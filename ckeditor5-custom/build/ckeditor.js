(function (t) {
  const e = (t['ru'] = t['ru'] || {});
  e.dictionary = Object.assign(e.dictionary || {}, {
    '%0 of %1': '%0 из %1',
    'Align center': 'Выравнивание по центру',
    'Align left': 'Выравнивание по левому краю',
    'Align right': 'Выравнивание по правому краю',
    'Almost equal to': 'Почти равный',
    Angle: 'Угол',
    'Approximately equal to':
      'Конгруэнтность (геометрическое равенство)',
    Aquamarine: 'Аквамариновый',
    'Asterisk operator': 'Оператор звездочка',
    'Austral sign': 'Символ аргентинского аустраля',
    'back with leftwards arrow above':
      'Стрелка влево над словом BACK (назад)',
    Big: 'Крупный',
    'Bitcoin sign': 'Символ биткоина',
    Black: 'Чёрный',
    Blue: 'Синий',
    'Blue marker': 'Выделение синим маркером',
    Bold: 'Жирный',
    'Break text': 'Разрывать текст',
    'Bulleted List': 'Маркированный список',
    Cancel: 'Отмена',
    'Cedi sign': 'Символ ганского седи',
    'Cent sign': 'Символ цента',
    'Centered image': 'Выравнивание по центру',
    'Change image text alternative':
      'Редактировать альтернативный текст',
    'Character categories': 'Категории',
    'Colon sign': 'Символ двоеточия',
    'Contains as member': 'Содержит как член',
    'Copyright sign': 'Знак авторского права',
    'Cruzeiro sign': 'Символ бразильского крузейро',
    'Currency sign': 'Символ валюты',
    'Decrease indent': 'Уменьшить отступ',
    Default: 'По умолчанию',
    'Degree sign': 'Знак градуса',
    'Dim grey': 'Тёмно-серый',
    'Division sign': 'Знак деления',
    'Document colors': 'Цвет страницы',
    'Dollar sign': 'Символ доллара',
    'Dong sign': 'Символ донга',
    'Double dagger': 'Двойной крестик',
    'Double exclamation mark': 'Двойной восклицательный знак',
    'Double low-9 quotation mark':
      'Нижняя двойная открывающая кавычка',
    'Double question mark': 'Двойной вопросительный знак',
    Downloadable: 'Загружаемые',
    'downwards arrow to bar': 'Стрелка вниз, упирающаяся в планку',
    'downwards dashed arrow': 'Пунктирная стрелка вниз',
    'downwards double arrow': 'Двойная стрелка вниз',
    'Drachma sign': 'Символ драхмы',
    'Dropdown toolbar': 'Выпадающая панель инструментов',
    'Edit block': 'Редактировать блок',
    'Edit link': 'Редактировать ссылку',
    'Editor block content toolbar': '',
    'Editor contextual toolbar': '',
    'Editor editing area: %0': 'Область редактирования редактора: %0',
    'Editor toolbar': 'Панель инструментов редактора',
    'Element of': 'Принадлежит',
    'Em dash': 'Длинное тире',
    'Empty set': 'Пустое множество',
    'En dash': 'Среднее тире',
    'end with leftwards arrow above':
      'Стрелка влево над словом END (конец)',
    'Euro sign': 'Символ евро',
    'Euro-currency sign': 'Символ евровалюты',
    'Exclamation question mark':
      'Восклицательный вопросительный знак',
    'Font Background Color': 'Цвет фона',
    'Font Color': 'Цвет шрифта',
    'Font Size': 'Размер шрифта',
    'For all': 'Для всех',
    'Fraction slash': 'Дробная наклонная черта',
    'French franc sign': 'Символ французского франка',
    'Full size image': 'Оригинальный размер изображения',
    'German penny sign': 'Символ немецкого пенни',
    'Greater-than or equal to': 'Больше либо равно',
    'Greater-than sign': 'Знак больше',
    Green: 'Зелёный',
    'Green marker': 'Выделение зелёным маркером',
    'Green pen': 'Зеленый цвет текста',
    Grey: 'Серый',
    'Guarani sign': 'Символ гуарани',
    Highlight: 'Выделить',
    'Horizontal ellipsis': 'Многоточие',
    'Hryvnia sign': 'Символ гривны',
    Huge: 'Очень крупный',
    'Identical to': 'Тождественно равно',
    'Image resize list': 'Список размеров',
    'image widget': 'Виджет изображений',
    'In line': 'В тексте',
    'Increase indent': 'Увеличить отступ',
    'Indian rupee sign': 'Символ индийской рупии',
    Infinity: 'Бесконечность',
    Insert: 'Вставить',
    'Insert image': 'Вставить изображение',
    'Insert image via URL': 'Вставить изображение по URL',
    'Insert paragraph after block': 'Вставить параграф после блока',
    'Insert paragraph before block': 'Вставить параграф перед блоком',
    Integral: 'Интеграл',
    Intersection: 'Пересечение',
    'Inverted exclamation mark': 'Перевернутый восклицательный знак',
    'Inverted question mark': 'Перевернутый вопросительный знак',
    Italic: 'Курсив',
    Justify: 'Выравнивание по ширине',
    'Kip sign': 'Символ кипа',
    'Latin capital letter a with breve':
      'Латинская заглавная буква «A» с бревисом',
    'Latin capital letter a with macron':
      'Латинская заглавная буква «A» с макроном',
    'Latin capital letter a with ogonek':
      'Латинская заглавная буква «A» с огонеком',
    'Latin capital letter c with acute':
      'Латинская заглавная буква «C» с акутом',
    'Latin capital letter c with caron':
      'Латинская заглавная буква «C» с гачеком',
    'Latin capital letter c with circumflex':
      'Латинская заглавная буква «C» с циркумфлексом',
    'Latin capital letter c with dot above':
      'Латинская заглавная буква «C» с точкой сверху',
    'Latin capital letter d with caron':
      'Латинская заглавная буква «D» с гачеком',
    'Latin capital letter d with stroke':
      'Латинская заглавная буква «D» со штрихом',
    'Latin capital letter e with breve':
      'Латинская заглавная буква «E» с бревисом',
    'Latin capital letter e with caron':
      'Латинская заглавная буква «E» с гачеком',
    'Latin capital letter e with dot above':
      'Латинская заглавная буква «E» с точкой сверху',
    'Latin capital letter e with macron':
      'Латинская заглавная буква «E» с макроном',
    'Latin capital letter e with ogonek':
      'Латинская заглавная буква «E» с огонеком',
    'Latin capital letter eng': 'Латинская заглавная буква энг',
    'Latin capital letter g with breve':
      'Латинская заглавная буква «G» с бревисом',
    'Latin capital letter g with cedilla':
      'Латинская заглавная буква «G» с седилью',
    'Latin capital letter g with circumflex':
      'Латинская заглавная буква «G» с циркумфлексом',
    'Latin capital letter g with dot above':
      'Латинская заглавная буква «G» с точкой сверху',
    'Latin capital letter h with circumflex':
      'Латинская заглавная буква «H» с циркумфлексом',
    'Latin capital letter h with stroke':
      'Латинская заглавная буква «H» со штрихом',
    'Latin capital letter i with breve':
      'Латинская заглавная буква «I» с бревисом',
    'Latin capital letter i with dot above':
      'Латинская заглавная буква «I» с точкой сверху',
    'Latin capital letter i with macron':
      'Латинская заглавная буква «I» с макроном',
    'Latin capital letter i with ogonek':
      'Латинская заглавная буква «I» с огонеком',
    'Latin capital letter i with tilde':
      'Латинская заглавная буква «I» с тильдой',
    'Latin capital letter j with circumflex':
      'Латинская заглавная буква «J» с циркумфлексом',
    'Latin capital letter k with cedilla':
      'Латинская заглавная буква «K» с седилью',
    'Latin capital letter l with acute':
      'Латинская заглавная буква «L» с акутом',
    'Latin capital letter l with caron':
      'Латинская заглавная буква «L» с гачеком',
    'Latin capital letter l with cedilla':
      'Латинская заглавная буква «L» с седилью',
    'Latin capital letter l with middle dot':
      'Латинская заглавная буква «L» с внутристрочной точкой',
    'Latin capital letter l with stroke':
      'Латинская заглавная буква «L» со штрихом',
    'Latin capital letter n with acute':
      'Латинская заглавная буква «N» с акутом',
    'Latin capital letter n with caron':
      'Латинская заглавная буква «N» с гачеком',
    'Latin capital letter n with cedilla':
      'Латинская заглавная буква «N» с седилью',
    'Latin capital letter o with breve':
      'Латинская заглавная буква «O» с бревисом',
    'Latin capital letter o with double acute':
      'Латинская заглавная буква «O» с двойным акутом',
    'Latin capital letter o with macron':
      'Латинская заглавная буква «O» с макроном',
    'Latin capital letter r with acute':
      'Латинская заглавная буква «R» с акутом',
    'Latin capital letter r with caron':
      'Латинская заглавная буква «R» с гачеком',
    'Latin capital letter r with cedilla':
      'Латинская заглавная буква «R» с седилью',
    'Latin capital letter s with acute':
      'Латинская заглавная буква «S» с акутом',
    'Latin capital letter s with caron':
      'Латинская заглавная буква «S» с гачеком',
    'Latin capital letter s with cedilla':
      'Латинская заглавная буква «S» с седилью',
    'Latin capital letter s with circumflex':
      'Латинская заглавная буква «S» с циркумфлексом',
    'Latin capital letter t with caron':
      'Латинская заглавная буква «T» с гачеком',
    'Latin capital letter t with cedilla':
      'Латинская заглавная буква «T» с седилью',
    'Latin capital letter t with stroke':
      'Латинская заглавная буква «T» со штрихом',
    'Latin capital letter u with breve':
      'Латинская заглавная буква «U» с бревисом',
    'Latin capital letter u with double acute':
      'Латинская заглавная буква «U» с двойным акутом',
    'Latin capital letter u with macron':
      'Латинская заглавная буква «U» с макроном',
    'Latin capital letter u with ogonek':
      'Латинская заглавная буква «U» с огонеком',
    'Latin capital letter u with ring above':
      'Латинская заглавная буква «U» с кружком сверху',
    'Latin capital letter u with tilde':
      'Латинская заглавная буква «U» с тильдой',
    'Latin capital letter w with circumflex':
      'Латинская заглавная буква «W» с циркумфлексом',
    'Latin capital letter y with circumflex':
      'Латинская заглавная буква «Y» с циркумфлексом',
    'Latin capital letter y with diaeresis':
      'Латинская заглавная буква «Y» с диэрезисом',
    'Latin capital letter z with acute':
      'Латинская заглавная буква «Z» с акутом',
    'Latin capital letter z with caron':
      'Латинская заглавная буква «Z» с гачеком',
    'Latin capital letter z with dot above':
      'Латинская заглавная буква «Z» с точкой сверху',
    'Latin capital ligature ij': 'Латинская заглавная лигатура «IJ»',
    'Latin capital ligature oe': 'Латинская заглавная лигатура OE',
    'Latin small letter a with breve':
      'Латинская строчная буква «a» с бревисом',
    'Latin small letter a with macron':
      'Латинская строчная буква «a» с макроном',
    'Latin small letter a with ogonek':
      'Латинская строчная буква «a» с огонеком',
    'Latin small letter c with acute':
      'Латинская строчная буква «c» с акутом',
    'Latin small letter c with caron':
      'Латинская строчная буква «c» с гачеком',
    'Latin small letter c with circumflex':
      'Латинская строчная буква «c» с циркумфлексом',
    'Latin small letter c with dot above':
      'Латинская строчная буква «c» с точкой сверху',
    'Latin small letter d with caron':
      'Латинская строчная буква «d» с гачеком',
    'Latin small letter d with stroke':
      'Латинская строчная буква «d» со штрихом',
    'Latin small letter dotless i':
      'Латинская строчная буква «i» без точки',
    'Latin small letter e with breve':
      'Латинская строчная буква «e» с бревисом',
    'Latin small letter e with caron':
      'Латинская строчная буква «e» с гачеком',
    'Latin small letter e with dot above':
      'Латинская строчная буква «e» с точкой сверху',
    'Latin small letter e with macron':
      'Латинская строчная буква «e» с макроном',
    'Latin small letter e with ogonek':
      'Латинская строчная буква «e» с огонеком',
    'Latin small letter eng': 'Латинская строчная буква энг',
    'Latin small letter f with hook':
      'Латинская строчная буква «f» с хвостиком',
    'Latin small letter g with breve':
      'Латинская строчная буква «g» с бревисом',
    'Latin small letter g with cedilla':
      'Латинская строчная буква «g» с седилью',
    'Latin small letter g with circumflex':
      'Латинская строчная буква «g» с циркумфлексом',
    'Latin small letter g with dot above':
      'Латинская строчная буква «g» с точкой сверху',
    'Latin small letter h with circumflex':
      'Латинская строчная буква «h» с циркумфлексом',
    'Latin small letter h with stroke':
      'Латинская строчная буква «h» со штрихом',
    'Latin small letter i with breve':
      'Латинская строчная буква «i» с бревисом',
    'Latin small letter i with macron':
      'Латинская строчная буква «i» с макроном',
    'Latin small letter i with ogonek':
      'Латинская строчная буква «i» с огонеком',
    'Latin small letter i with tilde':
      'Латинская строчная буква «i» с тильдой',
    'Latin small letter j with circumflex':
      'Латинская строчная буква «j» с циркумфлексом',
    'Latin small letter k with cedilla':
      'Латинская строчная буква «k» с седилью',
    'Latin small letter kra': 'Латинская строчная буква кра',
    'Latin small letter l with acute':
      'Латинская строчная буква «l» с акутом',
    'Latin small letter l with caron':
      'Латинская строчная буква «l» с гачеком',
    'Latin small letter l with cedilla':
      'Латинская строчная буква «l» с седилью',
    'Latin small letter l with middle dot':
      'Латинская строчная буква «l» с внутристрочной точкой',
    'Latin small letter l with stroke':
      'Латинская строчная буква «l» со штрихом',
    'Latin small letter long s':
      'Латинская строчная буква длинная «s»',
    'Latin small letter n preceded by apostrophe':
      'Латинская строчная буква «n» с предшествующим апострофом',
    'Latin small letter n with acute':
      'Латинская строчная буква «n» с акутом',
    'Latin small letter n with caron':
      'Латинская строчная буква «n» с гачеком',
    'Latin small letter n with cedilla':
      'Латинская строчная буква «n» с седилью',
    'Latin small letter o with breve':
      'Латинская строчная буква «o» с бревисом',
    'Latin small letter o with double acute':
      'Латинская строчная буква «o» с двойным акутом',
    'Latin small letter o with macron':
      'Латинская строчная буква «o» с макроном',
    'Latin small letter r with acute':
      'Латинская строчная буква «r» с акутом',
    'Latin small letter r with caron':
      'Латинская строчная буква «r» с гачеком',
    'Latin small letter r with cedilla':
      'Латинская строчная буква «r» с седилью',
    'Latin small letter s with acute':
      'Латинская строчная буква «s» с акутом',
    'Latin small letter s with caron':
      'Латинская строчная буква «s» с гачеком',
    'Latin small letter s with cedilla':
      'Латинская строчная буква «s» с седилью',
    'Latin small letter s with circumflex':
      'Латинская строчная буква «s» с циркумфлексом',
    'Latin small letter t with caron':
      'Латинская строчная буква «t» с гачеком',
    'Latin small letter t with cedilla':
      'Латинская строчная буква «t» с седилью',
    'Latin small letter t with stroke':
      'Латинская строчная буква «t» со штрихом',
    'Latin small letter u with breve':
      'Латинская строчная буква «u» с бревисом',
    'Latin small letter u with double acute':
      'Латинская строчная буква «u» с двойным акутом',
    'Latin small letter u with macron':
      'Латинская строчная буква «u» с макроном',
    'Latin small letter u with ogonek':
      'Латинская строчная буква «u» с огонеком',
    'Latin small letter u with ring above':
      'Латинская строчная буква «u» с кружком сверху',
    'Latin small letter u with tilde':
      'Латинская строчная буква «u» с тильдой',
    'Latin small letter w with circumflex':
      'Латинская строчная буква «w» с циркумфлексом',
    'Latin small letter y with circumflex':
      'Латинская строчная буква «y» с циркумфлексом',
    'Latin small letter z with acute':
      'Латинская строчная буква «z» с акутом',
    'Latin small letter z with caron':
      'Латинская строчная буква «z» с гачеком',
    'Latin small letter z with dot above':
      'Латинская строчная буква «z» с точкой сверху',
    'Latin small ligature ij': 'Латинская строчная лигатура «ij»',
    'Latin small ligature oe': 'Латинская строчная лигатура oe',
    'Left aligned image': 'Выравнивание по левому краю',
    'Left double quotation mark': 'Открывающая двойная кавычка',
    'Left single quotation mark': 'Открывающая одинарная кавычка',
    'Left-pointing double angle quotation mark':
      'Открывающая левая кавычка «ёлочка»',
    'leftwards arrow to bar': 'Стрелка влево, упирающаяся в планку',
    'leftwards dashed arrow': 'Пунктирная стрелка влево',
    'leftwards double arrow': 'Двойная стрелка влево',
    'Less-than or equal to': 'Меньше либо равно',
    'Less-than sign': 'Знак меньше',
    'Light blue': 'Голубой',
    'Light green': 'Салатовый',
    'Light grey': 'Светло-серый',
    Link: 'Ссылка',
    'Link URL': 'Ссылка URL',
    'Lira sign': 'Символ лиры',
    'Livre tournois sign': 'Символ турского ливра',
    'Logical and': 'Логическое И',
    'Logical or': 'Логическое ИЛИ',
    Macron: 'Макрон',
    'Manat sign': 'Символ маната',
    'Mill sign': 'Символ милль',
    'Minus sign': 'Знак минус',
    'Multiplication sign': 'Знак умножения',
    'N-ary product': 'N-арное произведение',
    'N-ary summation': 'N-арная сумма',
    Nabla: 'Набла',
    'Naira sign': 'Символ найры',
    'New sheqel sign': 'Символ нового шекеля',
    Next: 'Следующий',
    'Nordic mark sign': 'Символ скандинавской марки',
    'Not an element of': 'Не принадлежит',
    'Not equal to': 'Не равно',
    'Not sign': 'Знак отрицания',
    'Numbered List': 'Нумерованный список',
    'on with exclamation mark with left right arrow above':
      'Стрелка влево и вправо над словом ON! (включить)',
    'Open in a new tab': 'Открыть в новой вкладке',
    'Open link in new tab': 'Открыть ссылку в новой вкладке',
    Orange: 'Оранжевый',
    Original: 'Оригинальный',
    Overline: 'Надчёркивание',
    'Paragraph sign': 'Знак абзаца',
    'Partial differential': 'Частичный дифференциал',
    'Per mille sign': 'Знак промилле',
    'Per ten thousand sign': 'Знак на десять тысяч',
    'Peseta sign': 'Символ песеты',
    'Peso sign': 'Символ песо',
    'Pink marker': 'Выделение розовым маркером',
    'Plus-minus sign': 'Знак плюс-минус',
    'Pound sign': 'Символ фунта стерлингов',
    Previous: 'Предыдущий',
    'Proportional to': 'Пропорционально',
    Purple: 'Фиолетовый',
    'Question exclamation mark':
      'Вопросительный восклицательный знак',
    Red: 'Красный',
    'Red pen': 'Красный цвет текста',
    Redo: 'Повторить',
    'Registered sign': 'Зарегистрированный товарный знак',
    'Remove color': 'Убрать цвет',
    'Remove Format': 'Убрать форматирование',
    'Remove highlight': 'Убрать выделение',
    'Resize image': 'Изменить размер изображения',
    'Resize image to %0': 'Изменить размер изображения до %0',
    'Resize image to the original size':
      'Вернуть размер изображения к оригинальному',
    'Reversed paragraph sign': 'Обратный знак абзаца',
    'Rich Text Editor': 'Редактор',
    'Right aligned image': 'Выравнивание по правому краю',
    'Right double quotation mark': 'Закрывающая двойная кавычка',
    'Right single quotation mark': 'Закрывающая одинарная кавычка',
    'Right-pointing double angle quotation mark':
      'Закрывающая правая кавычка «ёлочка»',
    'rightwards arrow to bar': 'Стрелка вправо, упирающаяся в планку',
    'rightwards dashed arrow': 'Пунктирная стрелка вправо',
    'rightwards double arrow': 'Двойная стрелка вправо',
    'Ruble sign': 'Символ рубля',
    'Rupee sign': 'Символ рупии',
    Save: 'Сохранить',
    'Section sign': 'Параграф',
    'Select all': 'Выбрать все',
    'Show more items': 'Другие инструменты',
    'Side image': 'Боковое изображение',
    'Single left-pointing angle quotation mark':
      'Одинарная открывающая (левая) французская угловая кавычка',
    'Single low-9 quotation mark':
      'Нижняя одинарная открывающая кавычка',
    'Single right-pointing angle quotation mark':
      'Одинарная закрывающая (правая) французская угловая кавычка',
    Small: 'Мелкий',
    'soon with rightwards arrow above':
      'Стрелка вправо над словом SOON (скоро)',
    'Special characters': 'Спецсимволы',
    'Spesmilo sign': 'Символ спесмило',
    'Square root': 'Квадратный корень',
    Strikethrough: 'Зачеркнутый',
    Subscript: 'Подстрочный',
    Superscript: 'Надстрочный',
    'Tenge sign': 'Символ тенге',
    'Text alignment': 'Выравнивание текста',
    'Text alignment toolbar': 'Выравнивание',
    'Text alternative': 'Альтернативный текст',
    'Text highlight toolbar': 'Панель инструментов выделения текста',
    'There exists': 'Существует',
    'This link has no URL': 'Для этой ссылки не установлен адрес URL',
    'Tilde operator': 'Оператор тильда',
    Tiny: 'Очень мелкий',
    'top with upwards arrow above':
      'Стрелка вверх над словом TOP (верх)',
    'Trade mark sign': 'Знак торговой марки',
    'Tugrik sign': 'Символ тугрика',
    'Turkish lira sign': 'Символ турецкой лиры',
    Turquoise: 'Бирюзовый',
    'Two dot leader': 'Двухточечный пунктир',
    Underline: 'Подчеркнутый',
    Undo: 'Отменить',
    Union: 'Объединение',
    Unlink: 'Убрать ссылку',
    'up down arrow with base': 'Стрелка вверх и вниз от планки внизу',
    Update: 'Изменить',
    'Update image URL': 'Изменить URL изображения',
    'Upload failed': 'Загрузка не выполнена',
    'Upload in progress': 'Идёт загрузка',
    'upwards arrow to bar': 'Стрелка вверх, упирающаяся в планку',
    'upwards dashed arrow': 'Пунктирная стрелка вверх',
    'upwards double arrow': 'Двойная стрелка вверх',
    'Vulgar fraction one half': 'Дробь – одна вторая',
    'Vulgar fraction one quarter': 'Дробь – одна четверть',
    'Vulgar fraction three quarters': 'Дробь – три четверти',
    White: 'Белый',
    'Widget toolbar': 'Панель инструментов виджета',
    'Won sign': 'Символ воны',
    'Wrap text': 'Обтекать текст',
    Yellow: 'Жёлтый',
    'Yellow marker': 'Выделение жёлтым маркером',
    'Yen sign': 'Символ иены',
  });
  e.getPluralForm = function (t) {
    return t % 10 == 1 && t % 100 != 11
      ? 0
      : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 12 || t % 100 > 14)
      ? 1
      : t % 10 == 0 ||
        (t % 10 >= 5 && t % 10 <= 9) ||
        (t % 100 >= 11 && t % 100 <= 14)
      ? 2
      : 3;
  };
})(
  window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})
);
/*!
 * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */ (function t(e, n) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = n();
  else if (typeof define === 'function' && define.amd) define([], n);
  else if (typeof exports === 'object')
    exports['ClassicEditor'] = n();
  else e['ClassicEditor'] = n();
})(self, () =>
  (() => {
    'use strict';
    var t = {
      390: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css',
            ],
            names: [],
            mappings:
              'AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      3638: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      8894: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css',
            ],
            names: [],
            mappings:
              'AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      4401: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css',
            ],
            names: [],
            mappings: 'AAMA,qDACC,YACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      2585: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-button.ck-color-table__remove-color{align-items:center;display:flex;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontcolor.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-font/fontcolor.css',
            ],
            names: [],
            mappings:
              'AAKA,4CAEC,kBAAmB,CADnB,YAAa,CAEb,UACD,CAEA,8BACC,iBACD,CCNA,4CAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,wDACC,mDACD,CAEA,kEAEE,uCAMF,CARA,kEAME,sCAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-button.ck-color-table__remove-color {\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 100%;\n}\n\nlabel.ck.ck-color-grid__label {\n\tfont-weight: unset;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck .ck-button.ck-color-table__remove-color {\n\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\n\tborder-bottom-left-radius: 0;\n\tborder-bottom-right-radius: 0;\n\n\t&:not(:focus) {\n\t\tborder-bottom: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n}\n\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      6203: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css',
            ],
            names: [],
            mappings:
              'AAUC,uBACC,cACD,CAEA,wBACC,eACD,CAEA,sBACC,eACD,CAEA,uBACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* The values should be synchronized with the "FONT_SIZE_PRESET_UNITS" object in the "/src/fontsize/utils.js" file. */\n\n/* Styles should be prefixed with the `.ck-content` class.\nSee https://github.com/ckeditor/ckeditor5/issues/6636 */\n.ck-content {\n\t& .text-tiny {\n\t\tfont-size: .7em;\n\t}\n\n\t& .text-small {\n\t\tfont-size: .85em;\n\t}\n\n\t& .text-big {\n\t\tfont-size: 1.4em;\n\t}\n\n\t& .text-huge {\n\t\tfont-size: 1.8em;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      713: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-highlight-marker-yellow:#fdfd77;--ck-highlight-marker-green:#62f962;--ck-highlight-marker-pink:#fc7899;--ck-highlight-marker-blue:#72ccfd;--ck-highlight-pen-red:#e71313;--ck-highlight-pen-green:#128a00}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{background-color:transparent;color:var(--ck-highlight-pen-red)}.ck-content .pen-green{background-color:transparent;color:var(--ck-highlight-pen-green)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-highlight/theme/highlight.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,oCAA+C,CAC/C,mCAA+C,CAC/C,kCAA8C,CAC9C,kCAA8C,CAC9C,8BAAwC,CACxC,gCACD,CAGC,2BACC,kDACD,CAFA,0BACC,iDACD,CAFA,yBACC,gDACD,CAFA,yBACC,gDACD,CAIA,qBAIC,4BAA6B,CAH7B,iCAID,CALA,uBAIC,4BAA6B,CAH7B,mCAID',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-highlight-marker-yellow: hsl(60, 97%, 73%);\n\t--ck-highlight-marker-green: hsl(120, 93%, 68%);\n\t--ck-highlight-marker-pink: hsl(345, 96%, 73%);\n\t--ck-highlight-marker-blue: hsl(201, 97%, 72%);\n\t--ck-highlight-pen-red: hsl(0, 85%, 49%);\n\t--ck-highlight-pen-green: hsl(112, 100%, 27%);\n}\n\n@define-mixin highlight-marker-color $color {\n\t.ck-content .marker-$color {\n\t\tbackground-color: var(--ck-highlight-marker-$color);\n\t}\n}\n\n@define-mixin highlight-pen-color $color {\n\t.ck-content .pen-$color {\n\t\tcolor: var(--ck-highlight-pen-$color);\n\n\t\t/* Override default yellow background of `<mark>` from user agent stylesheet */\n\t\tbackground-color: transparent;\n\t}\n}\n\n@mixin highlight-marker-color yellow;\n@mixin highlight-marker-color green;\n@mixin highlight-marker-color pink;\n@mixin highlight-marker-color blue;\n\n@mixin highlight-pen-color red;\n@mixin highlight-pen-color green;\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      9048: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css',
            ],
            names: [],
            mappings:
              'AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      9292: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsert.css',
            ],
            names: [],
            mappings:
              'AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert__panel {\n\tpadding: var(--ck-spacing-large);\n}\n\n.ck.ck-image-insert__ck-finder-button {\n\tdisplay: block;\n\twidth: 100%;\n\tmargin: var(--ck-spacing-standard) auto;\n\tborder: 1px solid hsl(0, 0%, 80%);\n\tborder-radius: var(--ck-border-radius);\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\n\tpadding: 0;\n\tmargin: 0;\n\tborder: none;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      5150: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsertformrowview.css',
            ],
            names: [],
            mappings:
              'AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert-form {\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n}\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-image-insert-form__action-row {\n\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      1043: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css',
            ],
            names: [],
            mappings:
              'AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image.image_resized {\n\tmax-width: 100%;\n\t/*\n\tThe `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n\tFortunately, since we control the width, there is no risk that the image will look bad.\n\t*/\n\tdisplay: block;\n\tbox-sizing: border-box;\n\n\t& img {\n\t\t/* For resized images it is the `<figure>` element that determines the image width. */\n\t\twidth: 100%;\n\t}\n\n\t& > figcaption {\n\t\t/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n\t\tdisplay: block;\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/* The resized inline image nested in the table should respect its parent size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline.image_resized img {\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n\twidth: 4em;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      4622: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      9899: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css',
            ],
            names: [],
            mappings:
              'AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      9825: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css',
            ],
            names: [],
            mappings:
              'AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      5870: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css',
            ],
            names: [],
            mappings:
              'AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      6831: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
            ],
            names: [],
            mappings:
              'AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      399: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css',
            ],
            names: [],
            mappings:
              'AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      9465: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css',
            ],
            names: [],
            mappings:
              'AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      4827: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css',
            ],
            names: [],
            mappings:
              'AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      4046: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-character-grid{max-width:100%}.ck.ck-character-grid .ck-character-grid__tiles{display:grid}:root{--ck-character-grid-tile-size:24px}.ck.ck-character-grid{max-height:200px;overflow-x:hidden;overflow-y:auto;width:350px}@media screen and (max-width:600px){.ck.ck-character-grid{width:190px}}.ck.ck-character-grid .ck-character-grid__tiles{grid-gap:var(--ck-spacing-standard);grid-template-columns:repeat(10,1fr);margin:var(--ck-spacing-standard) var(--ck-spacing-large)}@media screen and (max-width:600px){.ck.ck-character-grid .ck-character-grid__tiles{grid-template-columns:repeat(5,1fr)}}.ck.ck-character-grid .ck-character-grid__tile{border:0;font-size:1.2em;height:var(--ck-character-grid-tile-size);min-height:var(--ck-character-grid-tile-size);min-width:var(--ck-character-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-character-grid-tile-size)}.ck.ck-character-grid .ck-character-grid__tile:focus:not(.ck-disabled),.ck.ck-character-grid .ck-character-grid__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-character-grid .ck-character-grid__tile .ck-button__label{line-height:var(--ck-character-grid-tile-size);text-align:center;width:100%}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/charactergrid.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/charactergrid.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
            ],
            names: [],
            mappings:
              'AAKA,sBACC,cAKD,CAHC,gDACC,YACD,CCFD,MACC,kCACD,CAEA,sBAIC,gBAAiB,CAFjB,iBAAkB,CADlB,eAAgB,CAEhB,WAyCD,CClDC,oCDMD,sBAOE,WAqCF,CChDC,CDcA,gDAGC,mCAAoC,CAFpC,oCAAsC,CACtC,yDAMD,CCxBA,oCDgBA,gDAME,mCAEF,CCtBA,CDwBA,+CAQC,QAAS,CAHT,eAAgB,CAHhB,yCAA0C,CAE1C,6CAA8C,CAD9C,4CAA6C,CAG7C,SAAU,CACV,8BAA+B,CAN/B,wCAsBD,CAbC,8IAGC,QAAS,CACT,iGACD,CAGA,iEACC,8CAA+C,CAE/C,iBAAkB,CADlB,UAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-grid {\n\tmax-width: 100%;\n\t\n\t& .ck-character-grid__tiles {\n\t\tdisplay: grid;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-character-grid-tile-size: 24px;\n}\n\n.ck.ck-character-grid {\n\toverflow-y: auto;\n\toverflow-x: hidden;\n\twidth: 350px;\n\tmax-height: 200px;\n\n\t@mixin ck-media-phone {\n\t\twidth: 190px;\n\t}\n\n\t& .ck-character-grid__tiles {\n\t\tgrid-template-columns: repeat(10, 1fr);\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\t\tgrid-gap: var(--ck-spacing-standard);\n\n\t\t@mixin ck-media-phone {\n\t\t\tgrid-template-columns: repeat(5, 1fr);\n\t\t}\n\t}\n\n\t& .ck-character-grid__tile {\n\t\twidth: var(--ck-character-grid-tile-size);\n\t\theight: var(--ck-character-grid-tile-size);\n\t\tmin-width: var(--ck-character-grid-tile-size);\n\t\tmin-height: var(--ck-character-grid-tile-size);\n\t\tfont-size: 1.2em;\n\t\tpadding: 0;\n\t\ttransition: .2s ease box-shadow;\n\t\tborder: 0;\n\n\t\t&:focus:not( .ck-disabled ),\n\t\t&:hover:not( .ck-disabled ) {\n\t\t\t/* Disable the default .ck-button\'s border ring. */\n\t\t\tborder: 0;\n\t\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t\t}\n\n\t\t/* Make sure the glyph is rendered in the center of the button */\n\t\t& .ck-button__label {\n\t\t\tline-height: var(--ck-character-grid-tile-size);\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      4779: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-character-info{border-top:1px solid var(--ck-color-base-border);display:flex;justify-content:space-between;padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-character-info>*{font-size:var(--ck-font-size-small);text-transform:uppercase}.ck.ck-character-info .ck-character-info__name{max-width:280px;overflow:hidden;text-overflow:ellipsis}.ck.ck-character-info .ck-character-info__code{opacity:.6}@media screen and (max-width:600px){.ck.ck-character-info{max-width:190px}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/characterinfo.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/characterinfo.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
            ],
            names: [],
            mappings:
              'AAKA,sBCIC,gDAAiD,CDHjD,YAAa,CACb,6BAA8B,CCC9B,uDDAD,CCGC,wBAEC,mCAAoC,CADpC,wBAED,CAEA,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,+CACC,UACD,CClBA,oCDCD,sBAoBE,eAEF,CCrBC',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-info {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-character-info {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t& > * {\n\t\ttext-transform: uppercase;\n\t\tfont-size: var(--ck-font-size-small);\n\t}\n\n\t& .ck-character-info__name {\n\t\tmax-width: 280px;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t}\n\n\t& .ck-character-info__code {\n\t\topacity: .6;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tmax-width: 190px;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      8170: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-special-characters-navigation>.ck-label{max-width:160px;overflow:hidden;text-overflow:ellipsis}.ck.ck-special-characters-navigation>.ck-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}@media screen and (max-width:600px){.ck.ck-special-characters-navigation{max-width:190px}.ck.ck-special-characters-navigation>.ck-form__header__label{overflow:hidden;text-overflow:ellipsis}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/specialcharacters.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
            ],
            names: [],
            mappings:
              'AAUC,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,sEAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED,CCfA,oCDED,qCAgBE,eAOF,CALE,6DAEC,eAAgB,CADhB,sBAED,CCrBD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-special-characters-navigation {\n\n\t& > .ck-label {\n\t\tmax-width: 160px;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t}\n\n\t& > .ck-dropdown .ck-dropdown__panel {\n\t\t/* There could be dozens of categories available. Use scroll to prevent a 10e6px dropdown. */\n\t\tmax-height: 250px;\n\t\toverflow-y: auto;\n\t\toverflow-x: hidden;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tmax-width: 190px;\n\n\t\t& > .ck-form__header__label {\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      4499: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
            ],
            names: [],
            mappings:
              'AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      9681: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton:active{background:transparent}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
            ],
            names: [],
            mappings:
              'AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAGC,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDC3BA,eDmEA,CAxCA,yICvBC,qCD+DD,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2EC/CD,eD0DC,CAXA,6LC3CA,qCAAsC,CD6CpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEvEA,kCFyEA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAIA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF,CAKF,gFACC,sBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Regular buttons get a backgound when active. Switch buttons announce that through the switch toggle instead */\n\t&:active, &.ck-on:active {\n\t\tbackground: transparent;\n\t}\n\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      4923: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css',
            ],
            names: [],
            mappings:
              'AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      3488: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      6875: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      66: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CASA,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCC7EA,eDuFA,CAVA,qHCzEC,qCDmFD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      5075: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      4547: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      5523: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css',
            ],
            names: [],
            mappings:
              'AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      1174: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css',
            ],
            names: [],
            mappings:
              'AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAY1B,qBAcD,CAZC,0BARA,aAAc,CAGd,cAgBA,CAJC,yBAEC,iBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\tcolor: inherit;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\n\t\t/* Allows dynamic coloring of the icons. */\n\t\tcolor: inherit;\n\n\t\t&:not([fill]) {\n\t\t\t/* Needed by FF. */\n\t\t\tfill: currentColor;\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      6985: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      2751: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css',
            ],
            names: [],
            mappings: 'AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      8111: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-spacing-medium),calc(var(--ck-font-size-base)*.6)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-spacing-medium)*-1),calc(var(--ck-font-size-base)*.6)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,yEACD,CAEA,0BCHC,eD4GD,CAzGA,2FCCE,qCDwGF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,wFAYF,CAfA,oUAOE,iGAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-spacing-medium), calc(0.6 * var(--ck-font-size-base))) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-spacing-medium)), calc(0.6 * var(--ck-font-size-base))) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      1162: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      8245: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      1757: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css',
            ],
            names: [],
            mappings:
              'AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n',
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      3553: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      3609: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      1590: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css',
            ],
            names: [],
            mappings:
              'AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      6706: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css',
            ],
            names: [],
            mappings:
              'AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      5571: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDuFD,CA1FA,qECOE,qCDmFF,CA1FA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAsFD,CAnFC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CApFF,qCAwFE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      9948: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css',
            ],
            names: [],
            mappings:
              'AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      6150: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css',
            ],
            names: [],
            mappings:
              'AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CCnGhE,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJmGD,CI7FA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n',
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n',
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      6507: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          ':root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
              "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      2263: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css',
            ],
            names: [],
            mappings:
              'AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      5137: (t, e, n) => {
        n.d(e, { Z: () => c });
        var i = n(4015);
        var o = n.n(i);
        var r = n(3645);
        var s = n.n(r);
        var a = s()(o());
        a.push([
          t.id,
          '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css',
            ],
            names: [],
            mappings:
              'AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      3645: (t) => {
        t.exports = function (t) {
          var e = [];
          e.toString = function e() {
            return this.map(function (e) {
              var n = t(e);
              if (e[2]) {
                return '@media '.concat(e[2], ' {').concat(n, '}');
              }
              return n;
            }).join('');
          };
          e.i = function (t, n, i) {
            if (typeof t === 'string') {
              t = [[null, t, '']];
            }
            var o = {};
            if (i) {
              for (var r = 0; r < this.length; r++) {
                var s = this[r][0];
                if (s != null) {
                  o[s] = true;
                }
              }
            }
            for (var a = 0; a < t.length; a++) {
              var c = [].concat(t[a]);
              if (i && o[c[0]]) {
                continue;
              }
              if (n) {
                if (!c[2]) {
                  c[2] = n;
                } else {
                  c[2] = ''.concat(n, ' and ').concat(c[2]);
                }
              }
              e.push(c);
            }
          };
          return e;
        };
      },
      4015: (t) => {
        function e(t, e) {
          return s(t) || r(t, e) || i(t, e) || n();
        }
        function n() {
          throw new TypeError(
            'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
          );
        }
        function i(t, e) {
          if (!t) return;
          if (typeof t === 'string') return o(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          if (n === 'Object' && t.constructor) n = t.constructor.name;
          if (n === 'Map' || n === 'Set') return Array.from(t);
          if (
            n === 'Arguments' ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          )
            return o(t, e);
        }
        function o(t, e) {
          if (e == null || e > t.length) e = t.length;
          for (var n = 0, i = new Array(e); n < e; n++) {
            i[n] = t[n];
          }
          return i;
        }
        function r(t, e) {
          var n =
            t &&
            ((typeof Symbol !== 'undefined' && t[Symbol.iterator]) ||
              t['@@iterator']);
          if (n == null) return;
          var i = [];
          var o = true;
          var r = false;
          var s, a;
          try {
            for (
              n = n.call(t);
              !(o = (s = n.next()).done);
              o = true
            ) {
              i.push(s.value);
              if (e && i.length === e) break;
            }
          } catch (t) {
            r = true;
            a = t;
          } finally {
            try {
              if (!o && n['return'] != null) n['return']();
            } finally {
              if (r) throw a;
            }
          }
          return i;
        }
        function s(t) {
          if (Array.isArray(t)) return t;
        }
        t.exports = function t(n) {
          var i = e(n, 4),
            o = i[1],
            r = i[3];
          if (!r) {
            return o;
          }
          if (typeof btoa === 'function') {
            var s = btoa(
              unescape(encodeURIComponent(JSON.stringify(r)))
            );
            var a =
              'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(
                s
              );
            var c = '/*# '.concat(a, ' */');
            var l = r.sources.map(function (t) {
              return '/*# sourceURL='
                .concat(r.sourceRoot || '')
                .concat(t, ' */');
            });
            return [o].concat(l).concat([c]).join('\n');
          }
          return [o].join('\n');
        };
      },
      3379: (t, e, n) => {
        var i = (function t() {
          var e;
          return function t() {
            if (typeof e === 'undefined') {
              e = Boolean(
                window && document && document.all && !window.atob
              );
            }
            return e;
          };
        })();
        var o = (function t() {
          var e = {};
          return function t(n) {
            if (typeof e[n] === 'undefined') {
              var i = document.querySelector(n);
              if (
                window.HTMLIFrameElement &&
                i instanceof window.HTMLIFrameElement
              ) {
                try {
                  i = i.contentDocument.head;
                } catch (t) {
                  i = null;
                }
              }
              e[n] = i;
            }
            return e[n];
          };
        })();
        var r = [];
        function s(t) {
          var e = -1;
          for (var n = 0; n < r.length; n++) {
            if (r[n].identifier === t) {
              e = n;
              break;
            }
          }
          return e;
        }
        function a(t, e) {
          var n = {};
          var i = [];
          for (var o = 0; o < t.length; o++) {
            var a = t[o];
            var c = e.base ? a[0] + e.base : a[0];
            var l = n[c] || 0;
            var d = ''.concat(c, ' ').concat(l);
            n[c] = l + 1;
            var h = s(d);
            var u = { css: a[1], media: a[2], sourceMap: a[3] };
            if (h !== -1) {
              r[h].references++;
              r[h].updater(u);
            } else {
              r.push({
                identifier: d,
                updater: m(u, e),
                references: 1,
              });
            }
            i.push(d);
          }
          return i;
        }
        function c(t) {
          var e = document.createElement('style');
          var i = t.attributes || {};
          if (typeof i.nonce === 'undefined') {
            var r = true ? n.nc : 0;
            if (r) {
              i.nonce = r;
            }
          }
          Object.keys(i).forEach(function (t) {
            e.setAttribute(t, i[t]);
          });
          if (typeof t.insert === 'function') {
            t.insert(e);
          } else {
            var s = o(t.insert || 'head');
            if (!s) {
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
              );
            }
            s.appendChild(e);
          }
          return e;
        }
        function l(t) {
          if (t.parentNode === null) {
            return false;
          }
          t.parentNode.removeChild(t);
        }
        var d = (function t() {
          var e = [];
          return function t(n, i) {
            e[n] = i;
            return e.filter(Boolean).join('\n');
          };
        })();
        function h(t, e, n, i) {
          var o = n
            ? ''
            : i.media
            ? '@media '.concat(i.media, ' {').concat(i.css, '}')
            : i.css;
          if (t.styleSheet) {
            t.styleSheet.cssText = d(e, o);
          } else {
            var r = document.createTextNode(o);
            var s = t.childNodes;
            if (s[e]) {
              t.removeChild(s[e]);
            }
            if (s.length) {
              t.insertBefore(r, s[e]);
            } else {
              t.appendChild(r);
            }
          }
        }
        function u(t, e, n) {
          var i = n.css;
          var o = n.media;
          var r = n.sourceMap;
          if (o) {
            t.setAttribute('media', o);
          } else {
            t.removeAttribute('media');
          }
          if (r && typeof btoa !== 'undefined') {
            i +=
              '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
                btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
                ' */'
              );
          }
          if (t.styleSheet) {
            t.styleSheet.cssText = i;
          } else {
            while (t.firstChild) {
              t.removeChild(t.firstChild);
            }
            t.appendChild(document.createTextNode(i));
          }
        }
        var f = null;
        var g = 0;
        function m(t, e) {
          var n;
          var i;
          var o;
          if (e.singleton) {
            var r = g++;
            n = f || (f = c(e));
            i = h.bind(null, n, r, false);
            o = h.bind(null, n, r, true);
          } else {
            n = c(e);
            i = u.bind(null, n, e);
            o = function t() {
              l(n);
            };
          }
          i(t);
          return function e(n) {
            if (n) {
              if (
                n.css === t.css &&
                n.media === t.media &&
                n.sourceMap === t.sourceMap
              ) {
                return;
              }
              i((t = n));
            } else {
              o();
            }
          };
        }
        t.exports = function (t, e) {
          e = e || {};
          if (!e.singleton && typeof e.singleton !== 'boolean') {
            e.singleton = i();
          }
          t = t || [];
          var n = a(t, e);
          return function t(i) {
            i = i || [];
            if (
              Object.prototype.toString.call(i) !== '[object Array]'
            ) {
              return;
            }
            for (var o = 0; o < n.length; o++) {
              var c = n[o];
              var l = s(c);
              r[l].references--;
            }
            var d = a(i, e);
            for (var h = 0; h < n.length; h++) {
              var u = n[h];
              var f = s(u);
              if (r[f].references === 0) {
                r[f].updater();
                r.splice(f, 1);
              }
            }
            n = d;
          };
        };
      },
    };
    var e = {};
    function n(i) {
      var o = e[i];
      if (o !== undefined) {
        return o.exports;
      }
      var r = (e[i] = { id: i, exports: {} });
      t[i](r, r.exports, n);
      return r.exports;
    }
    (() => {
      n.n = (t) => {
        var e = t && t.__esModule ? () => t['default'] : () => t;
        n.d(e, { a: e });
        return e;
      };
    })();
    (() => {
      n.d = (t, e) => {
        for (var i in e) {
          if (n.o(e, i) && !n.o(t, i)) {
            Object.defineProperty(t, i, {
              enumerable: true,
              get: e[i],
            });
          }
        }
      };
    })();
    (() => {
      n.g = (function () {
        if (typeof globalThis === 'object') return globalThis;
        try {
          return this || new Function('return this')();
        } catch (t) {
          if (typeof window === 'object') return window;
        }
      })();
    })();
    (() => {
      n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
    })();
    (() => {
      n.nc = undefined;
    })();
    var i = {};
    (() => {
      n.d(i, { default: () => BF });
      function t() {
        return function t() {
          t.called = true;
        };
      }
      const e = t;
      class o {
        constructor(t, n) {
          this.source = t;
          this.name = n;
          this.path = [];
          this.stop = e();
          this.off = e();
        }
      }
      const r = new Array(256)
        .fill('')
        .map((t, e) => ('0' + e.toString(16)).slice(-2));
      function s() {
        const t = (Math.random() * 4294967296) >>> 0;
        const e = (Math.random() * 4294967296) >>> 0;
        const n = (Math.random() * 4294967296) >>> 0;
        const i = (Math.random() * 4294967296) >>> 0;
        return (
          'e' +
          r[(t >> 0) & 255] +
          r[(t >> 8) & 255] +
          r[(t >> 16) & 255] +
          r[(t >> 24) & 255] +
          r[(e >> 0) & 255] +
          r[(e >> 8) & 255] +
          r[(e >> 16) & 255] +
          r[(e >> 24) & 255] +
          r[(n >> 0) & 255] +
          r[(n >> 8) & 255] +
          r[(n >> 16) & 255] +
          r[(n >> 24) & 255] +
          r[(i >> 0) & 255] +
          r[(i >> 8) & 255] +
          r[(i >> 16) & 255] +
          r[(i >> 24) & 255]
        );
      }
      const a = {
        get(t = 'normal') {
          if (typeof t != 'number') {
            return this[t] || this.normal;
          } else {
            return t;
          }
        },
        highest: 1e5,
        high: 1e3,
        normal: 0,
        low: -1e3,
        lowest: -1e5,
      };
      const c = a;
      function l(t, e) {
        const n = c.get(e.priority);
        for (let i = 0; i < t.length; i++) {
          if (c.get(t[i].priority) < n) {
            t.splice(i, 0, e);
            return;
          }
        }
        t.push(e);
      }
      const d =
        'https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html';
      class h extends Error {
        constructor(t, e, n) {
          super(m(t, n));
          this.name = 'CKEditorError';
          this.context = e;
          this.data = n;
        }
        is(t) {
          return t === 'CKEditorError';
        }
        static rethrowUnexpectedError(t, e) {
          if (t.is && t.is('CKEditorError')) {
            throw t;
          }
          const n = new h(t.message, e);
          n.stack = t.stack;
          throw n;
        }
      }
      function u(t, e) {
        console.warn(...p(t, e));
      }
      function f(t, e) {
        console.error(...p(t, e));
      }
      function g(t) {
        return `\nRead more: ${d}#error-${t}`;
      }
      function m(t, e) {
        const n = new WeakSet();
        const i = (t, e) => {
          if (typeof e === 'object' && e !== null) {
            if (n.has(e)) {
              return `[object ${e.constructor.name}]`;
            }
            n.add(e);
          }
          return e;
        };
        const o = e ? ` ${JSON.stringify(e, i)}` : '';
        const r = g(t);
        return t + o + r;
      }
      function p(t, e) {
        const n = g(t);
        return e ? [t, e, n] : [t, n];
      }
      const k = '35.1.0';
      const b = null && k;
      const w = typeof window === 'object' ? window : n.g;
      if (w.CKEDITOR_VERSION) {
        throw new h('ckeditor-duplicated-modules', null);
      } else {
        w.CKEDITOR_VERSION = k;
      }
      const _ = Symbol('listeningTo');
      const v = Symbol('emitterId');
      const A = Symbol('delegations');
      function C(t) {
        class e extends t {
          on(t, e, n) {
            this.listenTo(this, t, e, n);
          }
          once(t, e, n) {
            let i = false;
            const o = (t, ...n) => {
              if (!i) {
                i = true;
                t.off();
                e.call(this, t, ...n);
              }
            };
            this.listenTo(this, t, o, n);
          }
          off(t, e) {
            this.stopListening(this, t, e);
          }
          listenTo(t, e, n, i = {}) {
            let o, r;
            if (!this[_]) {
              this[_] = {};
            }
            const s = this[_];
            if (!D(t)) {
              E(t);
            }
            const a = D(t);
            if (!(o = s[a])) {
              o = s[a] = { emitter: t, callbacks: {} };
            }
            if (!(r = o.callbacks[e])) {
              r = o.callbacks[e] = [];
            }
            r.push(n);
            z(this, t, e, n, i);
          }
          stopListening(t, e, n) {
            const i = this[_];
            let o = t && D(t);
            const r = i && o ? i[o] : undefined;
            const s = r && e ? r.callbacks[e] : undefined;
            if (!i || (t && !r) || (e && !s)) {
              return;
            }
            if (n) {
              O(this, t, e, n);
              const i = s.indexOf(n);
              if (i !== -1) {
                if (s.length === 1) {
                  delete r.callbacks[e];
                } else {
                  O(this, t, e, n);
                }
              }
            } else if (s) {
              while ((n = s.pop())) {
                O(this, t, e, n);
              }
              delete r.callbacks[e];
            } else if (r) {
              for (e in r.callbacks) {
                this.stopListening(t, e);
              }
              delete i[o];
            } else {
              for (o in i) {
                this.stopListening(i[o].emitter);
              }
              delete this[_];
            }
          }
          fire(t, ...e) {
            try {
              const n = t instanceof o ? t : new o(this, t);
              const i = n.name;
              let r = I(this, i);
              n.path.push(this);
              if (r) {
                const t = [n, ...e];
                r = Array.from(r);
                for (let e = 0; e < r.length; e++) {
                  r[e].callback.apply(this, t);
                  if (n.off.called) {
                    delete n.off.called;
                    this._removeEventListener(i, r[e].callback);
                  }
                  if (n.stop.called) {
                    break;
                  }
                }
              }
              const s = this[A];
              if (s) {
                const t = s.get(i);
                const o = s.get('*');
                if (t) {
                  R(t, n, e);
                }
                if (o) {
                  R(o, n, e);
                }
              }
              return n.return;
            } catch (t) {
              h.rethrowUnexpectedError(t, this);
            }
          }
          delegate(...t) {
            return {
              to: (e, n) => {
                if (!this[A]) {
                  this[A] = new Map();
                }
                t.forEach((t) => {
                  const i = this[A].get(t);
                  if (!i) {
                    this[A].set(t, new Map([[e, n]]));
                  } else {
                    i.set(e, n);
                  }
                });
              },
            };
          }
          stopDelegating(t, e) {
            if (!this[A]) {
              return;
            }
            if (!t) {
              this[A].clear();
            } else if (!e) {
              this[A].delete(t);
            } else {
              const n = this[A].get(t);
              if (n) {
                n.delete(e);
              }
            }
          }
          _addEventListener(t, e, n) {
            B(this, t);
            const i = P(this, t);
            const o = c.get(n.priority);
            const r = { callback: e, priority: o };
            for (const t of i) {
              l(t, r);
            }
          }
          _removeEventListener(t, e) {
            const n = P(this, t);
            for (const t of n) {
              for (let n = 0; n < t.length; n++) {
                if (t[n].callback == e) {
                  t.splice(n, 1);
                  n--;
                }
              }
            }
          }
        }
        return e;
      }
      const y = C(Object);
      [
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach((t) => {
        C[t] = y.prototype[t];
      });
      function x(t, e) {
        const n = t[_];
        if (n && n[e]) {
          return n[e].emitter;
        }
        return null;
      }
      function E(t, e) {
        if (!t[v]) {
          t[v] = e || s();
        }
      }
      function D(t) {
        return t[v];
      }
      function S(t) {
        if (!t._events) {
          Object.defineProperty(t, '_events', { value: {} });
        }
        return t._events;
      }
      function T() {
        return { callbacks: [], childEvents: [] };
      }
      function B(t, e) {
        const n = S(t);
        if (n[e]) {
          return;
        }
        let i = e;
        let o = null;
        const r = [];
        while (i !== '') {
          if (n[i]) {
            break;
          }
          n[i] = T();
          r.push(n[i]);
          if (o) {
            n[i].childEvents.push(o);
          }
          o = i;
          i = i.substr(0, i.lastIndexOf(':'));
        }
        if (i !== '') {
          for (const t of r) {
            t.callbacks = n[i].callbacks.slice();
          }
          n[i].childEvents.push(o);
        }
      }
      function P(t, e) {
        const n = S(t)[e];
        if (!n) {
          return [];
        }
        let i = [n.callbacks];
        for (let e = 0; e < n.childEvents.length; e++) {
          const o = P(t, n.childEvents[e]);
          i = i.concat(o);
        }
        return i;
      }
      function I(t, e) {
        let n;
        if (
          !t._events ||
          !(n = t._events[e]) ||
          !n.callbacks.length
        ) {
          if (e.indexOf(':') > -1) {
            return I(t, e.substr(0, e.lastIndexOf(':')));
          } else {
            return null;
          }
        }
        return n.callbacks;
      }
      function R(t, e, n) {
        for (let [i, r] of t) {
          if (!r) {
            r = e.name;
          } else if (typeof r == 'function') {
            r = r(e.name);
          }
          const t = new o(e.source, r);
          t.path = [...e.path];
          i.fire(t, ...n);
        }
      }
      function z(t, e, n, i, o) {
        if (e._addEventListener) {
          e._addEventListener(n, i, o);
        } else {
          t._addEventListener.call(e, n, i, o);
        }
      }
      function O(t, e, n, i) {
        if (e._removeEventListener) {
          e._removeEventListener(n, i);
        } else {
          t._removeEventListener.call(e, n, i);
        }
      }
      function F(t) {
        var e = typeof t;
        return t != null && (e == 'object' || e == 'function');
      }
      const N = F;
      const M = Symbol('observableProperties');
      const L = Symbol('boundObservables');
      const V = Symbol('boundProperties');
      const H = Symbol('decoratedMethods');
      const j = Symbol('decoratedOriginal');
      function q(t) {
        class e extends t {
          set(t, e) {
            if (N(t)) {
              Object.keys(t).forEach((e) => {
                this.set(e, t[e]);
              }, this);
              return;
            }
            U(this);
            const n = this[M];
            if (t in this && !n.has(t)) {
              throw new h('observable-set-cannot-override', this);
            }
            Object.defineProperty(this, t, {
              enumerable: true,
              configurable: true,
              get() {
                return n.get(t);
              },
              set(e) {
                const i = n.get(t);
                let o = this.fire(`set:${t}`, t, e, i);
                if (o === undefined) {
                  o = e;
                }
                if (i !== o || !n.has(t)) {
                  n.set(t, o);
                  this.fire(`change:${t}`, t, o, i);
                }
              },
            });
            this[t] = e;
          }
          bind(...t) {
            if (!t.length || !Z(t)) {
              throw new h('observable-bind-wrong-properties', this);
            }
            if (new Set(t).size !== t.length) {
              throw new h(
                'observable-bind-duplicate-properties',
                this
              );
            }
            U(this);
            const e = this[V];
            t.forEach((t) => {
              if (e.has(t)) {
                throw new h('observable-bind-rebind', this);
              }
            });
            const n = new Map();
            t.forEach((t) => {
              const i = { property: t, to: [] };
              e.set(t, i);
              n.set(t, i);
            });
            return {
              to: G,
              toMany: $,
              _observable: this,
              _bindProperties: t,
              _to: [],
              _bindings: n,
            };
          }
          unbind(...t) {
            if (!this[M]) {
              return;
            }
            const e = this[V];
            const n = this[L];
            if (t.length) {
              if (!Z(t)) {
                throw new h(
                  'observable-unbind-wrong-properties',
                  this
                );
              }
              t.forEach((t) => {
                const i = e.get(t);
                if (!i) {
                  return;
                }
                i.to.forEach(([t, e]) => {
                  const o = n.get(t);
                  const r = o[e];
                  r.delete(i);
                  if (!r.size) {
                    delete o[e];
                  }
                  if (!Object.keys(o).length) {
                    n.delete(t);
                    this.stopListening(t, 'change');
                  }
                });
                e.delete(t);
              });
            } else {
              n.forEach((t, e) => {
                this.stopListening(e, 'change');
              });
              n.clear();
              e.clear();
            }
          }
          decorate(t) {
            U(this);
            const e = this[t];
            if (!e) {
              throw new h(
                'observablemixin-cannot-decorate-undefined',
                this,
                { object: this, methodName: t }
              );
            }
            this.on(t, (t, n) => {
              t.return = e.apply(this, n);
            });
            this[t] = function (...e) {
              return this.fire(t, e);
            };
            this[t][j] = e;
            if (!this[H]) {
              this[H] = [];
            }
            this[H].push(t);
          }
          stopListening(t, e, n) {
            if (!t && this[H]) {
              for (const t of this[H]) {
                this[t] = this[t][j];
              }
              delete this[H];
            }
            y.prototype.stopListening.call(this, t, e, n);
          }
        }
        return e;
      }
      const W = q(y);
      [
        'set',
        'bind',
        'unbind',
        'decorate',
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach((t) => {
        q[t] = W.prototype[t];
      });
      function U(t) {
        if (t[M]) {
          return;
        }
        Object.defineProperty(t, M, { value: new Map() });
        Object.defineProperty(t, L, { value: new Map() });
        Object.defineProperty(t, V, { value: new Map() });
      }
      function G(...t) {
        const e = J(...t);
        const n = Array.from(this._bindings.keys());
        const i = n.length;
        if (!e.callback && e.to.length > 1) {
          throw new h('observable-bind-to-no-callback', this);
        }
        if (i > 1 && e.callback) {
          throw new h('observable-bind-to-extra-callback', this);
        }
        e.to.forEach((t) => {
          if (t.properties.length && t.properties.length !== i) {
            throw new h('observable-bind-to-properties-length', this);
          }
          if (!t.properties.length) {
            t.properties = this._bindProperties;
          }
        });
        this._to = e.to;
        if (e.callback) {
          this._bindings.get(n[0]).callback = e.callback;
        }
        tt(this._observable, this._to);
        Q(this);
        this._bindProperties.forEach((t) => {
          X(this._observable, t);
        });
      }
      function $(t, e, n) {
        if (this._bindings.size > 1) {
          throw new h(
            'observable-bind-to-many-not-one-binding',
            this
          );
        }
        this.to(...K(t, e), n);
      }
      function K(t, e) {
        const n = t.map((t) => [t, e]);
        return Array.prototype.concat.apply([], n);
      }
      function Z(t) {
        return t.every((t) => typeof t == 'string');
      }
      function J(...t) {
        if (!t.length) {
          throw new h('observable-bind-to-parse-error', null);
        }
        const e = { to: [] };
        let n;
        if (typeof t[t.length - 1] == 'function') {
          e.callback = t.pop();
        }
        t.forEach((t) => {
          if (typeof t == 'string') {
            n.properties.push(t);
          } else if (typeof t == 'object') {
            n = { observable: t, properties: [] };
            e.to.push(n);
          } else {
            throw new h('observable-bind-to-parse-error', null);
          }
        });
        return e;
      }
      function Y(t, e, n, i) {
        const o = t[L];
        const r = o.get(n);
        const s = r || {};
        if (!s[i]) {
          s[i] = new Set();
        }
        s[i].add(e);
        if (!r) {
          o.set(n, s);
        }
      }
      function Q(t) {
        let e;
        t._bindings.forEach((n, i) => {
          t._to.forEach((o) => {
            e =
              o.properties[
                n.callback ? 0 : t._bindProperties.indexOf(i)
              ];
            n.to.push([o.observable, e]);
            Y(t._observable, n, o.observable, e);
          });
        });
      }
      function X(t, e) {
        const n = t[V];
        const i = n.get(e);
        let o;
        if (i.callback) {
          o = i.callback.apply(
            t,
            i.to.map((t) => t[0][t[1]])
          );
        } else {
          o = i.to[0];
          o = o[0][o[1]];
        }
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          t[e] = o;
        } else {
          t.set(e, o);
        }
      }
      function tt(t, e) {
        e.forEach((e) => {
          const n = t[L];
          let i;
          if (!n.get(e.observable)) {
            t.listenTo(e.observable, 'change', (o, r) => {
              i = n.get(e.observable)[r];
              if (i) {
                i.forEach((e) => {
                  X(t, e.property);
                });
              }
            });
          }
        });
      }
      function et(t, ...e) {
        e.forEach((e) => {
          const n = Object.getOwnPropertyNames(e);
          const i = Object.getOwnPropertySymbols(e);
          n.concat(i).forEach((n) => {
            if (n in t.prototype) {
              return;
            }
            if (
              typeof e == 'function' &&
              (n == 'length' || n == 'name' || n == 'prototype')
            ) {
              return;
            }
            const i = Object.getOwnPropertyDescriptor(e, n);
            i.enumerable = false;
            Object.defineProperty(t.prototype, n, i);
          });
        });
      }
      class nt {
        constructor(t) {
          this.editor = t;
          this.set('isEnabled', true);
          this._disableStack = new Set();
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on('set:isEnabled', it, { priority: 'highest' });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off('set:isEnabled', it);
            this.isEnabled = true;
          }
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return false;
        }
      }
      et(nt, q);
      function it(t) {
        t.return = false;
        t.stop();
      }
      class ot {
        constructor(t) {
          this.editor = t;
          this.set('value', undefined);
          this.set('isEnabled', false);
          this.affectsData = true;
          this._disableStack = new Set();
          this.decorate('execute');
          this.listenTo(this.editor.model.document, 'change', () => {
            this.refresh();
          });
          this.on(
            'execute',
            (t) => {
              if (!this.isEnabled) {
                t.stop();
              }
            },
            { priority: 'high' }
          );
          this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
            if (n && this.affectsData) {
              this.forceDisabled('readOnlyMode');
            } else {
              this.clearForceDisabled('readOnlyMode');
            }
          });
        }
        refresh() {
          this.isEnabled = true;
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on('set:isEnabled', rt, { priority: 'highest' });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off('set:isEnabled', rt);
            this.refresh();
          }
        }
        execute() {}
        destroy() {
          this.stopListening();
        }
      }
      et(ot, q);
      function rt(t) {
        t.return = false;
        t.stop();
      }
      class st extends ot {
        constructor(t) {
          super(t);
          this._childCommandsDefinitions = [];
        }
        refresh() {}
        execute(...t) {
          const e = this._getFirstEnabledCommand();
          return !!e && e.execute(t);
        }
        registerChildCommand(t, e = { priority: 'normal' }) {
          l(this._childCommandsDefinitions, {
            command: t,
            priority: e.priority,
          });
          t.on('change:isEnabled', () => this._checkEnabled());
          this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          const t = this._childCommandsDefinitions.find(
            ({ command: t }) => t.isEnabled
          );
          return t && t.command;
        }
      }
      var at =
        typeof global == 'object' &&
        global &&
        global.Object === Object &&
        global;
      const ct = at;
      var lt =
        typeof self == 'object' &&
        self &&
        self.Object === Object &&
        self;
      var dt = ct || lt || Function('return this')();
      const ht = dt;
      var ut = ht.Symbol;
      const ft = ut;
      var gt = Object.prototype;
      var mt = gt.hasOwnProperty;
      var pt = gt.toString;
      var kt = ft ? ft.toStringTag : undefined;
      function bt(t) {
        var e = mt.call(t, kt),
          n = t[kt];
        try {
          t[kt] = undefined;
          var i = true;
        } catch (t) {}
        var o = pt.call(t);
        if (i) {
          if (e) {
            t[kt] = n;
          } else {
            delete t[kt];
          }
        }
        return o;
      }
      const wt = bt;
      var _t = Object.prototype;
      var vt = _t.toString;
      function At(t) {
        return vt.call(t);
      }
      const Ct = At;
      var yt = '[object Null]',
        xt = '[object Undefined]';
      var Et = ft ? ft.toStringTag : undefined;
      function Dt(t) {
        if (t == null) {
          return t === undefined ? xt : yt;
        }
        return Et && Et in Object(t) ? wt(t) : Ct(t);
      }
      const St = Dt;
      function Tt(t, e) {
        return function (n) {
          return t(e(n));
        };
      }
      const Bt = Tt;
      var Pt = Bt(Object.getPrototypeOf, Object);
      const It = Pt;
      function Rt(t) {
        return t != null && typeof t == 'object';
      }
      const zt = Rt;
      var Ot = '[object Object]';
      var Ft = Function.prototype,
        Nt = Object.prototype;
      var Mt = Ft.toString;
      var Lt = Nt.hasOwnProperty;
      var Vt = Mt.call(Object);
      function Ht(t) {
        if (!zt(t) || St(t) != Ot) {
          return false;
        }
        var e = It(t);
        if (e === null) {
          return true;
        }
        var n = Lt.call(e, 'constructor') && e.constructor;
        return (
          typeof n == 'function' && n instanceof n && Mt.call(n) == Vt
        );
      }
      const jt = Ht;
      function qt() {
        this.__data__ = [];
        this.size = 0;
      }
      const Wt = qt;
      function Ut(t, e) {
        return t === e || (t !== t && e !== e);
      }
      const Gt = Ut;
      function $t(t, e) {
        var n = t.length;
        while (n--) {
          if (Gt(t[n][0], e)) {
            return n;
          }
        }
        return -1;
      }
      const Kt = $t;
      var Zt = Array.prototype;
      var Jt = Zt.splice;
      function Yt(t) {
        var e = this.__data__,
          n = Kt(e, t);
        if (n < 0) {
          return false;
        }
        var i = e.length - 1;
        if (n == i) {
          e.pop();
        } else {
          Jt.call(e, n, 1);
        }
        --this.size;
        return true;
      }
      const Qt = Yt;
      function Xt(t) {
        var e = this.__data__,
          n = Kt(e, t);
        return n < 0 ? undefined : e[n][1];
      }
      const te = Xt;
      function ee(t) {
        return Kt(this.__data__, t) > -1;
      }
      const ne = ee;
      function ie(t, e) {
        var n = this.__data__,
          i = Kt(n, t);
        if (i < 0) {
          ++this.size;
          n.push([t, e]);
        } else {
          n[i][1] = e;
        }
        return this;
      }
      const oe = ie;
      function re(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var i = t[e];
          this.set(i[0], i[1]);
        }
      }
      re.prototype.clear = Wt;
      re.prototype['delete'] = Qt;
      re.prototype.get = te;
      re.prototype.has = ne;
      re.prototype.set = oe;
      const se = re;
      function ae() {
        this.__data__ = new se();
        this.size = 0;
      }
      const ce = ae;
      function le(t) {
        var e = this.__data__,
          n = e['delete'](t);
        this.size = e.size;
        return n;
      }
      const de = le;
      function he(t) {
        return this.__data__.get(t);
      }
      const ue = he;
      function fe(t) {
        return this.__data__.has(t);
      }
      const ge = fe;
      var me = '[object AsyncFunction]',
        pe = '[object Function]',
        ke = '[object GeneratorFunction]',
        be = '[object Proxy]';
      function we(t) {
        if (!N(t)) {
          return false;
        }
        var e = St(t);
        return e == pe || e == ke || e == me || e == be;
      }
      const _e = we;
      var ve = ht['__core-js_shared__'];
      const Ae = ve;
      var Ce = (function () {
        var t = /[^.]+$/.exec(
          (Ae && Ae.keys && Ae.keys.IE_PROTO) || ''
        );
        return t ? 'Symbol(src)_1.' + t : '';
      })();
      function ye(t) {
        return !!Ce && Ce in t;
      }
      const xe = ye;
      var Ee = Function.prototype;
      var De = Ee.toString;
      function Se(t) {
        if (t != null) {
          try {
            return De.call(t);
          } catch (t) {}
          try {
            return t + '';
          } catch (t) {}
        }
        return '';
      }
      const Te = Se;
      var Be = /[\\^$.*+?()[\]{}|]/g;
      var Pe = /^\[object .+?Constructor\]$/;
      var Ie = Function.prototype,
        Re = Object.prototype;
      var ze = Ie.toString;
      var Oe = Re.hasOwnProperty;
      var Fe = RegExp(
        '^' +
          ze
            .call(Oe)
            .replace(Be, '\\$&')
            .replace(
              /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
              '$1.*?'
            ) +
          '$'
      );
      function Ne(t) {
        if (!N(t) || xe(t)) {
          return false;
        }
        var e = _e(t) ? Fe : Pe;
        return e.test(Te(t));
      }
      const Me = Ne;
      function Le(t, e) {
        return t == null ? undefined : t[e];
      }
      const Ve = Le;
      function He(t, e) {
        var n = Ve(t, e);
        return Me(n) ? n : undefined;
      }
      const je = He;
      var qe = je(ht, 'Map');
      const We = qe;
      var Ue = je(Object, 'create');
      const Ge = Ue;
      function $e() {
        this.__data__ = Ge ? Ge(null) : {};
        this.size = 0;
      }
      const Ke = $e;
      function Ze(t) {
        var e = this.has(t) && delete this.__data__[t];
        this.size -= e ? 1 : 0;
        return e;
      }
      const Je = Ze;
      var Ye = '__lodash_hash_undefined__';
      var Qe = Object.prototype;
      var Xe = Qe.hasOwnProperty;
      function tn(t) {
        var e = this.__data__;
        if (Ge) {
          var n = e[t];
          return n === Ye ? undefined : n;
        }
        return Xe.call(e, t) ? e[t] : undefined;
      }
      const en = tn;
      var nn = Object.prototype;
      var on = nn.hasOwnProperty;
      function rn(t) {
        var e = this.__data__;
        return Ge ? e[t] !== undefined : on.call(e, t);
      }
      const sn = rn;
      var an = '__lodash_hash_undefined__';
      function cn(t, e) {
        var n = this.__data__;
        this.size += this.has(t) ? 0 : 1;
        n[t] = Ge && e === undefined ? an : e;
        return this;
      }
      const ln = cn;
      function dn(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var i = t[e];
          this.set(i[0], i[1]);
        }
      }
      dn.prototype.clear = Ke;
      dn.prototype['delete'] = Je;
      dn.prototype.get = en;
      dn.prototype.has = sn;
      dn.prototype.set = ln;
      const hn = dn;
      function un() {
        this.size = 0;
        this.__data__ = {
          hash: new hn(),
          map: new (We || se)(),
          string: new hn(),
        };
      }
      const fn = un;
      function gn(t) {
        var e = typeof t;
        return e == 'string' ||
          e == 'number' ||
          e == 'symbol' ||
          e == 'boolean'
          ? t !== '__proto__'
          : t === null;
      }
      const mn = gn;
      function pn(t, e) {
        var n = t.__data__;
        return mn(e)
          ? n[typeof e == 'string' ? 'string' : 'hash']
          : n.map;
      }
      const kn = pn;
      function bn(t) {
        var e = kn(this, t)['delete'](t);
        this.size -= e ? 1 : 0;
        return e;
      }
      const wn = bn;
      function _n(t) {
        return kn(this, t).get(t);
      }
      const vn = _n;
      function An(t) {
        return kn(this, t).has(t);
      }
      const Cn = An;
      function yn(t, e) {
        var n = kn(this, t),
          i = n.size;
        n.set(t, e);
        this.size += n.size == i ? 0 : 1;
        return this;
      }
      const xn = yn;
      function En(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var i = t[e];
          this.set(i[0], i[1]);
        }
      }
      En.prototype.clear = fn;
      En.prototype['delete'] = wn;
      En.prototype.get = vn;
      En.prototype.has = Cn;
      En.prototype.set = xn;
      const Dn = En;
      var Sn = 200;
      function Tn(t, e) {
        var n = this.__data__;
        if (n instanceof se) {
          var i = n.__data__;
          if (!We || i.length < Sn - 1) {
            i.push([t, e]);
            this.size = ++n.size;
            return this;
          }
          n = this.__data__ = new Dn(i);
        }
        n.set(t, e);
        this.size = n.size;
        return this;
      }
      const Bn = Tn;
      function Pn(t) {
        var e = (this.__data__ = new se(t));
        this.size = e.size;
      }
      Pn.prototype.clear = ce;
      Pn.prototype['delete'] = de;
      Pn.prototype.get = ue;
      Pn.prototype.has = ge;
      Pn.prototype.set = Bn;
      const In = Pn;
      function Rn(t, e) {
        var n = -1,
          i = t == null ? 0 : t.length;
        while (++n < i) {
          if (e(t[n], n, t) === false) {
            break;
          }
        }
        return t;
      }
      const zn = Rn;
      var On = (function () {
        try {
          var t = je(Object, 'defineProperty');
          t({}, '', {});
          return t;
        } catch (t) {}
      })();
      const Fn = On;
      function Nn(t, e, n) {
        if (e == '__proto__' && Fn) {
          Fn(t, e, {
            configurable: true,
            enumerable: true,
            value: n,
            writable: true,
          });
        } else {
          t[e] = n;
        }
      }
      const Mn = Nn;
      var Ln = Object.prototype;
      var Vn = Ln.hasOwnProperty;
      function Hn(t, e, n) {
        var i = t[e];
        if (
          !(Vn.call(t, e) && Gt(i, n)) ||
          (n === undefined && !(e in t))
        ) {
          Mn(t, e, n);
        }
      }
      const jn = Hn;
      function qn(t, e, n, i) {
        var o = !n;
        n || (n = {});
        var r = -1,
          s = e.length;
        while (++r < s) {
          var a = e[r];
          var c = i ? i(n[a], t[a], a, n, t) : undefined;
          if (c === undefined) {
            c = t[a];
          }
          if (o) {
            Mn(n, a, c);
          } else {
            jn(n, a, c);
          }
        }
        return n;
      }
      const Wn = qn;
      function Un(t, e) {
        var n = -1,
          i = Array(t);
        while (++n < t) {
          i[n] = e(n);
        }
        return i;
      }
      const Gn = Un;
      var $n = '[object Arguments]';
      function Kn(t) {
        return zt(t) && St(t) == $n;
      }
      const Zn = Kn;
      var Jn = Object.prototype;
      var Yn = Jn.hasOwnProperty;
      var Qn = Jn.propertyIsEnumerable;
      var Xn = Zn(
        (function () {
          return arguments;
        })()
      )
        ? Zn
        : function (t) {
            return (
              zt(t) && Yn.call(t, 'callee') && !Qn.call(t, 'callee')
            );
          };
      const ti = Xn;
      var ei = Array.isArray;
      const ni = ei;
      function ii() {
        return false;
      }
      const oi = ii;
      var ri =
        typeof exports == 'object' &&
        exports &&
        !exports.nodeType &&
        exports;
      var si =
        ri &&
        typeof module == 'object' &&
        module &&
        !module.nodeType &&
        module;
      var ai = si && si.exports === ri;
      var ci = ai ? ht.Buffer : undefined;
      var li = ci ? ci.isBuffer : undefined;
      var di = li || oi;
      const hi = di;
      var ui = 9007199254740991;
      var fi = /^(?:0|[1-9]\d*)$/;
      function gi(t, e) {
        var n = typeof t;
        e = e == null ? ui : e;
        return (
          !!e &&
          (n == 'number' || (n != 'symbol' && fi.test(t))) &&
          t > -1 &&
          t % 1 == 0 &&
          t < e
        );
      }
      const mi = gi;
      var pi = 9007199254740991;
      function ki(t) {
        return (
          typeof t == 'number' && t > -1 && t % 1 == 0 && t <= pi
        );
      }
      const bi = ki;
      var wi = '[object Arguments]',
        _i = '[object Array]',
        vi = '[object Boolean]',
        Ai = '[object Date]',
        Ci = '[object Error]',
        yi = '[object Function]',
        xi = '[object Map]',
        Ei = '[object Number]',
        Di = '[object Object]',
        Si = '[object RegExp]',
        Ti = '[object Set]',
        Bi = '[object String]',
        Pi = '[object WeakMap]';
      var Ii = '[object ArrayBuffer]',
        Ri = '[object DataView]',
        zi = '[object Float32Array]',
        Oi = '[object Float64Array]',
        Fi = '[object Int8Array]',
        Ni = '[object Int16Array]',
        Mi = '[object Int32Array]',
        Li = '[object Uint8Array]',
        Vi = '[object Uint8ClampedArray]',
        Hi = '[object Uint16Array]',
        ji = '[object Uint32Array]';
      var qi = {};
      qi[zi] =
        qi[Oi] =
        qi[Fi] =
        qi[Ni] =
        qi[Mi] =
        qi[Li] =
        qi[Vi] =
        qi[Hi] =
        qi[ji] =
          true;
      qi[wi] =
        qi[_i] =
        qi[Ii] =
        qi[vi] =
        qi[Ri] =
        qi[Ai] =
        qi[Ci] =
        qi[yi] =
        qi[xi] =
        qi[Ei] =
        qi[Di] =
        qi[Si] =
        qi[Ti] =
        qi[Bi] =
        qi[Pi] =
          false;
      function Wi(t) {
        return zt(t) && bi(t.length) && !!qi[St(t)];
      }
      const Ui = Wi;
      function Gi(t) {
        return function (e) {
          return t(e);
        };
      }
      const $i = Gi;
      var Ki =
        typeof exports == 'object' &&
        exports &&
        !exports.nodeType &&
        exports;
      var Zi =
        Ki &&
        typeof module == 'object' &&
        module &&
        !module.nodeType &&
        module;
      var Ji = Zi && Zi.exports === Ki;
      var Yi = Ji && ct.process;
      var Qi = (function () {
        try {
          var t = Zi && Zi.require && Zi.require('util').types;
          if (t) {
            return t;
          }
          return Yi && Yi.binding && Yi.binding('util');
        } catch (t) {}
      })();
      const Xi = Qi;
      var to = Xi && Xi.isTypedArray;
      var eo = to ? $i(to) : Ui;
      const no = eo;
      var io = Object.prototype;
      var oo = io.hasOwnProperty;
      function ro(t, e) {
        var n = ni(t),
          i = !n && ti(t),
          o = !n && !i && hi(t),
          r = !n && !i && !o && no(t),
          s = n || i || o || r,
          a = s ? Gn(t.length, String) : [],
          c = a.length;
        for (var l in t) {
          if (
            (e || oo.call(t, l)) &&
            !(
              s &&
              (l == 'length' ||
                (o && (l == 'offset' || l == 'parent')) ||
                (r &&
                  (l == 'buffer' ||
                    l == 'byteLength' ||
                    l == 'byteOffset')) ||
                mi(l, c))
            )
          ) {
            a.push(l);
          }
        }
        return a;
      }
      const so = ro;
      var ao = Object.prototype;
      function co(t) {
        var e = t && t.constructor,
          n = (typeof e == 'function' && e.prototype) || ao;
        return t === n;
      }
      const lo = co;
      var ho = Bt(Object.keys, Object);
      const uo = ho;
      var fo = Object.prototype;
      var go = fo.hasOwnProperty;
      function mo(t) {
        if (!lo(t)) {
          return uo(t);
        }
        var e = [];
        for (var n in Object(t)) {
          if (go.call(t, n) && n != 'constructor') {
            e.push(n);
          }
        }
        return e;
      }
      const po = mo;
      function ko(t) {
        return t != null && bi(t.length) && !_e(t);
      }
      const bo = ko;
      function wo(t) {
        return bo(t) ? so(t) : po(t);
      }
      const _o = wo;
      function vo(t, e) {
        return t && Wn(e, _o(e), t);
      }
      const Ao = vo;
      function Co(t) {
        var e = [];
        if (t != null) {
          for (var n in Object(t)) {
            e.push(n);
          }
        }
        return e;
      }
      const yo = Co;
      var xo = Object.prototype;
      var Eo = xo.hasOwnProperty;
      function Do(t) {
        if (!N(t)) {
          return yo(t);
        }
        var e = lo(t),
          n = [];
        for (var i in t) {
          if (!(i == 'constructor' && (e || !Eo.call(t, i)))) {
            n.push(i);
          }
        }
        return n;
      }
      const So = Do;
      function To(t) {
        return bo(t) ? so(t, true) : So(t);
      }
      const Bo = To;
      function Po(t, e) {
        return t && Wn(e, Bo(e), t);
      }
      const Io = Po;
      var Ro =
        typeof exports == 'object' &&
        exports &&
        !exports.nodeType &&
        exports;
      var zo =
        Ro &&
        typeof module == 'object' &&
        module &&
        !module.nodeType &&
        module;
      var Oo = zo && zo.exports === Ro;
      var Fo = Oo ? ht.Buffer : undefined,
        No = Fo ? Fo.allocUnsafe : undefined;
      function Mo(t, e) {
        if (e) {
          return t.slice();
        }
        var n = t.length,
          i = No ? No(n) : new t.constructor(n);
        t.copy(i);
        return i;
      }
      const Lo = Mo;
      function Vo(t, e) {
        var n = -1,
          i = t.length;
        e || (e = Array(i));
        while (++n < i) {
          e[n] = t[n];
        }
        return e;
      }
      const Ho = Vo;
      function jo(t, e) {
        var n = -1,
          i = t == null ? 0 : t.length,
          o = 0,
          r = [];
        while (++n < i) {
          var s = t[n];
          if (e(s, n, t)) {
            r[o++] = s;
          }
        }
        return r;
      }
      const qo = jo;
      function Wo() {
        return [];
      }
      const Uo = Wo;
      var Go = Object.prototype;
      var $o = Go.propertyIsEnumerable;
      var Ko = Object.getOwnPropertySymbols;
      var Zo = !Ko
        ? Uo
        : function (t) {
            if (t == null) {
              return [];
            }
            t = Object(t);
            return qo(Ko(t), function (e) {
              return $o.call(t, e);
            });
          };
      const Jo = Zo;
      function Yo(t, e) {
        return Wn(t, Jo(t), e);
      }
      const Qo = Yo;
      function Xo(t, e) {
        var n = -1,
          i = e.length,
          o = t.length;
        while (++n < i) {
          t[o + n] = e[n];
        }
        return t;
      }
      const tr = Xo;
      var er = Object.getOwnPropertySymbols;
      var nr = !er
        ? Uo
        : function (t) {
            var e = [];
            while (t) {
              tr(e, Jo(t));
              t = It(t);
            }
            return e;
          };
      const ir = nr;
      function or(t, e) {
        return Wn(t, ir(t), e);
      }
      const rr = or;
      function sr(t, e, n) {
        var i = e(t);
        return ni(t) ? i : tr(i, n(t));
      }
      const ar = sr;
      function cr(t) {
        return ar(t, _o, Jo);
      }
      const lr = cr;
      function dr(t) {
        return ar(t, Bo, ir);
      }
      const hr = dr;
      var ur = je(ht, 'DataView');
      const fr = ur;
      var gr = je(ht, 'Promise');
      const mr = gr;
      var pr = je(ht, 'Set');
      const kr = pr;
      var br = je(ht, 'WeakMap');
      const wr = br;
      var _r = '[object Map]',
        vr = '[object Object]',
        Ar = '[object Promise]',
        Cr = '[object Set]',
        yr = '[object WeakMap]';
      var xr = '[object DataView]';
      var Er = Te(fr),
        Dr = Te(We),
        Sr = Te(mr),
        Tr = Te(kr),
        Br = Te(wr);
      var Pr = St;
      if (
        (fr && Pr(new fr(new ArrayBuffer(1))) != xr) ||
        (We && Pr(new We()) != _r) ||
        (mr && Pr(mr.resolve()) != Ar) ||
        (kr && Pr(new kr()) != Cr) ||
        (wr && Pr(new wr()) != yr)
      ) {
        Pr = function (t) {
          var e = St(t),
            n = e == vr ? t.constructor : undefined,
            i = n ? Te(n) : '';
          if (i) {
            switch (i) {
              case Er:
                return xr;
              case Dr:
                return _r;
              case Sr:
                return Ar;
              case Tr:
                return Cr;
              case Br:
                return yr;
            }
          }
          return e;
        };
      }
      const Ir = Pr;
      var Rr = Object.prototype;
      var zr = Rr.hasOwnProperty;
      function Or(t) {
        var e = t.length,
          n = new t.constructor(e);
        if (e && typeof t[0] == 'string' && zr.call(t, 'index')) {
          n.index = t.index;
          n.input = t.input;
        }
        return n;
      }
      const Fr = Or;
      var Nr = ht.Uint8Array;
      const Mr = Nr;
      function Lr(t) {
        var e = new t.constructor(t.byteLength);
        new Mr(e).set(new Mr(t));
        return e;
      }
      const Vr = Lr;
      function Hr(t, e) {
        var n = e ? Vr(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength);
      }
      const jr = Hr;
      var qr = /\w*$/;
      function Wr(t) {
        var e = new t.constructor(t.source, qr.exec(t));
        e.lastIndex = t.lastIndex;
        return e;
      }
      const Ur = Wr;
      var Gr = ft ? ft.prototype : undefined,
        $r = Gr ? Gr.valueOf : undefined;
      function Kr(t) {
        return $r ? Object($r.call(t)) : {};
      }
      const Zr = Kr;
      function Jr(t, e) {
        var n = e ? Vr(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length);
      }
      const Yr = Jr;
      var Qr = '[object Boolean]',
        Xr = '[object Date]',
        ts = '[object Map]',
        es = '[object Number]',
        ns = '[object RegExp]',
        is = '[object Set]',
        os = '[object String]',
        rs = '[object Symbol]';
      var ss = '[object ArrayBuffer]',
        as = '[object DataView]',
        cs = '[object Float32Array]',
        ls = '[object Float64Array]',
        ds = '[object Int8Array]',
        hs = '[object Int16Array]',
        us = '[object Int32Array]',
        fs = '[object Uint8Array]',
        gs = '[object Uint8ClampedArray]',
        ms = '[object Uint16Array]',
        ps = '[object Uint32Array]';
      function ks(t, e, n) {
        var i = t.constructor;
        switch (e) {
          case ss:
            return Vr(t);
          case Qr:
          case Xr:
            return new i(+t);
          case as:
            return jr(t, n);
          case cs:
          case ls:
          case ds:
          case hs:
          case us:
          case fs:
          case gs:
          case ms:
          case ps:
            return Yr(t, n);
          case ts:
            return new i();
          case es:
          case os:
            return new i(t);
          case ns:
            return Ur(t);
          case is:
            return new i();
          case rs:
            return Zr(t);
        }
      }
      const bs = ks;
      var ws = Object.create;
      var _s = (function () {
        function t() {}
        return function (e) {
          if (!N(e)) {
            return {};
          }
          if (ws) {
            return ws(e);
          }
          t.prototype = e;
          var n = new t();
          t.prototype = undefined;
          return n;
        };
      })();
      const vs = _s;
      function As(t) {
        return typeof t.constructor == 'function' && !lo(t)
          ? vs(It(t))
          : {};
      }
      const Cs = As;
      var ys = '[object Map]';
      function xs(t) {
        return zt(t) && Ir(t) == ys;
      }
      const Es = xs;
      var Ds = Xi && Xi.isMap;
      var Ss = Ds ? $i(Ds) : Es;
      const Ts = Ss;
      var Bs = '[object Set]';
      function Ps(t) {
        return zt(t) && Ir(t) == Bs;
      }
      const Is = Ps;
      var Rs = Xi && Xi.isSet;
      var zs = Rs ? $i(Rs) : Is;
      const Os = zs;
      var Fs = 1,
        Ns = 2,
        Ms = 4;
      var Ls = '[object Arguments]',
        Vs = '[object Array]',
        Hs = '[object Boolean]',
        js = '[object Date]',
        qs = '[object Error]',
        Ws = '[object Function]',
        Us = '[object GeneratorFunction]',
        Gs = '[object Map]',
        $s = '[object Number]',
        Ks = '[object Object]',
        Zs = '[object RegExp]',
        Js = '[object Set]',
        Ys = '[object String]',
        Qs = '[object Symbol]',
        Xs = '[object WeakMap]';
      var ta = '[object ArrayBuffer]',
        ea = '[object DataView]',
        na = '[object Float32Array]',
        ia = '[object Float64Array]',
        oa = '[object Int8Array]',
        ra = '[object Int16Array]',
        sa = '[object Int32Array]',
        aa = '[object Uint8Array]',
        ca = '[object Uint8ClampedArray]',
        la = '[object Uint16Array]',
        da = '[object Uint32Array]';
      var ha = {};
      ha[Ls] =
        ha[Vs] =
        ha[ta] =
        ha[ea] =
        ha[Hs] =
        ha[js] =
        ha[na] =
        ha[ia] =
        ha[oa] =
        ha[ra] =
        ha[sa] =
        ha[Gs] =
        ha[$s] =
        ha[Ks] =
        ha[Zs] =
        ha[Js] =
        ha[Ys] =
        ha[Qs] =
        ha[aa] =
        ha[ca] =
        ha[la] =
        ha[da] =
          true;
      ha[qs] = ha[Ws] = ha[Xs] = false;
      function ua(t, e, n, i, o, r) {
        var s,
          a = e & Fs,
          c = e & Ns,
          l = e & Ms;
        if (n) {
          s = o ? n(t, i, o, r) : n(t);
        }
        if (s !== undefined) {
          return s;
        }
        if (!N(t)) {
          return t;
        }
        var d = ni(t);
        if (d) {
          s = Fr(t);
          if (!a) {
            return Ho(t, s);
          }
        } else {
          var h = Ir(t),
            u = h == Ws || h == Us;
          if (hi(t)) {
            return Lo(t, a);
          }
          if (h == Ks || h == Ls || (u && !o)) {
            s = c || u ? {} : Cs(t);
            if (!a) {
              return c ? rr(t, Io(s, t)) : Qo(t, Ao(s, t));
            }
          } else {
            if (!ha[h]) {
              return o ? t : {};
            }
            s = bs(t, h, a);
          }
        }
        r || (r = new In());
        var f = r.get(t);
        if (f) {
          return f;
        }
        r.set(t, s);
        if (Os(t)) {
          t.forEach(function (i) {
            s.add(ua(i, e, n, i, t, r));
          });
        } else if (Ts(t)) {
          t.forEach(function (i, o) {
            s.set(o, ua(i, e, n, o, t, r));
          });
        }
        var g = l ? (c ? hr : lr) : c ? Bo : _o;
        var m = d ? undefined : g(t);
        zn(m || t, function (i, o) {
          if (m) {
            o = i;
            i = t[o];
          }
          jn(s, o, ua(i, e, n, o, t, r));
        });
        return s;
      }
      const fa = ua;
      var ga = 1,
        ma = 4;
      function pa(t, e) {
        e = typeof e == 'function' ? e : undefined;
        return fa(t, ga | ma, e);
      }
      const ka = pa;
      function ba(t) {
        return zt(t) && t.nodeType === 1 && !jt(t);
      }
      const wa = ba;
      class _a {
        constructor(t, e) {
          this._config = {};
          if (e) {
            this.define(va(e));
          }
          if (t) {
            this._setObjectToTarget(this._config, t);
          }
        }
        set(t, e) {
          this._setToTarget(this._config, t, e);
        }
        define(t, e) {
          const n = true;
          this._setToTarget(this._config, t, e, n);
        }
        get(t) {
          return this._getFromSource(this._config, t);
        }
        *names() {
          for (const t of Object.keys(this._config)) {
            yield t;
          }
        }
        _setToTarget(t, e, n, i = false) {
          if (jt(e)) {
            this._setObjectToTarget(t, e, i);
            return;
          }
          const o = e.split('.');
          e = o.pop();
          for (const e of o) {
            if (!jt(t[e])) {
              t[e] = {};
            }
            t = t[e];
          }
          if (jt(n)) {
            if (!jt(t[e])) {
              t[e] = {};
            }
            t = t[e];
            this._setObjectToTarget(t, n, i);
            return;
          }
          if (i && typeof t[e] != 'undefined') {
            return;
          }
          t[e] = n;
        }
        _getFromSource(t, e) {
          const n = e.split('.');
          e = n.pop();
          for (const e of n) {
            if (!jt(t[e])) {
              t = null;
              break;
            }
            t = t[e];
          }
          return t ? va(t[e]) : undefined;
        }
        _setObjectToTarget(t, e, n) {
          Object.keys(e).forEach((i) => {
            this._setToTarget(t, i, e[i], n);
          });
        }
      }
      function va(t) {
        return ka(t, Aa);
      }
      function Aa(t) {
        return wa(t) ? t : undefined;
      }
      function Ca(t) {
        return !!(t && t[Symbol.iterator]);
      }
      class ya extends y {
        constructor(t = {}, e = {}) {
          super();
          const n = Ca(t);
          if (!n) {
            e = t;
          }
          this._items = [];
          this._itemMap = new Map();
          this._idProperty = e.idProperty || 'id';
          this._bindToExternalToInternalMap = new WeakMap();
          this._bindToInternalToExternalMap = new WeakMap();
          this._skippedIndexesFromExternal = [];
          if (n) {
            for (const e of t) {
              this._items.push(e);
              this._itemMap.set(this._getItemIdBeforeAdding(e), e);
            }
          }
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(t, e) {
          return this.addMany([t], e);
        }
        addMany(t, e) {
          if (e === undefined) {
            e = this._items.length;
          } else if (e > this._items.length || e < 0) {
            throw new h('collection-add-item-invalid-index', this);
          }
          let n = 0;
          for (const i of t) {
            const t = this._getItemIdBeforeAdding(i);
            const o = e + n;
            this._items.splice(o, 0, i);
            this._itemMap.set(t, i);
            this.fire('add', i, o);
            n++;
          }
          this.fire('change', { added: t, removed: [], index: e });
          return this;
        }
        get(t) {
          let e;
          if (typeof t == 'string') {
            e = this._itemMap.get(t);
          } else if (typeof t == 'number') {
            e = this._items[t];
          } else {
            throw new h('collection-get-invalid-arg', this);
          }
          return e || null;
        }
        has(t) {
          if (typeof t == 'string') {
            return this._itemMap.has(t);
          } else {
            const e = this._idProperty;
            const n = t[e];
            return n && this._itemMap.has(n);
          }
        }
        getIndex(t) {
          let e;
          if (typeof t == 'string') {
            e = this._itemMap.get(t);
          } else {
            e = t;
          }
          return e ? this._items.indexOf(e) : -1;
        }
        remove(t) {
          const [e, n] = this._remove(t);
          this.fire('change', { added: [], removed: [e], index: n });
          return e;
        }
        map(t, e) {
          return this._items.map(t, e);
        }
        find(t, e) {
          return this._items.find(t, e);
        }
        filter(t, e) {
          return this._items.filter(t, e);
        }
        clear() {
          if (this._bindToCollection) {
            this.stopListening(this._bindToCollection);
            this._bindToCollection = null;
          }
          const t = Array.from(this._items);
          while (this.length) {
            this._remove(0);
          }
          this.fire('change', { added: [], removed: t, index: 0 });
        }
        bindTo(t) {
          if (this._bindToCollection) {
            throw new h('collection-bind-to-rebind', this);
          }
          this._bindToCollection = t;
          return {
            as: (t) => {
              this._setUpBindToBinding((e) => new t(e));
            },
            using: (t) => {
              if (typeof t == 'function') {
                this._setUpBindToBinding(t);
              } else {
                this._setUpBindToBinding((e) => e[t]);
              }
            },
          };
        }
        _setUpBindToBinding(t) {
          const e = this._bindToCollection;
          const n = (n, i, o) => {
            const r = e._bindToCollection == this;
            const s = e._bindToInternalToExternalMap.get(i);
            if (r && s) {
              this._bindToExternalToInternalMap.set(i, s);
              this._bindToInternalToExternalMap.set(s, i);
            } else {
              const n = t(i);
              if (!n) {
                this._skippedIndexesFromExternal.push(o);
                return;
              }
              let r = o;
              for (const t of this._skippedIndexesFromExternal) {
                if (o > t) {
                  r--;
                }
              }
              for (const t of e._skippedIndexesFromExternal) {
                if (r >= t) {
                  r++;
                }
              }
              this._bindToExternalToInternalMap.set(i, n);
              this._bindToInternalToExternalMap.set(n, i);
              this.add(n, r);
              for (
                let t = 0;
                t < e._skippedIndexesFromExternal.length;
                t++
              ) {
                if (r <= e._skippedIndexesFromExternal[t]) {
                  e._skippedIndexesFromExternal[t]++;
                }
              }
            }
          };
          for (const t of e) {
            n(null, t, e.getIndex(t));
          }
          this.listenTo(e, 'add', n);
          this.listenTo(e, 'remove', (t, e, n) => {
            const i = this._bindToExternalToInternalMap.get(e);
            if (i) {
              this.remove(i);
            }
            this._skippedIndexesFromExternal =
              this._skippedIndexesFromExternal.reduce((t, e) => {
                if (n < e) {
                  t.push(e - 1);
                }
                if (n > e) {
                  t.push(e);
                }
                return t;
              }, []);
          });
        }
        _getItemIdBeforeAdding(t) {
          const e = this._idProperty;
          let n;
          if (e in t) {
            n = t[e];
            if (typeof n != 'string') {
              throw new h('collection-add-invalid-id', this);
            }
            if (this.get(n)) {
              throw new h('collection-add-item-already-exists', this);
            }
          } else {
            t[e] = n = s();
          }
          return n;
        }
        _remove(t) {
          let e, n, i;
          let o = false;
          const r = this._idProperty;
          if (typeof t == 'string') {
            n = t;
            i = this._itemMap.get(n);
            o = !i;
            if (i) {
              e = this._items.indexOf(i);
            }
          } else if (typeof t == 'number') {
            e = t;
            i = this._items[e];
            o = !i;
            if (i) {
              n = i[r];
            }
          } else {
            i = t;
            n = i[r];
            e = this._items.indexOf(i);
            o = e == -1 || !this._itemMap.get(n);
          }
          if (o) {
            throw new h('collection-remove-404', this);
          }
          this._items.splice(e, 1);
          this._itemMap.delete(n);
          const s = this._bindToInternalToExternalMap.get(i);
          this._bindToInternalToExternalMap.delete(i);
          this._bindToExternalToInternalMap.delete(s);
          this.fire('remove', i, e);
          return [i, e];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      class xa {
        constructor(t, e = [], n = []) {
          this._context = t;
          this._plugins = new Map();
          this._availablePlugins = new Map();
          for (const t of e) {
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
          this._contextPlugins = new Map();
          for (const [t, e] of n) {
            this._contextPlugins.set(t, e);
            this._contextPlugins.set(e, t);
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
        }
        *[Symbol.iterator]() {
          for (const t of this._plugins) {
            if (typeof t[0] == 'function') {
              yield t;
            }
          }
        }
        get(t) {
          const e = this._plugins.get(t);
          if (!e) {
            let e = t;
            if (typeof t == 'function') {
              e = t.pluginName || t.name;
            }
            throw new h(
              'plugincollection-plugin-not-loaded',
              this._context,
              { plugin: e }
            );
          }
          return e;
        }
        has(t) {
          return this._plugins.has(t);
        }
        init(t, e = [], n = []) {
          const i = this;
          const o = this._context;
          f(t);
          m(t);
          const r = t.filter((t) => !d(t, e));
          const s = [...g(r)];
          v(s, n);
          const a = w(s);
          return _(a, 'init')
            .then(() => _(a, 'afterInit'))
            .then(() => a);
          function c(t) {
            return typeof t === 'function';
          }
          function l(t) {
            return c(t) && t.isContextPlugin;
          }
          function d(t, e) {
            return e.some((e) => {
              if (e === t) {
                return true;
              }
              if (u(t) === e) {
                return true;
              }
              if (u(e) === t) {
                return true;
              }
              return false;
            });
          }
          function u(t) {
            return c(t) ? t.pluginName || t.name : t;
          }
          function f(t, e = new Set()) {
            t.forEach((t) => {
              if (!c(t)) {
                return;
              }
              if (e.has(t)) {
                return;
              }
              e.add(t);
              if (
                t.pluginName &&
                !i._availablePlugins.has(t.pluginName)
              ) {
                i._availablePlugins.set(t.pluginName, t);
              }
              if (t.requires) {
                f(t.requires, e);
              }
            });
          }
          function g(t, e = new Set()) {
            return t
              .map((t) => (c(t) ? t : i._availablePlugins.get(t)))
              .reduce((t, n) => {
                if (e.has(n)) {
                  return t;
                }
                e.add(n);
                if (n.requires) {
                  m(n.requires, n);
                  g(n.requires, e).forEach((e) => t.add(e));
                }
                return t.add(n);
              }, new Set());
          }
          function m(t, e = null) {
            t.map((t) =>
              c(t) ? t : i._availablePlugins.get(t) || t
            ).forEach((t) => {
              p(t, e);
              k(t, e);
              b(t, e);
            });
          }
          function p(t, e) {
            if (c(t)) {
              return;
            }
            if (e) {
              throw new h('plugincollection-soft-required', o, {
                missingPlugin: t,
                requiredBy: u(e),
              });
            }
            throw new h('plugincollection-plugin-not-found', o, {
              plugin: t,
            });
          }
          function k(t, e) {
            if (!l(e)) {
              return;
            }
            if (l(t)) {
              return;
            }
            throw new h('plugincollection-context-required', o, {
              plugin: u(t),
              requiredBy: u(e),
            });
          }
          function b(t, n) {
            if (!n) {
              return;
            }
            if (!d(t, e)) {
              return;
            }
            throw new h('plugincollection-required', o, {
              plugin: u(t),
              requiredBy: u(n),
            });
          }
          function w(t) {
            return t.map((t) => {
              const e = i._contextPlugins.get(t) || new t(o);
              i._add(t, e);
              return e;
            });
          }
          function _(t, e) {
            return t.reduce((t, n) => {
              if (!n[e]) {
                return t;
              }
              if (i._contextPlugins.has(n)) {
                return t;
              }
              return t.then(n[e].bind(n));
            }, Promise.resolve());
          }
          function v(t, e) {
            for (const n of e) {
              if (typeof n != 'function') {
                throw new h(
                  'plugincollection-replace-plugin-invalid-type',
                  null,
                  { pluginItem: n }
                );
              }
              const e = n.pluginName;
              if (!e) {
                throw new h(
                  'plugincollection-replace-plugin-missing-name',
                  null,
                  { pluginItem: n }
                );
              }
              if (n.requires && n.requires.length) {
                throw new h(
                  'plugincollection-plugin-for-replacing-cannot-have-dependencies',
                  null,
                  { pluginName: e }
                );
              }
              const o = i._availablePlugins.get(e);
              if (!o) {
                throw new h(
                  'plugincollection-plugin-for-replacing-not-exist',
                  null,
                  { pluginName: e }
                );
              }
              const r = t.indexOf(o);
              if (r === -1) {
                if (i._contextPlugins.has(o)) {
                  return;
                }
                throw new h(
                  'plugincollection-plugin-for-replacing-not-loaded',
                  null,
                  { pluginName: e }
                );
              }
              if (o.requires && o.requires.length) {
                throw new h(
                  'plugincollection-replaced-plugin-cannot-have-dependencies',
                  null,
                  { pluginName: e }
                );
              }
              t.splice(r, 1, n);
              i._availablePlugins.set(e, n);
            }
          }
        }
        destroy() {
          const t = [];
          for (const [, e] of this) {
            if (
              typeof e.destroy == 'function' &&
              !this._contextPlugins.has(e)
            ) {
              t.push(e.destroy());
            }
          }
          return Promise.all(t);
        }
        _add(t, e) {
          this._plugins.set(t, e);
          const n = t.pluginName;
          if (!n) {
            return;
          }
          if (this._plugins.has(n)) {
            throw new h(
              'plugincollection-plugin-name-conflict',
              null,
              {
                pluginName: n,
                plugin1: this._plugins.get(n).constructor,
                plugin2: t,
              }
            );
          }
          this._plugins.set(n, e);
        }
      }
      et(xa, C);
      function Ea(t) {
        return Array.isArray(t) ? t : [t];
      }
      let Da;
      try {
        Da = { window, document };
      } catch (t) {
        Da = { window: {}, document: {} };
      }
      const Sa = Da;
      if (!Sa.window.CKEDITOR_TRANSLATIONS) {
        Sa.window.CKEDITOR_TRANSLATIONS = {};
      }
      function Ta(t, e, n) {
        if (!global.window.CKEDITOR_TRANSLATIONS[t]) {
          global.window.CKEDITOR_TRANSLATIONS[t] = {};
        }
        const i = global.window.CKEDITOR_TRANSLATIONS[t];
        i.dictionary = i.dictionary || {};
        i.getPluralForm = n || i.getPluralForm;
        Object.assign(i.dictionary, e);
      }
      function Ba(t, e, n = 1) {
        if (typeof n !== 'number') {
          throw new h(
            'translation-service-quantity-not-a-number',
            null,
            { quantity: n }
          );
        }
        const i = Ra();
        if (i === 1) {
          t = Object.keys(Sa.window.CKEDITOR_TRANSLATIONS)[0];
        }
        const o = e.id || e.string;
        if (i === 0 || !Ia(t, o)) {
          if (n !== 1) {
            return e.plural;
          }
          return e.string;
        }
        const r = Sa.window.CKEDITOR_TRANSLATIONS[t].dictionary;
        const s =
          Sa.window.CKEDITOR_TRANSLATIONS[t].getPluralForm ||
          ((t) => (t === 1 ? 0 : 1));
        const a = r[o];
        if (typeof a === 'string') {
          return a;
        }
        const c = Number(s(n));
        return a[c];
      }
      function Pa() {
        global.window.CKEDITOR_TRANSLATIONS = {};
      }
      function Ia(t, e) {
        return (
          !!Sa.window.CKEDITOR_TRANSLATIONS[t] &&
          !!Sa.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        );
      }
      function Ra() {
        return Object.keys(Sa.window.CKEDITOR_TRANSLATIONS).length;
      }
      const za = [
        'ar',
        'ara',
        'fa',
        'per',
        'fas',
        'he',
        'heb',
        'ku',
        'kur',
        'ug',
        'uig',
      ];
      function Oa(t) {
        return za.includes(t) ? 'rtl' : 'ltr';
      }
      class Fa {
        constructor(t = {}) {
          this.uiLanguage = t.uiLanguage || 'en';
          this.contentLanguage = t.contentLanguage || this.uiLanguage;
          this.uiLanguageDirection = Oa(this.uiLanguage);
          this.contentLanguageDirection = Oa(this.contentLanguage);
          this.t = (t, e) => this._t(t, e);
        }
        get language() {
          console.warn(
            'locale-deprecated-language-property: ' +
              'The Locale#language property has been deprecated and will be removed in the near future. ' +
              'Please use #uiLanguage and #contentLanguage properties instead.'
          );
          return this.uiLanguage;
        }
        _t(t, e = []) {
          e = Ea(e);
          if (typeof t === 'string') {
            t = { string: t };
          }
          const n = !!t.plural;
          const i = n ? e[0] : 1;
          const o = Ba(this.uiLanguage, t, i);
          return Na(o, e);
        }
      }
      function Na(t, e) {
        return t.replace(/%(\d+)/g, (t, n) =>
          n < e.length ? e[n] : t
        );
      }
      class Ma {
        constructor(t) {
          this.config = new _a(t, this.constructor.defaultConfig);
          const e = this.constructor.builtinPlugins;
          this.config.define('plugins', e);
          this.plugins = new xa(this, e);
          const n = this.config.get('language') || {};
          this.locale = new Fa({
            uiLanguage: typeof n === 'string' ? n : n.ui,
            contentLanguage: this.config.get('language.content'),
          });
          this.t = this.locale.t;
          this.editors = new ya();
          this._contextOwner = null;
        }
        initPlugins() {
          const t = this.config.get('plugins') || [];
          const e = this.config.get('substitutePlugins') || [];
          for (const n of t.concat(e)) {
            if (typeof n != 'function') {
              throw new h(
                'context-initplugins-constructor-only',
                null,
                { Plugin: n }
              );
            }
            if (n.isContextPlugin !== true) {
              throw new h(
                'context-initplugins-invalid-plugin',
                null,
                { Plugin: n }
              );
            }
          }
          return this.plugins.init(t, [], e);
        }
        destroy() {
          return Promise.all(
            Array.from(this.editors, (t) => t.destroy())
          ).then(() => this.plugins.destroy());
        }
        _addEditor(t, e) {
          if (this._contextOwner) {
            throw new h('context-addeditor-private-context');
          }
          this.editors.add(t);
          if (e) {
            this._contextOwner = t;
          }
        }
        _removeEditor(t) {
          if (this.editors.has(t)) {
            this.editors.remove(t);
          }
          if (this._contextOwner === t) {
            return this.destroy();
          }
          return Promise.resolve();
        }
        _getEditorConfig() {
          const t = {};
          for (const e of this.config.names()) {
            if (
              !['plugins', 'removePlugins', 'extraPlugins'].includes(
                e
              )
            ) {
              t[e] = this.config.get(e);
            }
          }
          return t;
        }
        static create(t) {
          return new Promise((e) => {
            const n = new this(t);
            e(n.initPlugins().then(() => n));
          });
        }
      }
      class La {
        constructor(t) {
          this.context = t;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return true;
        }
      }
      et(La, q);
      class Va {
        is() {
          throw new Error('is() method is abstract');
        }
      }
      function Ha(t, e) {
        const n = Math.min(t.length, e.length);
        for (let i = 0; i < n; i++) {
          if (t[i] != e[i]) {
            return i;
          }
        }
        if (t.length == e.length) {
          return 'same';
        } else if (t.length < e.length) {
          return 'prefix';
        } else {
          return 'extension';
        }
      }
      var ja = 4;
      function qa(t) {
        return fa(t, ja);
      }
      const Wa = qa;
      class Ua extends C(Va) {
        constructor(t) {
          super();
          this.document = t;
          this.parent = null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) == -1) {
            throw new h('view-node-not-found-in-parent', this);
          }
          return t;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.root.is('rootElement');
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.index);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const i = t.getAncestors(e);
          let o = 0;
          while (n[o] == i[o] && n[o]) {
            o++;
          }
          return o === 0 ? null : n[o - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const i = Ha(e, n);
          switch (i) {
            case 'prefix':
              return true;
            case 'extension':
              return false;
            default:
              return e[i] < n[i];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(t, e) {
          this.fire(`change:${t}`, e);
          if (this.parent) {
            this.parent._fireChange(t, e);
          }
        }
        toJSON() {
          const t = Wa(this);
          delete t.parent;
          return t;
        }
      }
      Ua.prototype.is = function (t) {
        return t === 'node' || t === 'view:node';
      };
      class Ga extends Ua {
        constructor(t, e) {
          super(t);
          this._textData = e;
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(t) {
          this._fireChange('text', this);
          this._textData = t;
        }
        isSimilar(t) {
          if (!(t instanceof Ga)) {
            return false;
          }
          return this === t || this.data === t.data;
        }
        _clone() {
          return new Ga(this.document, this.data);
        }
      }
      Ga.prototype.is = function (t) {
        return (
          t === '$text' ||
          t === 'view:$text' ||
          t === 'text' ||
          t === 'view:text' ||
          t === 'node' ||
          t === 'view:node'
        );
      };
      class $a extends Va {
        constructor(t, e, n) {
          super();
          this.textNode = t;
          if (e < 0 || e > t.data.length) {
            throw new h('view-textproxy-wrong-offsetintext', this);
          }
          if (n < 0 || e + n > t.data.length) {
            throw new h('view-textproxy-wrong-length', this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this.textNode : this.parent;
          while (n !== null) {
            e[t.parentFirst ? 'push' : 'unshift'](n);
            n = n.parent;
          }
          return e;
        }
      }
      $a.prototype.is = function (t) {
        return (
          t === '$textProxy' ||
          t === 'view:$textProxy' ||
          t === 'textProxy' ||
          t === 'view:textProxy'
        );
      };
      function Ka(t) {
        const e = new Map();
        for (const n in t) {
          e.set(n, t[n]);
        }
        return e;
      }
      function Za(t) {
        if (Ca(t)) {
          return new Map(t);
        } else {
          return Ka(t);
        }
      }
      class Ja {
        constructor(...t) {
          this._patterns = [];
          this.add(...t);
        }
        add(...t) {
          for (let e of t) {
            if (typeof e == 'string' || e instanceof RegExp) {
              e = { name: e };
            }
            this._patterns.push(e);
          }
        }
        match(...t) {
          for (const e of t) {
            for (const t of this._patterns) {
              const n = Ya(e, t);
              if (n) {
                return { element: e, pattern: t, match: n };
              }
            }
          }
          return null;
        }
        matchAll(...t) {
          const e = [];
          for (const n of t) {
            for (const t of this._patterns) {
              const i = Ya(n, t);
              if (i) {
                e.push({ element: n, pattern: t, match: i });
              }
            }
          }
          return e.length > 0 ? e : null;
        }
        getElementName() {
          if (this._patterns.length !== 1) {
            return null;
          }
          const t = this._patterns[0];
          const e = t.name;
          return typeof t != 'function' && e && !(e instanceof RegExp)
            ? e
            : null;
        }
      }
      function Ya(t, e) {
        if (typeof e == 'function') {
          return e(t);
        }
        const n = {};
        if (e.name) {
          n.name = Qa(e.name, t.name);
          if (!n.name) {
            return null;
          }
        }
        if (e.attributes) {
          n.attributes = ic(e.attributes, t);
          if (!n.attributes) {
            return null;
          }
        }
        if (e.classes) {
          n.classes = oc(e.classes, t);
          if (!n.classes) {
            return null;
          }
        }
        if (e.styles) {
          n.styles = rc(e.styles, t);
          if (!n.styles) {
            return null;
          }
        }
        return n;
      }
      function Qa(t, e) {
        if (t instanceof RegExp) {
          return !!e.match(t);
        }
        return t === e;
      }
      function Xa(t, e, n) {
        const i = tc(t);
        const o = Array.from(e);
        const r = [];
        i.forEach(([t, e]) => {
          o.forEach((i) => {
            if (ec(t, i) && nc(e, i, n)) {
              r.push(i);
            }
          });
        });
        if (!i.length || r.length < i.length) {
          return undefined;
        }
        return r;
      }
      function tc(t) {
        if (Array.isArray(t)) {
          return t.map((t) => {
            if (jt(t)) {
              if (t.key === undefined || t.value === undefined) {
                u('matcher-pattern-missing-key-or-value', t);
              }
              return [t.key, t.value];
            }
            return [t, true];
          });
        }
        if (jt(t)) {
          return Object.entries(t);
        }
        return [[t, true]];
      }
      function ec(t, e) {
        return (
          t === true || t === e || (t instanceof RegExp && e.match(t))
        );
      }
      function nc(t, e, n) {
        if (t === true) {
          return true;
        }
        const i = n(e);
        return (
          t === i || (t instanceof RegExp && !!String(i).match(t))
        );
      }
      function ic(t, e) {
        const n = new Set(e.getAttributeKeys());
        if (jt(t)) {
          if (t.style !== undefined) {
            u('matcher-pattern-deprecated-attributes-style-key', t);
          }
          if (t.class !== undefined) {
            u('matcher-pattern-deprecated-attributes-class-key', t);
          }
        } else {
          n.delete('style');
          n.delete('class');
        }
        return Xa(t, n, (t) => e.getAttribute(t));
      }
      function oc(t, e) {
        return Xa(t, e.getClassNames(), () => {});
      }
      function rc(t, e) {
        return Xa(t, e.getStyleNames(true), (t) => e.getStyle(t));
      }
      var sc = '[object Symbol]';
      function ac(t) {
        return typeof t == 'symbol' || (zt(t) && St(t) == sc);
      }
      const cc = ac;
      var lc = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        dc = /^\w*$/;
      function hc(t, e) {
        if (ni(t)) {
          return false;
        }
        var n = typeof t;
        if (
          n == 'number' ||
          n == 'symbol' ||
          n == 'boolean' ||
          t == null ||
          cc(t)
        ) {
          return true;
        }
        return (
          dc.test(t) || !lc.test(t) || (e != null && t in Object(e))
        );
      }
      const uc = hc;
      var fc = 'Expected a function';
      function gc(t, e) {
        if (
          typeof t != 'function' ||
          (e != null && typeof e != 'function')
        ) {
          throw new TypeError(fc);
        }
        var n = function () {
          var i = arguments,
            o = e ? e.apply(this, i) : i[0],
            r = n.cache;
          if (r.has(o)) {
            return r.get(o);
          }
          var s = t.apply(this, i);
          n.cache = r.set(o, s) || r;
          return s;
        };
        n.cache = new (gc.Cache || Dn)();
        return n;
      }
      gc.Cache = Dn;
      const mc = gc;
      var pc = 500;
      function kc(t) {
        var e = mc(t, function (t) {
          if (n.size === pc) {
            n.clear();
          }
          return t;
        });
        var n = e.cache;
        return e;
      }
      const bc = kc;
      var wc =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var _c = /\\(\\)?/g;
      var vc = bc(function (t) {
        var e = [];
        if (t.charCodeAt(0) === 46) {
          e.push('');
        }
        t.replace(wc, function (t, n, i, o) {
          e.push(i ? o.replace(_c, '$1') : n || t);
        });
        return e;
      });
      const Ac = vc;
      function Cc(t, e) {
        var n = -1,
          i = t == null ? 0 : t.length,
          o = Array(i);
        while (++n < i) {
          o[n] = e(t[n], n, t);
        }
        return o;
      }
      const yc = Cc;
      var xc = 1 / 0;
      var Ec = ft ? ft.prototype : undefined,
        Dc = Ec ? Ec.toString : undefined;
      function Sc(t) {
        if (typeof t == 'string') {
          return t;
        }
        if (ni(t)) {
          return yc(t, Sc) + '';
        }
        if (cc(t)) {
          return Dc ? Dc.call(t) : '';
        }
        var e = t + '';
        return e == '0' && 1 / t == -xc ? '-0' : e;
      }
      const Tc = Sc;
      function Bc(t) {
        return t == null ? '' : Tc(t);
      }
      const Pc = Bc;
      function Ic(t, e) {
        if (ni(t)) {
          return t;
        }
        return uc(t, e) ? [t] : Ac(Pc(t));
      }
      const Rc = Ic;
      function zc(t) {
        var e = t == null ? 0 : t.length;
        return e ? t[e - 1] : undefined;
      }
      const Oc = zc;
      var Fc = 1 / 0;
      function Nc(t) {
        if (typeof t == 'string' || cc(t)) {
          return t;
        }
        var e = t + '';
        return e == '0' && 1 / t == -Fc ? '-0' : e;
      }
      const Mc = Nc;
      function Lc(t, e) {
        e = Rc(e, t);
        var n = 0,
          i = e.length;
        while (t != null && n < i) {
          t = t[Mc(e[n++])];
        }
        return n && n == i ? t : undefined;
      }
      const Vc = Lc;
      function Hc(t, e, n) {
        var i = -1,
          o = t.length;
        if (e < 0) {
          e = -e > o ? 0 : o + e;
        }
        n = n > o ? o : n;
        if (n < 0) {
          n += o;
        }
        o = e > n ? 0 : (n - e) >>> 0;
        e >>>= 0;
        var r = Array(o);
        while (++i < o) {
          r[i] = t[i + e];
        }
        return r;
      }
      const jc = Hc;
      function qc(t, e) {
        return e.length < 2 ? t : Vc(t, jc(e, 0, -1));
      }
      const Wc = qc;
      function Uc(t, e) {
        e = Rc(e, t);
        t = Wc(t, e);
        return t == null || delete t[Mc(Oc(e))];
      }
      const Gc = Uc;
      function $c(t, e) {
        return t == null ? true : Gc(t, e);
      }
      const Kc = $c;
      function Zc(t, e, n) {
        var i = t == null ? undefined : Vc(t, e);
        return i === undefined ? n : i;
      }
      const Jc = Zc;
      function Yc(t, e, n) {
        if (
          (n !== undefined && !Gt(t[e], n)) ||
          (n === undefined && !(e in t))
        ) {
          Mn(t, e, n);
        }
      }
      const Qc = Yc;
      function Xc(t) {
        return function (e, n, i) {
          var o = -1,
            r = Object(e),
            s = i(e),
            a = s.length;
          while (a--) {
            var c = s[t ? a : ++o];
            if (n(r[c], c, r) === false) {
              break;
            }
          }
          return e;
        };
      }
      const tl = Xc;
      var el = tl();
      const nl = el;
      function il(t) {
        return zt(t) && bo(t);
      }
      const ol = il;
      function rl(t, e) {
        if (e === 'constructor' && typeof t[e] === 'function') {
          return;
        }
        if (e == '__proto__') {
          return;
        }
        return t[e];
      }
      const sl = rl;
      function al(t) {
        return Wn(t, Bo(t));
      }
      const cl = al;
      function ll(t, e, n, i, o, r, s) {
        var a = sl(t, n),
          c = sl(e, n),
          l = s.get(c);
        if (l) {
          Qc(t, n, l);
          return;
        }
        var d = r ? r(a, c, n + '', t, e, s) : undefined;
        var h = d === undefined;
        if (h) {
          var u = ni(c),
            f = !u && hi(c),
            g = !u && !f && no(c);
          d = c;
          if (u || f || g) {
            if (ni(a)) {
              d = a;
            } else if (ol(a)) {
              d = Ho(a);
            } else if (f) {
              h = false;
              d = Lo(c, true);
            } else if (g) {
              h = false;
              d = Yr(c, true);
            } else {
              d = [];
            }
          } else if (jt(c) || ti(c)) {
            d = a;
            if (ti(a)) {
              d = cl(a);
            } else if (!N(a) || _e(a)) {
              d = Cs(c);
            }
          } else {
            h = false;
          }
        }
        if (h) {
          s.set(c, d);
          o(d, c, i, r, s);
          s['delete'](c);
        }
        Qc(t, n, d);
      }
      const dl = ll;
      function hl(t, e, n, i, o) {
        if (t === e) {
          return;
        }
        nl(
          e,
          function (r, s) {
            o || (o = new In());
            if (N(r)) {
              dl(t, e, s, n, hl, i, o);
            } else {
              var a = i ? i(sl(t, s), r, s + '', t, e, o) : undefined;
              if (a === undefined) {
                a = r;
              }
              Qc(t, s, a);
            }
          },
          Bo
        );
      }
      const ul = hl;
      function fl(t) {
        return t;
      }
      const gl = fl;
      function ml(t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e);
          case 1:
            return t.call(e, n[0]);
          case 2:
            return t.call(e, n[0], n[1]);
          case 3:
            return t.call(e, n[0], n[1], n[2]);
        }
        return t.apply(e, n);
      }
      const pl = ml;
      var kl = Math.max;
      function bl(t, e, n) {
        e = kl(e === undefined ? t.length - 1 : e, 0);
        return function () {
          var i = arguments,
            o = -1,
            r = kl(i.length - e, 0),
            s = Array(r);
          while (++o < r) {
            s[o] = i[e + o];
          }
          o = -1;
          var a = Array(e + 1);
          while (++o < e) {
            a[o] = i[o];
          }
          a[e] = n(s);
          return pl(t, this, a);
        };
      }
      const wl = bl;
      function _l(t) {
        return function () {
          return t;
        };
      }
      const vl = _l;
      var Al = !Fn
        ? gl
        : function (t, e) {
            return Fn(t, 'toString', {
              configurable: true,
              enumerable: false,
              value: vl(e),
              writable: true,
            });
          };
      const Cl = Al;
      var yl = 800,
        xl = 16;
      var El = Date.now;
      function Dl(t) {
        var e = 0,
          n = 0;
        return function () {
          var i = El(),
            o = xl - (i - n);
          n = i;
          if (o > 0) {
            if (++e >= yl) {
              return arguments[0];
            }
          } else {
            e = 0;
          }
          return t.apply(undefined, arguments);
        };
      }
      const Sl = Dl;
      var Tl = Sl(Cl);
      const Bl = Tl;
      function Pl(t, e) {
        return Bl(wl(t, e, gl), t + '');
      }
      const Il = Pl;
      function Rl(t, e, n) {
        if (!N(n)) {
          return false;
        }
        var i = typeof e;
        if (
          i == 'number'
            ? bo(n) && mi(e, n.length)
            : i == 'string' && e in n
        ) {
          return Gt(n[e], t);
        }
        return false;
      }
      const zl = Rl;
      function Ol(t) {
        return Il(function (e, n) {
          var i = -1,
            o = n.length,
            r = o > 1 ? n[o - 1] : undefined,
            s = o > 2 ? n[2] : undefined;
          r =
            t.length > 3 && typeof r == 'function'
              ? (o--, r)
              : undefined;
          if (s && zl(n[0], n[1], s)) {
            r = o < 3 ? undefined : r;
            o = 1;
          }
          e = Object(e);
          while (++i < o) {
            var a = n[i];
            if (a) {
              t(e, a, i, r);
            }
          }
          return e;
        });
      }
      const Fl = Ol;
      var Nl = Fl(function (t, e, n) {
        ul(t, e, n);
      });
      const Ml = Nl;
      function Ll(t, e, n, i) {
        if (!N(t)) {
          return t;
        }
        e = Rc(e, t);
        var o = -1,
          r = e.length,
          s = r - 1,
          a = t;
        while (a != null && ++o < r) {
          var c = Mc(e[o]),
            l = n;
          if (
            c === '__proto__' ||
            c === 'constructor' ||
            c === 'prototype'
          ) {
            return t;
          }
          if (o != s) {
            var d = a[c];
            l = i ? i(d, c, a) : undefined;
            if (l === undefined) {
              l = N(d) ? d : mi(e[o + 1]) ? [] : {};
            }
          }
          jn(a, c, l);
          a = a[c];
        }
        return t;
      }
      const Vl = Ll;
      function Hl(t, e, n) {
        return t == null ? t : Vl(t, e, n);
      }
      const jl = Hl;
      class ql {
        constructor(t) {
          this._styles = {};
          this._styleProcessor = t;
        }
        get isEmpty() {
          const t = Object.entries(this._styles);
          const e = Array.from(t);
          return !e.length;
        }
        get size() {
          if (this.isEmpty) {
            return 0;
          }
          return this.getStyleNames().length;
        }
        setTo(t) {
          this.clear();
          const e = Array.from(Ul(t).entries());
          for (const [t, n] of e) {
            this._styleProcessor.toNormalizedForm(t, n, this._styles);
          }
        }
        has(t) {
          if (this.isEmpty) {
            return false;
          }
          const e = this._styleProcessor.getReducedForm(
            t,
            this._styles
          );
          const n = e.find(([e]) => e === t);
          return Array.isArray(n);
        }
        set(t, e) {
          if (N(t)) {
            for (const [e, n] of Object.entries(t)) {
              this._styleProcessor.toNormalizedForm(
                e,
                n,
                this._styles
              );
            }
          } else {
            this._styleProcessor.toNormalizedForm(t, e, this._styles);
          }
        }
        remove(t) {
          const e = Gl(t);
          Kc(this._styles, e);
          delete this._styles[t];
          this._cleanEmptyObjectsOnPath(e);
        }
        getNormalized(t) {
          return this._styleProcessor.getNormalized(t, this._styles);
        }
        toString() {
          if (this.isEmpty) {
            return '';
          }
          return (
            this._getStylesEntries()
              .map((t) => t.join(':'))
              .sort()
              .join(';') + ';'
          );
        }
        getAsString(t) {
          if (this.isEmpty) {
            return;
          }
          if (this._styles[t] && !N(this._styles[t])) {
            return this._styles[t];
          }
          const e = this._styleProcessor.getReducedForm(
            t,
            this._styles
          );
          const n = e.find(([e]) => e === t);
          if (Array.isArray(n)) {
            return n[1];
          }
        }
        getStyleNames(t = false) {
          if (this.isEmpty) {
            return [];
          }
          if (t) {
            return this._styleProcessor.getStyleNames(this._styles);
          }
          const e = this._getStylesEntries();
          return e.map(([t]) => t);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const t = [];
          const e = Object.keys(this._styles);
          for (const n of e) {
            t.push(
              ...this._styleProcessor.getReducedForm(n, this._styles)
            );
          }
          return t;
        }
        _cleanEmptyObjectsOnPath(t) {
          const e = t.split('.');
          const n = e.length > 1;
          if (!n) {
            return;
          }
          const i = e.splice(0, e.length - 1).join('.');
          const o = Jc(this._styles, i);
          if (!o) {
            return;
          }
          const r = !Array.from(Object.keys(o)).length;
          if (r) {
            this.remove(i);
          }
        }
      }
      class Wl {
        constructor() {
          this._normalizers = new Map();
          this._extractors = new Map();
          this._reducers = new Map();
          this._consumables = new Map();
        }
        toNormalizedForm(t, e, n) {
          if (N(e)) {
            $l(n, Gl(t), e);
            return;
          }
          if (this._normalizers.has(t)) {
            const i = this._normalizers.get(t);
            const { path: o, value: r } = i(e);
            $l(n, o, r);
          } else {
            $l(n, t, e);
          }
        }
        getNormalized(t, e) {
          if (!t) {
            return Ml({}, e);
          }
          if (e[t] !== undefined) {
            return e[t];
          }
          if (this._extractors.has(t)) {
            const n = this._extractors.get(t);
            if (typeof n === 'string') {
              return Jc(e, n);
            }
            const i = n(t, e);
            if (i) {
              return i;
            }
          }
          return Jc(e, Gl(t));
        }
        getReducedForm(t, e) {
          const n = this.getNormalized(t, e);
          if (n === undefined) {
            return [];
          }
          if (this._reducers.has(t)) {
            const e = this._reducers.get(t);
            return e(n);
          }
          return [[t, n]];
        }
        getStyleNames(t) {
          const e = Array.from(this._consumables.keys()).filter(
            (e) => {
              const n = this.getNormalized(e, t);
              if (n && typeof n == 'object') {
                return Object.keys(n).length;
              }
              return n;
            }
          );
          const n = new Set([...e, ...Object.keys(t)]);
          return Array.from(n.values());
        }
        getRelatedStyles(t) {
          return this._consumables.get(t) || [];
        }
        setNormalizer(t, e) {
          this._normalizers.set(t, e);
        }
        setExtractor(t, e) {
          this._extractors.set(t, e);
        }
        setReducer(t, e) {
          this._reducers.set(t, e);
        }
        setStyleRelation(t, e) {
          this._mapStyleNames(t, e);
          for (const n of e) {
            this._mapStyleNames(n, [t]);
          }
        }
        _mapStyleNames(t, e) {
          if (!this._consumables.has(t)) {
            this._consumables.set(t, []);
          }
          this._consumables.get(t).push(...e);
        }
      }
      function Ul(t) {
        let e = null;
        let n = 0;
        let i = 0;
        let o = null;
        const r = new Map();
        if (t === '') {
          return r;
        }
        if (t.charAt(t.length - 1) != ';') {
          t = t + ';';
        }
        for (let s = 0; s < t.length; s++) {
          const a = t.charAt(s);
          if (e === null) {
            switch (a) {
              case ':':
                if (!o) {
                  o = t.substr(n, s - n);
                  i = s + 1;
                }
                break;
              case '"':
              case "'":
                e = a;
                break;
              case ';': {
                const e = t.substr(i, s - i);
                if (o) {
                  r.set(o.trim(), e.trim());
                }
                o = null;
                n = s + 1;
                break;
              }
            }
          } else if (a === e) {
            e = null;
          }
        }
        return r;
      }
      function Gl(t) {
        return t.replace('-', '.');
      }
      function $l(t, e, n) {
        let i = n;
        if (N(n)) {
          i = Ml({}, Jc(t, e), n);
        }
        jl(t, e, i);
      }
      class Kl extends Ua {
        constructor(t, e, n, i) {
          super(t);
          this.name = e;
          this._attrs = Zl(n);
          this._children = [];
          if (i) {
            this._insertChild(0, i);
          }
          this._classes = new Set();
          if (this._attrs.has('class')) {
            const t = this._attrs.get('class');
            Jl(this._classes, t);
            this._attrs.delete('class');
          }
          this._styles = new ql(this.document.stylesProcessor);
          if (this._attrs.has('style')) {
            this._styles.setTo(this._attrs.get('style'));
            this._attrs.delete('style');
          }
          this._customProperties = new Map();
          this._unsafeAttributesToRender = [];
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          if (this._classes.size > 0) {
            yield 'class';
          }
          if (!this._styles.isEmpty) {
            yield 'style';
          }
          yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries();
          if (this._classes.size > 0) {
            yield ['class', this.getAttribute('class')];
          }
          if (!this._styles.isEmpty) {
            yield ['style', this.getAttribute('style')];
          }
        }
        getAttribute(t) {
          if (t == 'class') {
            if (this._classes.size > 0) {
              return [...this._classes].join(' ');
            }
            return undefined;
          }
          if (t == 'style') {
            const t = this._styles.toString();
            return t == '' ? undefined : t;
          }
          return this._attrs.get(t);
        }
        hasAttribute(t) {
          if (t == 'class') {
            return this._classes.size > 0;
          }
          if (t == 'style') {
            return !this._styles.isEmpty;
          }
          return this._attrs.has(t);
        }
        isSimilar(t) {
          if (!(t instanceof Kl)) {
            return false;
          }
          if (this === t) {
            return true;
          }
          if (this.name != t.name) {
            return false;
          }
          if (
            this._attrs.size !== t._attrs.size ||
            this._classes.size !== t._classes.size ||
            this._styles.size !== t._styles.size
          ) {
            return false;
          }
          for (const [e, n] of this._attrs) {
            if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
              return false;
            }
          }
          for (const e of this._classes) {
            if (!t._classes.has(e)) {
              return false;
            }
          }
          for (const e of this._styles.getStyleNames()) {
            if (
              !t._styles.has(e) ||
              t._styles.getAsString(e) !== this._styles.getAsString(e)
            ) {
              return false;
            }
          }
          return true;
        }
        hasClass(...t) {
          for (const e of t) {
            if (!this._classes.has(e)) {
              return false;
            }
          }
          return true;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(t) {
          return this._styles.getAsString(t);
        }
        getNormalizedStyle(t) {
          return this._styles.getNormalized(t);
        }
        getStyleNames(t) {
          return this._styles.getStyleNames(t);
        }
        hasStyle(...t) {
          for (const e of t) {
            if (!this._styles.has(e)) {
              return false;
            }
          }
          return true;
        }
        findAncestor(...t) {
          const e = new Ja(...t);
          let n = this.parent;
          while (n && !n.is('documentFragment')) {
            if (e.match(n)) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        getCustomProperty(t) {
          return this._customProperties.get(t);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const t = Array.from(this._classes).sort().join(',');
          const e = this._styles.toString();
          const n = Array.from(this._attrs)
            .map((t) => `${t[0]}="${t[1]}"`)
            .sort()
            .join(' ');
          return (
            this.name +
            (t == '' ? '' : ` class="${t}"`) +
            (!e ? '' : ` style="${e}"`) +
            (n == '' ? '' : ` ${n}`)
          );
        }
        shouldRenderUnsafeAttribute(t) {
          return this._unsafeAttributesToRender.includes(t);
        }
        _clone(t = false) {
          const e = [];
          if (t) {
            for (const n of this.getChildren()) {
              e.push(n._clone(t));
            }
          }
          const n = new this.constructor(
            this.document,
            this.name,
            this._attrs,
            e
          );
          n._classes = new Set(this._classes);
          n._styles.set(this._styles.getNormalized());
          n._customProperties = new Map(this._customProperties);
          n.getFillerOffset = this.getFillerOffset;
          n._unsafeAttributesToRender =
            this._unsafeAttributesToRender;
          return n;
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          this._fireChange('children', this);
          let n = 0;
          const i = Yl(this.document, e);
          for (const e of i) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            e.document = this.document;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange('children', this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _setAttribute(t, e) {
          e = String(e);
          this._fireChange('attributes', this);
          if (t == 'class') {
            Jl(this._classes, e);
          } else if (t == 'style') {
            this._styles.setTo(e);
          } else {
            this._attrs.set(t, e);
          }
        }
        _removeAttribute(t) {
          this._fireChange('attributes', this);
          if (t == 'class') {
            if (this._classes.size > 0) {
              this._classes.clear();
              return true;
            }
            return false;
          }
          if (t == 'style') {
            if (!this._styles.isEmpty) {
              this._styles.clear();
              return true;
            }
            return false;
          }
          return this._attrs.delete(t);
        }
        _addClass(t) {
          this._fireChange('attributes', this);
          for (const e of Ea(t)) {
            this._classes.add(e);
          }
        }
        _removeClass(t) {
          this._fireChange('attributes', this);
          for (const e of Ea(t)) {
            this._classes.delete(e);
          }
        }
        _setStyle(t, e) {
          this._fireChange('attributes', this);
          if (jt(t)) {
            this._styles.set(t);
          } else {
            this._styles.set(t, e);
          }
        }
        _removeStyle(t) {
          this._fireChange('attributes', this);
          for (const e of Ea(t)) {
            this._styles.remove(e);
          }
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e);
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t);
        }
      }
      Kl.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'element' || t === 'view:element')
          );
        }
      };
      function Zl(t) {
        const e = Za(t);
        for (const [t, n] of e) {
          if (n === null) {
            e.delete(t);
          } else if (typeof n != 'string') {
            e.set(t, String(n));
          }
        }
        return e;
      }
      function Jl(t, e) {
        const n = e.split(/\s+/);
        t.clear();
        n.forEach((e) => t.add(e));
      }
      function Yl(t, e) {
        if (typeof e == 'string') {
          return [new Ga(t, e)];
        }
        if (!Ca(e)) {
          e = [e];
        }
        return Array.from(e).map((e) => {
          if (typeof e == 'string') {
            return new Ga(t, e);
          }
          if (e instanceof $a) {
            return new Ga(t, e.data);
          }
          return e;
        });
      }
      class Ql extends Kl {
        constructor(...t) {
          super(...t);
          this.getFillerOffset = Xl;
        }
      }
      Ql.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'containerElement' ||
              t === 'view:containerElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function Xl() {
        const t = [...this.getChildren()];
        const e = t[this.childCount - 1];
        if (e && e.is('element', 'br')) {
          return this.childCount;
        }
        for (const e of t) {
          if (!e.is('uiElement')) {
            return null;
          }
        }
        return this.childCount;
      }
      class td extends q(Ql) {
        constructor(...t) {
          super(...t);
          const e = t[0];
          this.set('isReadOnly', false);
          this.set('isFocused', false);
          this.bind('isReadOnly').to(e);
          this.bind('isFocused').to(
            e,
            'isFocused',
            (t) => t && e.selection.editableElement == this
          );
          this.listenTo(e.selection, 'change', () => {
            this.isFocused =
              e.isFocused && e.selection.editableElement == this;
          });
        }
        destroy() {
          this.stopListening();
        }
      }
      td.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'editableElement' ||
            t === 'view:editableElement' ||
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'editableElement' ||
              t === 'view:editableElement' ||
              t === 'containerElement' ||
              t === 'view:containerElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      const ed = Symbol('rootName');
      class nd extends td {
        constructor(t, e) {
          super(t, e);
          this.rootName = 'main';
        }
        get rootName() {
          return this.getCustomProperty(ed);
        }
        set rootName(t) {
          this._setCustomProperty(ed, t);
        }
        set _name(t) {
          this.name = t;
        }
      }
      nd.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rootElement' ||
            t === 'view:rootElement' ||
            t === 'editableElement' ||
            t === 'view:editableElement' ||
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'rootElement' ||
              t === 'view:rootElement' ||
              t === 'editableElement' ||
              t === 'view:editableElement' ||
              t === 'containerElement' ||
              t === 'view:containerElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      class id {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new h('view-tree-walker-no-start-position', null);
          }
          if (
            t.direction &&
            t.direction != 'forward' &&
            t.direction != 'backward'
          ) {
            throw new h(
              'view-tree-walker-unknown-direction',
              t.startPosition,
              { direction: t.direction }
            );
          }
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this.position = od._createAt(t.startPosition);
          } else {
            this.position = od._createAt(
              t.boundaries[
                t.direction == 'backward' ? 'end' : 'start'
              ]
            );
          }
          this.direction = t.direction || 'forward';
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null;
          this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        skip(t) {
          let e, n, i;
          do {
            i = this.position;
            ({ done: e, value: n } = this.next());
          } while (!e && t(n));
          if (!e) {
            this.position = i;
          }
        }
        next() {
          if (this.direction == 'forward') {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === n.childCount) {
            return { done: true, value: undefined };
          }
          if (
            n === this._boundaryEndParent &&
            t.offset == this.boundaries.end.offset
          ) {
            return { done: true, value: undefined };
          }
          let i;
          if (n instanceof Ga) {
            if (t.isAtEnd) {
              this.position = od._createAfter(n);
              return this._next();
            }
            i = n.data[t.offset];
          } else {
            i = n.getChild(t.offset);
          }
          if (i instanceof Kl) {
            if (!this.shallow) {
              t = new od(i, 0);
            } else {
              t.offset++;
            }
            this.position = t;
            return this._formatReturnValue(
              'elementStart',
              i,
              e,
              t,
              1
            );
          } else if (i instanceof Ga) {
            if (this.singleCharacters) {
              t = new od(i, 0);
              this.position = t;
              return this._next();
            } else {
              let n = i.data.length;
              let o;
              if (i == this._boundaryEndParent) {
                n = this.boundaries.end.offset;
                o = new $a(i, 0, n);
                t = od._createAfter(o);
              } else {
                o = new $a(i, 0, i.data.length);
                t.offset++;
              }
              this.position = t;
              return this._formatReturnValue('text', o, e, t, n);
            }
          } else if (typeof i == 'string') {
            let i;
            if (this.singleCharacters) {
              i = 1;
            } else {
              const e =
                n === this._boundaryEndParent
                  ? this.boundaries.end.offset
                  : n.data.length;
              i = e - t.offset;
            }
            const o = new $a(n, t.offset, i);
            t.offset += i;
            this.position = t;
            return this._formatReturnValue('text', o, e, t, i);
          } else {
            t = od._createAfter(n);
            this.position = t;
            if (this.ignoreElementEnd) {
              return this._next();
            } else {
              return this._formatReturnValue('elementEnd', n, e, t);
            }
          }
        }
        _previous() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === 0) {
            return { done: true, value: undefined };
          }
          if (
            n == this._boundaryStartParent &&
            t.offset == this.boundaries.start.offset
          ) {
            return { done: true, value: undefined };
          }
          let i;
          if (n instanceof Ga) {
            if (t.isAtStart) {
              this.position = od._createBefore(n);
              return this._previous();
            }
            i = n.data[t.offset - 1];
          } else {
            i = n.getChild(t.offset - 1);
          }
          if (i instanceof Kl) {
            if (!this.shallow) {
              t = new od(i, i.childCount);
              this.position = t;
              if (this.ignoreElementEnd) {
                return this._previous();
              } else {
                return this._formatReturnValue('elementEnd', i, e, t);
              }
            } else {
              t.offset--;
              this.position = t;
              return this._formatReturnValue(
                'elementStart',
                i,
                e,
                t,
                1
              );
            }
          } else if (i instanceof Ga) {
            if (this.singleCharacters) {
              t = new od(i, i.data.length);
              this.position = t;
              return this._previous();
            } else {
              let n = i.data.length;
              let o;
              if (i == this._boundaryStartParent) {
                const e = this.boundaries.start.offset;
                o = new $a(i, e, i.data.length - e);
                n = o.data.length;
                t = od._createBefore(o);
              } else {
                o = new $a(i, 0, i.data.length);
                t.offset--;
              }
              this.position = t;
              return this._formatReturnValue('text', o, e, t, n);
            }
          } else if (typeof i == 'string') {
            let i;
            if (!this.singleCharacters) {
              const e =
                n === this._boundaryStartParent
                  ? this.boundaries.start.offset
                  : 0;
              i = t.offset - e;
            } else {
              i = 1;
            }
            t.offset -= i;
            const o = new $a(n, t.offset, i);
            this.position = t;
            return this._formatReturnValue('text', o, e, t, i);
          } else {
            t = od._createBefore(n);
            this.position = t;
            return this._formatReturnValue(
              'elementStart',
              n,
              e,
              t,
              1
            );
          }
        }
        _formatReturnValue(t, e, n, i, o) {
          if (e instanceof $a) {
            if (
              e.offsetInText + e.data.length ==
              e.textNode.data.length
            ) {
              if (
                this.direction == 'forward' &&
                !(
                  this.boundaries &&
                  this.boundaries.end.isEqual(this.position)
                )
              ) {
                i = od._createAfter(e.textNode);
                this.position = i;
              } else {
                n = od._createAfter(e.textNode);
              }
            }
            if (e.offsetInText === 0) {
              if (
                this.direction == 'backward' &&
                !(
                  this.boundaries &&
                  this.boundaries.start.isEqual(this.position)
                )
              ) {
                i = od._createBefore(e.textNode);
                this.position = i;
              } else {
                n = od._createBefore(e.textNode);
              }
            }
          }
          return {
            done: false,
            value: {
              type: t,
              item: e,
              previousPosition: n,
              nextPosition: i,
              length: o,
            },
          };
        }
      }
      class od extends Va {
        constructor(t, e) {
          super();
          this.parent = t;
          this.offset = e;
        }
        get nodeAfter() {
          if (this.parent.is('$text')) {
            return null;
          }
          return this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          if (this.parent.is('$text')) {
            return null;
          }
          return this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const t = this.parent.is('$text')
            ? this.parent.data.length
            : this.parent.childCount;
          return this.offset === t;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let t = this.parent;
          while (!(t instanceof td)) {
            if (t.parent) {
              t = t.parent;
            } else {
              return null;
            }
          }
          return t;
        }
        getShiftedBy(t) {
          const e = od._createAt(this);
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new id(e);
          n.skip(t);
          return n.position;
        }
        getAncestors() {
          if (this.parent.is('documentFragment')) {
            return [this.parent];
          } else {
            return this.parent.getAncestors({ includeSelf: true });
          }
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let i = 0;
          while (e[i] == n[i] && e[i]) {
            i++;
          }
          return i === 0 ? null : e[i - 1];
        }
        isEqual(t) {
          return this.parent == t.parent && this.offset == t.offset;
        }
        isBefore(t) {
          return this.compareWith(t) == 'before';
        }
        isAfter(t) {
          return this.compareWith(t) == 'after';
        }
        compareWith(t) {
          if (this.root !== t.root) {
            return 'different';
          }
          if (this.isEqual(t)) {
            return 'same';
          }
          const e = this.parent.is('node')
            ? this.parent.getPath()
            : [];
          const n = t.parent.is('node') ? t.parent.getPath() : [];
          e.push(this.offset);
          n.push(t.offset);
          const i = Ha(e, n);
          switch (i) {
            case 'prefix':
              return 'before';
            case 'extension':
              return 'after';
            default:
              return e[i] < n[i] ? 'before' : 'after';
          }
        }
        getWalker(t = {}) {
          t.startPosition = this;
          return new id(t);
        }
        clone() {
          return new od(this.parent, this.offset);
        }
        static _createAt(t, e) {
          if (t instanceof od) {
            return new this(t.parent, t.offset);
          } else {
            const n = t;
            if (e == 'end') {
              e = n.is('$text') ? n.data.length : n.childCount;
            } else if (e == 'before') {
              return this._createBefore(n);
            } else if (e == 'after') {
              return this._createAfter(n);
            } else if (e !== 0 && !e) {
              throw new h('view-createpositionat-offset-required', n);
            }
            return new od(n, e);
          }
        }
        static _createAfter(t) {
          if (t.is('$textProxy')) {
            return new od(t.textNode, t.offsetInText + t.data.length);
          }
          if (!t.parent) {
            throw new h('view-position-after-root', t, { root: t });
          }
          return new od(t.parent, t.index + 1);
        }
        static _createBefore(t) {
          if (t.is('$textProxy')) {
            return new od(t.textNode, t.offsetInText);
          }
          if (!t.parent) {
            throw new h('view-position-before-root', t, { root: t });
          }
          return new od(t.parent, t.index);
        }
      }
      od.prototype.is = function (t) {
        return t === 'position' || t === 'view:position';
      };
      class rd extends Va {
        constructor(t, e = null) {
          super();
          this.start = t.clone();
          this.end = e ? e.clone() : t.clone();
        }
        *[Symbol.iterator]() {
          yield* new id({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let t = this.start.getLastMatchingPosition(sd, {
            direction: 'backward',
          });
          let e = this.end.getLastMatchingPosition(sd);
          if (t.parent.is('$text') && t.isAtStart) {
            t = od._createBefore(t.parent);
          }
          if (e.parent.is('$text') && e.isAtEnd) {
            e = od._createAfter(e.parent);
          }
          return new rd(t, e);
        }
        getTrimmed() {
          let t = this.start.getLastMatchingPosition(sd);
          if (t.isAfter(this.end) || t.isEqual(this.end)) {
            return new rd(t, t);
          }
          let e = this.end.getLastMatchingPosition(sd, {
            direction: 'backward',
          });
          const n = t.nodeAfter;
          const i = e.nodeBefore;
          if (n && n.is('$text')) {
            t = new od(n, 0);
          }
          if (i && i.is('$text')) {
            e = new od(i, i.data.length);
          }
          return new rd(t, e);
        }
        isEqual(t) {
          return (
            this == t ||
            (this.start.isEqual(t.start) && this.end.isEqual(t.end))
          );
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start));
          const i =
            this.containsPosition(t.end) ||
            (e && this.end.isEqual(t.end));
          return n && i;
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new rd(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new rd(t.end, this.end));
            }
          } else {
            e.push(this.clone());
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new rd(e, n);
          }
          return null;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new id(t);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          let t = this.start.nodeAfter;
          let e = this.end.nodeBefore;
          if (
            this.start.parent.is('$text') &&
            this.start.isAtEnd &&
            this.start.parent.nextSibling
          ) {
            t = this.start.parent.nextSibling;
          }
          if (
            this.end.parent.is('$text') &&
            this.end.isAtStart &&
            this.end.parent.previousSibling
          ) {
            e = this.end.parent.previousSibling;
          }
          if (t && t.is('element') && t === e) {
            return t;
          }
          return null;
        }
        clone() {
          return new rd(this.start, this.end);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new id(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new id(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        isIntersecting(t) {
          return (
            this.start.isBefore(t.end) && this.end.isAfter(t.start)
          );
        }
        static _createFromParentsAndOffsets(t, e, n, i) {
          return new this(new od(t, e), new od(n, i));
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const i = t.getShiftedBy(e);
          return e > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(t) {
          return this._createFromParentsAndOffsets(
            t,
            0,
            t,
            t.childCount
          );
        }
        static _createOn(t) {
          const e = t.is('$textProxy') ? t.offsetSize : 1;
          return this._createFromPositionAndShift(
            od._createBefore(t),
            e
          );
        }
      }
      rd.prototype.is = function (t) {
        return t === 'range' || t === 'view:range';
      };
      function sd(t) {
        if (t.item.is('attributeElement') || t.item.is('uiElement')) {
          return true;
        }
        return false;
      }
      function ad(t) {
        let e = 0;
        for (const n of t) {
          e++;
        }
        return e;
      }
      class cd extends C(Va) {
        constructor(...t) {
          super();
          this._ranges = [];
          this._lastRangeBackward = false;
          this._isFake = false;
          this._fakeSelectionLabel = '';
          if (t.length) {
            this.setTo(...t);
          }
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.end : t.start;
          return e.clone();
        }
        get focus() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.start : t.end;
          return e.clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          if (this.anchor) {
            return this.anchor.editableElement;
          }
          return null;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield t.clone();
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        isEqual(t) {
          if (this.isFake != t.isFake) {
            return false;
          }
          if (
            this.isFake &&
            this.fakeSelectionLabel != t.fakeSelectionLabel
          ) {
            return false;
          }
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (
            !this.anchor.isEqual(t.anchor) ||
            !this.focus.isEqual(t.focus)
          ) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const i of t._ranges) {
              if (e.isEqual(i)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        isSimilar(t) {
          if (this.isBackward != t.isBackward) {
            return false;
          }
          const e = ad(this.getRanges());
          const n = ad(t.getRanges());
          if (e != n) {
            return false;
          }
          if (e == 0) {
            return true;
          }
          for (let e of this.getRanges()) {
            e = e.getTrimmed();
            let n = false;
            for (let i of t.getRanges()) {
              i = i.getTrimmed();
              if (e.start.isEqual(i.start) && e.end.isEqual(i.end)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        setTo(...t) {
          let [e, n, i] = t;
          if (typeof n == 'object') {
            i = n;
            n = undefined;
          }
          if (e === null) {
            this._setRanges([]);
            this._setFakeOptions(i);
          } else if (e instanceof cd || e instanceof ld) {
            this._setRanges(e.getRanges(), e.isBackward);
            this._setFakeOptions({
              fake: e.isFake,
              label: e.fakeSelectionLabel,
            });
          } else if (e instanceof rd) {
            this._setRanges([e], i && i.backward);
            this._setFakeOptions(i);
          } else if (e instanceof od) {
            this._setRanges([new rd(e)]);
            this._setFakeOptions(i);
          } else if (e instanceof Ua) {
            const t = !!i && !!i.backward;
            let o;
            if (n === undefined) {
              throw new h(
                'view-selection-setto-required-second-parameter',
                this
              );
            } else if (n == 'in') {
              o = rd._createIn(e);
            } else if (n == 'on') {
              o = rd._createOn(e);
            } else {
              o = new rd(od._createAt(e, n));
            }
            this._setRanges([o], t);
            this._setFakeOptions(i);
          } else if (Ca(e)) {
            this._setRanges(e, i && i.backward);
            this._setFakeOptions(i);
          } else {
            throw new h('view-selection-setto-not-selectable', this);
          }
          this.fire('change');
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new h('view-selection-setfocus-no-ranges', this);
          }
          const n = od._createAt(t, e);
          if (n.compareWith(this.focus) == 'same') {
            return;
          }
          const i = this.anchor;
          this._ranges.pop();
          if (n.compareWith(i) == 'before') {
            this._addRange(new rd(n, i), true);
          } else {
            this._addRange(new rd(i, n));
          }
          this.fire('change');
        }
        _setRanges(t, e = false) {
          t = Array.from(t);
          this._ranges = [];
          for (const e of t) {
            this._addRange(e);
          }
          this._lastRangeBackward = !!e;
        }
        _setFakeOptions(t = {}) {
          this._isFake = !!t.fake;
          this._fakeSelectionLabel = t.fake ? t.label || '' : '';
        }
        _addRange(t, e = false) {
          if (!(t instanceof rd)) {
            throw new h('view-selection-add-range-not-range', this);
          }
          this._pushRange(t);
          this._lastRangeBackward = !!e;
        }
        _pushRange(t) {
          for (const e of this._ranges) {
            if (t.isIntersecting(e)) {
              throw new h('view-selection-range-intersects', this, {
                addedRange: t,
                intersectingRange: e,
              });
            }
          }
          this._ranges.push(new rd(t.start, t.end));
        }
      }
      cd.prototype.is = function (t) {
        return t === 'selection' || t === 'view:selection';
      };
      class ld extends C(Va) {
        constructor(...t) {
          super();
          this._selection = new cd();
          this._selection.delegate('change').to(this);
          if (t.length) {
            this._selection.setTo(...t);
          }
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(t) {
          return this._selection.isEqual(t);
        }
        isSimilar(t) {
          return this._selection.isSimilar(t);
        }
        _setTo(...t) {
          this._selection.setTo(...t);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
      }
      ld.prototype.is = function (t) {
        return (
          t === 'selection' ||
          t == 'documentSelection' ||
          t == 'view:selection' ||
          t == 'view:documentSelection'
        );
      };
      class dd extends o {
        constructor(t, e, n) {
          super(t, e);
          this.startRange = n;
          this._eventPhase = 'none';
          this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const hd = Symbol('bubbling contexts');
      function ud(t) {
        class e extends t {
          fire(t, ...e) {
            try {
              const n = t instanceof o ? t : new o(this, t);
              const i = pd(this);
              if (!i.size) {
                return;
              }
              fd(n, 'capturing', this);
              if (gd(i, '$capture', n, ...e)) {
                return n.return;
              }
              const r =
                n.startRange || this.selection.getFirstRange();
              const s = r ? r.getContainedElement() : null;
              const a = s ? Boolean(md(i, s)) : false;
              let c = s || kd(r);
              fd(n, 'atTarget', c);
              if (!a) {
                if (gd(i, '$text', n, ...e)) {
                  return n.return;
                }
                fd(n, 'bubbling', c);
              }
              while (c) {
                if (c.is('rootElement')) {
                  if (gd(i, '$root', n, ...e)) {
                    return n.return;
                  }
                } else if (c.is('element')) {
                  if (gd(i, c.name, n, ...e)) {
                    return n.return;
                  }
                }
                if (gd(i, c, n, ...e)) {
                  return n.return;
                }
                c = c.parent;
                fd(n, 'bubbling', c);
              }
              fd(n, 'bubbling', this);
              gd(i, '$document', n, ...e);
              return n.return;
            } catch (t) {
              h.rethrowUnexpectedError(t, this);
            }
          }
          _addEventListener(t, e, n) {
            const i = Ea(n.context || '$document');
            const o = pd(this);
            for (const r of i) {
              let i = o.get(r);
              if (!i) {
                i = new y();
                o.set(r, i);
              }
              this.listenTo(i, t, e, n);
            }
          }
          _removeEventListener(t, e) {
            const n = pd(this);
            for (const i of n.values()) {
              this.stopListening(i, t, e);
            }
          }
        }
        return e;
      }
      {
        const t = ud(Object);
        ['fire', '_addEventListener', '_removeEventListener'].forEach(
          (e) => {
            ud[e] = t.prototype[e];
          }
        );
      }
      function fd(t, e, n) {
        if (t instanceof dd) {
          t._eventPhase = e;
          t._currentTarget = n;
        }
      }
      function gd(t, e, n, ...i) {
        const o = typeof e == 'string' ? t.get(e) : md(t, e);
        if (!o) {
          return false;
        }
        o.fire(n, ...i);
        return n.stop.called;
      }
      function md(t, e) {
        for (const [n, i] of t) {
          if (typeof n == 'function' && n(e)) {
            return i;
          }
        }
        return null;
      }
      function pd(t) {
        if (!t[hd]) {
          t[hd] = new Map();
        }
        return t[hd];
      }
      function kd(t) {
        if (!t) {
          return null;
        }
        const e = t.start.parent;
        const n = t.end.parent;
        const i = e.getPath();
        const o = n.getPath();
        return i.length > o.length ? e : n;
      }
      class bd extends ud(W) {
        constructor(t) {
          super();
          this.selection = new ld();
          this.roots = new ya({ idProperty: 'rootName' });
          this.stylesProcessor = t;
          this.set('isReadOnly', false);
          this.set('isFocused', false);
          this.set('isSelecting', false);
          this.set('isComposing', false);
          this._postFixers = new Set();
        }
        getRoot(t = 'main') {
          return this.roots.get(t);
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        destroy() {
          this.roots.map((t) => t.destroy());
          this.stopListening();
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      const wd = 10;
      class _d extends Kl {
        constructor(...t) {
          super(...t);
          this.getFillerOffset = vd;
          this._priority = wd;
          this._id = null;
          this._clonesGroup = null;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null) {
            throw new h(
              'attribute-element-get-elements-with-same-id-no-id',
              this
            );
          }
          return new Set(this._clonesGroup);
        }
        isSimilar(t) {
          if (this.id !== null || t.id !== null) {
            return this.id === t.id;
          }
          return super.isSimilar(t) && this.priority == t.priority;
        }
        _clone(t = false) {
          const e = super._clone(t);
          e._priority = this._priority;
          e._id = this._id;
          return e;
        }
      }
      _d.DEFAULT_PRIORITY = wd;
      _d.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'attributeElement' ||
            t === 'view:attributeElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'attributeElement' ||
              t === 'view:attributeElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function vd() {
        if (Ad(this)) {
          return null;
        }
        let t = this.parent;
        while (t && t.is('attributeElement')) {
          if (Ad(t) > 1) {
            return null;
          }
          t = t.parent;
        }
        if (!t || Ad(t) > 1) {
          return null;
        }
        return this.childCount;
      }
      function Ad(t) {
        return Array.from(t.getChildren()).filter(
          (t) => !t.is('uiElement')
        ).length;
      }
      class Cd extends Kl {
        constructor(t, e, n, i) {
          super(t, e, n, i);
          this.getFillerOffset = yd;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ua || Array.from(e).length > 0)) {
            throw new h('view-emptyelement-cannot-add', [this, e]);
          }
          return 0;
        }
      }
      Cd.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'emptyElement' ||
            t === 'view:emptyElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'emptyElement' ||
              t === 'view:emptyElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function yd() {
        return null;
      }
      function xd() {
        try {
          return navigator.userAgent.toLowerCase();
        } catch (t) {
          return '';
        }
      }
      const Ed = xd();
      const Dd = {
        isMac: Td(Ed),
        isWindows: Bd(Ed),
        isGecko: Pd(Ed),
        isSafari: Id(Ed),
        isiOS: Rd(Ed),
        isAndroid: zd(Ed),
        isBlink: Od(Ed),
        features: { isRegExpUnicodePropertySupported: Fd() },
      };
      const Sd = Dd;
      function Td(t) {
        return t.indexOf('macintosh') > -1;
      }
      function Bd(t) {
        return t.indexOf('windows') > -1;
      }
      function Pd(t) {
        return !!t.match(/gecko\/\d+/);
      }
      function Id(t) {
        return (
          t.indexOf(' applewebkit/') > -1 &&
          t.indexOf('chrome') === -1
        );
      }
      function Rd(t) {
        return (
          !!t.match(/iphone|ipad/i) ||
          (Td(t) && navigator.maxTouchPoints > 0)
        );
      }
      function zd(t) {
        return t.indexOf('android') > -1;
      }
      function Od(t) {
        return t.indexOf('chrome/') > -1 && t.indexOf('edge/') < 0;
      }
      function Fd() {
        let t = false;
        try {
          t = 'ć'.search(new RegExp('[\\p{L}]', 'u')) === 0;
        } catch (t) {}
        return t;
      }
      const Nd = { ctrl: '⌃', cmd: '⌘', alt: '⌥', shift: '⇧' };
      const Md = { ctrl: 'Ctrl+', alt: 'Alt+', shift: 'Shift+' };
      const Ld = Kd();
      const Vd = Object.fromEntries(
        Object.entries(Ld).map(([t, e]) => [
          e,
          t.charAt(0).toUpperCase() + t.slice(1),
        ])
      );
      function Hd(t) {
        let e;
        if (typeof t == 'string') {
          e = Ld[t.toLowerCase()];
          if (!e) {
            throw new h('keyboard-unknown-key', null, { key: t });
          }
        } else {
          e =
            t.keyCode +
            (t.altKey ? Ld.alt : 0) +
            (t.ctrlKey ? Ld.ctrl : 0) +
            (t.shiftKey ? Ld.shift : 0) +
            (t.metaKey ? Ld.cmd : 0);
        }
        return e;
      }
      function jd(t) {
        if (typeof t == 'string') {
          t = Zd(t);
        }
        return t
          .map((t) => (typeof t == 'string' ? Gd(t) : t))
          .reduce((t, e) => e + t, 0);
      }
      function qd(t) {
        let e = jd(t);
        const n = Object.entries(Sd.isMac ? Nd : Md);
        const i = n.reduce((t, [n, i]) => {
          if ((e & Ld[n]) != 0) {
            e &= ~Ld[n];
            t += i;
          }
          return t;
        }, '');
        return i + (e ? Vd[e] : '');
      }
      function Wd(t) {
        return (
          t == Ld.arrowright ||
          t == Ld.arrowleft ||
          t == Ld.arrowup ||
          t == Ld.arrowdown
        );
      }
      function Ud(t, e) {
        const n = e === 'ltr';
        switch (t) {
          case Ld.arrowleft:
            return n ? 'left' : 'right';
          case Ld.arrowright:
            return n ? 'right' : 'left';
          case Ld.arrowup:
            return 'up';
          case Ld.arrowdown:
            return 'down';
        }
      }
      function Gd(t) {
        if (t.endsWith('!')) {
          return Hd(t.slice(0, -1));
        }
        const e = Hd(t);
        return Sd.isMac && e == Ld.ctrl ? Ld.cmd : e;
      }
      function $d(t, e) {
        const n = Ud(t, e);
        return n === 'down' || n === 'right';
      }
      function Kd() {
        const t = {
          arrowleft: 37,
          arrowup: 38,
          arrowright: 39,
          arrowdown: 40,
          backspace: 8,
          delete: 46,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          ctrl: 1114112,
          shift: 2228224,
          alt: 4456448,
          cmd: 8912896,
        };
        for (let e = 65; e <= 90; e++) {
          const n = String.fromCharCode(e);
          t[n.toLowerCase()] = e;
        }
        for (let e = 48; e <= 57; e++) {
          t[e - 48] = e;
        }
        for (let e = 112; e <= 123; e++) {
          t['f' + (e - 111)] = e;
        }
        for (const e of "`-=[];',./\\") {
          t[e] = e.charCodeAt(0);
        }
        return t;
      }
      function Zd(t) {
        return t.split('+').map((t) => t.trim());
      }
      class Jd extends Kl {
        constructor(...t) {
          super(...t);
          this.getFillerOffset = Qd;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ua || Array.from(e).length > 0)) {
            throw new h('view-uielement-cannot-add', [this, e]);
          }
          return 0;
        }
        render(t, e) {
          return this.toDomElement(t);
        }
        toDomElement(t) {
          const e = t.createElement(this.name);
          for (const t of this.getAttributeKeys()) {
            e.setAttribute(t, this.getAttribute(t));
          }
          return e;
        }
      }
      Jd.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'uiElement' ||
            t === 'view:uiElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'uiElement' ||
              t === 'view:uiElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function Yd(t) {
        t.document.on(
          'arrowKey',
          (e, n) => Xd(e, n, t.domConverter),
          { priority: 'low' }
        );
      }
      function Qd() {
        return null;
      }
      function Xd(t, e, n) {
        if (e.keyCode == Ld.arrowright) {
          const t =
            e.domTarget.ownerDocument.defaultView.getSelection();
          const i = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
          if (i || e.shiftKey) {
            const e = t.focusNode;
            const o = t.focusOffset;
            const r = n.domPositionToView(e, o);
            if (r === null) {
              return;
            }
            let s = false;
            const a = r.getLastMatchingPosition((t) => {
              if (t.item.is('uiElement')) {
                s = true;
              }
              if (
                t.item.is('uiElement') ||
                t.item.is('attributeElement')
              ) {
                return true;
              }
              return false;
            });
            if (s) {
              const e = n.viewPositionToDom(a);
              if (i) {
                t.collapse(e.parent, e.offset);
              } else {
                t.extend(e.parent, e.offset);
              }
            }
          }
        }
      }
      class th extends Kl {
        constructor(...t) {
          super(...t);
          this.getFillerOffset = eh;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ua || Array.from(e).length > 0)) {
            throw new h('view-rawelement-cannot-add', [this, e]);
          }
          return 0;
        }
        render() {}
      }
      th.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rawElement' ||
            t === 'view:rawElement' ||
            t === this.name ||
            t === 'view:' + this.name ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'rawElement' ||
              t === 'view:rawElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function eh() {
        return null;
      }
      class nh extends C(Va) {
        constructor(t, e) {
          super();
          this.document = t;
          this._children = [];
          if (e) {
            this._insertChild(0, e);
          }
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(t, e) {
          this._fireChange('children', this);
          let n = 0;
          const i = ih(this.document, e);
          for (const e of i) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange('children', this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _fireChange(t, e) {
          this.fire('change:' + t, e);
        }
      }
      nh.prototype.is = function (t) {
        return (
          t === 'documentFragment' || t === 'view:documentFragment'
        );
      };
      function ih(t, e) {
        if (typeof e == 'string') {
          return [new Ga(t, e)];
        }
        if (!Ca(e)) {
          e = [e];
        }
        return Array.from(e).map((e) => {
          if (typeof e == 'string') {
            return new Ga(t, e);
          }
          if (e instanceof $a) {
            return new Ga(t, e.data);
          }
          return e;
        });
      }
      class oh {
        constructor(t) {
          this.document = t;
          this._cloneGroups = new Map();
          this._slotFactory = null;
        }
        setSelection(...t) {
          this.document.selection._setTo(...t);
        }
        setSelectionFocus(...t) {
          this.document.selection._setFocus(...t);
        }
        createDocumentFragment(t) {
          return new nh(this.document, t);
        }
        createText(t) {
          return new Ga(this.document, t);
        }
        createAttributeElement(t, e, n = {}) {
          const i = new _d(this.document, t, e);
          if (typeof n.priority === 'number') {
            i._priority = n.priority;
          }
          if (n.id) {
            i._id = n.id;
          }
          if (n.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(
              ...n.renderUnsafeAttributes
            );
          }
          return i;
        }
        createContainerElement(t, e, n = {}, i = {}) {
          let o = null;
          if (jt(n)) {
            i = n;
          } else {
            o = n;
          }
          const r = new Ql(this.document, t, e, o);
          if (i.renderUnsafeAttributes) {
            r._unsafeAttributesToRender.push(
              ...i.renderUnsafeAttributes
            );
          }
          return r;
        }
        createEditableElement(t, e, n = {}) {
          const i = new td(this.document, t, e);
          if (n.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(
              ...n.renderUnsafeAttributes
            );
          }
          return i;
        }
        createEmptyElement(t, e, n = {}) {
          const i = new Cd(this.document, t, e);
          if (n.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(
              ...n.renderUnsafeAttributes
            );
          }
          return i;
        }
        createUIElement(t, e, n) {
          const i = new Jd(this.document, t, e);
          if (n) {
            i.render = n;
          }
          return i;
        }
        createRawElement(t, e, n, i = {}) {
          const o = new th(this.document, t, e);
          if (n) {
            o.render = n;
          }
          if (i.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(
              ...i.renderUnsafeAttributes
            );
          }
          return o;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (jt(t) && n === undefined) {
            e._setStyle(t);
          } else {
            n._setStyle(t, e);
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        breakAttributes(t) {
          if (t instanceof od) {
            return this._breakAttributes(t);
          } else {
            return this._breakAttributesRange(t);
          }
        }
        breakContainer(t) {
          const e = t.parent;
          if (!e.is('containerElement')) {
            throw new h(
              'view-writer-break-non-container-element',
              this.document
            );
          }
          if (!e.parent) {
            throw new h('view-writer-break-root', this.document);
          }
          if (t.isAtStart) {
            return od._createBefore(e);
          } else if (!t.isAtEnd) {
            const n = e._clone(false);
            this.insert(od._createAfter(e), n);
            const i = new rd(t, od._createAt(e, 'end'));
            const o = new od(n, 0);
            this.move(i, o);
          }
          return od._createAfter(e);
        }
        mergeAttributes(t) {
          const e = t.offset;
          const n = t.parent;
          if (n.is('$text')) {
            return t;
          }
          if (n.is('attributeElement') && n.childCount === 0) {
            const t = n.parent;
            const e = n.index;
            n._remove();
            this._removeFromClonedElementsGroup(n);
            return this.mergeAttributes(new od(t, e));
          }
          const i = n.getChild(e - 1);
          const o = n.getChild(e);
          if (!i || !o) {
            return t;
          }
          if (i.is('$text') && o.is('$text')) {
            return dh(i, o);
          } else if (
            i.is('attributeElement') &&
            o.is('attributeElement') &&
            i.isSimilar(o)
          ) {
            const t = i.childCount;
            i._appendChild(o.getChildren());
            o._remove();
            this._removeFromClonedElementsGroup(o);
            return this.mergeAttributes(new od(i, t));
          }
          return t;
        }
        mergeContainers(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (
            !e ||
            !n ||
            !e.is('containerElement') ||
            !n.is('containerElement')
          ) {
            throw new h(
              'view-writer-merge-containers-invalid-position',
              this.document
            );
          }
          const i = e.getChild(e.childCount - 1);
          const o =
            i instanceof Ga
              ? od._createAt(i, 'end')
              : od._createAt(e, 'end');
          this.move(rd._createIn(n), od._createAt(e, 'end'));
          this.remove(rd._createOn(n));
          return o;
        }
        insert(t, e) {
          e = Ca(e) ? [...e] : [e];
          uh(e, this.document);
          const n = e.reduce((t, e) => {
            const n = t[t.length - 1];
            const i = !e.is('uiElement');
            if (!n || n.breakAttributes != i) {
              t.push({ breakAttributes: i, nodes: [e] });
            } else {
              n.nodes.push(e);
            }
            return t;
          }, []);
          let i = null;
          let o = t;
          for (const { nodes: t, breakAttributes: e } of n) {
            const n = this._insertNodes(o, t, e);
            if (!i) {
              i = n.start;
            }
            o = n.end;
          }
          if (!i) {
            return new rd(t);
          }
          return new rd(i, o);
        }
        remove(t) {
          const e = t instanceof rd ? t : rd._createOn(t);
          gh(e, this.document);
          if (e.isCollapsed) {
            return new nh(this.document);
          }
          const { start: n, end: i } = this._breakAttributesRange(
            e,
            true
          );
          const o = n.parent;
          const r = i.offset - n.offset;
          const s = o._removeChildren(n.offset, r);
          for (const t of s) {
            this._removeFromClonedElementsGroup(t);
          }
          const a = this.mergeAttributes(n);
          e.start = a;
          e.end = a.clone();
          return new nh(this.document, s);
        }
        clear(t, e) {
          gh(t, this.document);
          const n = t.getWalker({
            direction: 'backward',
            ignoreElementEnd: true,
          });
          for (const i of n) {
            const n = i.item;
            let o;
            if (n.is('element') && e.isSimilar(n)) {
              o = rd._createOn(n);
            } else if (
              !i.nextPosition.isAfter(t.start) &&
              n.is('$textProxy')
            ) {
              const t = n
                .getAncestors()
                .find((t) => t.is('element') && e.isSimilar(t));
              if (t) {
                o = rd._createIn(t);
              }
            }
            if (o) {
              if (o.end.isAfter(t.end)) {
                o.end = t.end;
              }
              if (o.start.isBefore(t.start)) {
                o.start = t.start;
              }
              this.remove(o);
            }
          }
        }
        move(t, e) {
          let n;
          if (e.isAfter(t.end)) {
            e = this._breakAttributes(e, true);
            const i = e.parent;
            const o = i.childCount;
            t = this._breakAttributesRange(t, true);
            n = this.remove(t);
            e.offset += i.childCount - o;
          } else {
            n = this.remove(t);
          }
          return this.insert(e, n);
        }
        wrap(t, e) {
          if (!(e instanceof _d)) {
            throw new h(
              'view-writer-wrap-invalid-attribute',
              this.document
            );
          }
          gh(t, this.document);
          if (!t.isCollapsed) {
            return this._wrapRange(t, e);
          } else {
            let n = t.start;
            if (n.parent.is('element') && !rh(n.parent)) {
              n = n.getLastMatchingPosition((t) =>
                t.item.is('uiElement')
              );
            }
            n = this._wrapPosition(n, e);
            const i = this.document.selection;
            if (
              i.isCollapsed &&
              i.getFirstPosition().isEqual(t.start)
            ) {
              this.setSelection(n);
            }
            return new rd(n);
          }
        }
        unwrap(t, e) {
          if (!(e instanceof _d)) {
            throw new h(
              'view-writer-unwrap-invalid-attribute',
              this.document
            );
          }
          gh(t, this.document);
          if (t.isCollapsed) {
            return t;
          }
          const { start: n, end: i } = this._breakAttributesRange(
            t,
            true
          );
          const o = n.parent;
          const r = this._unwrapChildren(o, n.offset, i.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new rd(s, a);
        }
        rename(t, e) {
          const n = new Ql(this.document, t, e.getAttributes());
          this.insert(od._createAfter(e), n);
          this.move(rd._createIn(e), od._createAt(n, 0));
          this.remove(rd._createOn(e));
          return n;
        }
        clearClonedElementsGroup(t) {
          this._cloneGroups.delete(t);
        }
        createPositionAt(t, e) {
          return od._createAt(t, e);
        }
        createPositionAfter(t) {
          return od._createAfter(t);
        }
        createPositionBefore(t) {
          return od._createBefore(t);
        }
        createRange(...t) {
          return new rd(...t);
        }
        createRangeOn(t) {
          return rd._createOn(t);
        }
        createRangeIn(t) {
          return rd._createIn(t);
        }
        createSelection(...t) {
          return new cd(...t);
        }
        createSlot(t) {
          if (!this._slotFactory) {
            throw new h(
              'view-writer-invalid-create-slot-context',
              this.document
            );
          }
          return this._slotFactory(this, t);
        }
        _registerSlotFactory(t) {
          this._slotFactory = t;
        }
        _clearSlotFactory() {
          this._slotFactory = null;
        }
        _insertNodes(t, e, n) {
          let i;
          if (n) {
            i = sh(t);
          } else {
            i = t.parent.is('$text') ? t.parent.parent : t.parent;
          }
          if (!i) {
            throw new h(
              'view-writer-invalid-position-container',
              this.document
            );
          }
          let o;
          if (n) {
            o = this._breakAttributes(t, true);
          } else {
            o = t.parent.is('$text') ? lh(t) : t;
          }
          const r = i._insertChild(o.offset, e);
          for (const t of e) {
            this._addToClonedElementsGroup(t);
          }
          const s = o.getShiftedBy(r);
          const a = this.mergeAttributes(o);
          if (!a.isEqual(o)) {
            s.offset--;
          }
          const c = this.mergeAttributes(s);
          return new rd(a, c);
        }
        _wrapChildren(t, e, n, i) {
          let o = e;
          const r = [];
          while (o < n) {
            const e = t.getChild(o);
            const n = e.is('$text');
            const s = e.is('attributeElement');
            if (s && this._wrapAttributeElement(i, e)) {
              r.push(new od(t, o));
            } else if (n || !s || ah(i, e)) {
              const n = i._clone();
              e._remove();
              n._appendChild(e);
              t._insertChild(o, n);
              this._addToClonedElementsGroup(n);
              r.push(new od(t, o));
            } else {
              this._wrapChildren(e, 0, e.childCount, i);
            }
            o++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e) {
              continue;
            }
            const i = this.mergeAttributes(t);
            if (!i.isEqual(t)) {
              s++;
              n--;
            }
          }
          return rd._createFromParentsAndOffsets(t, e, t, n);
        }
        _unwrapChildren(t, e, n, i) {
          let o = e;
          const r = [];
          while (o < n) {
            const e = t.getChild(o);
            if (!e.is('attributeElement')) {
              o++;
              continue;
            }
            if (e.isSimilar(i)) {
              const i = e.getChildren();
              const s = e.childCount;
              e._remove();
              t._insertChild(o, i);
              this._removeFromClonedElementsGroup(e);
              r.push(new od(t, o), new od(t, o + s));
              o += s;
              n += s - 1;
              continue;
            }
            if (this._unwrapAttributeElement(i, e)) {
              r.push(new od(t, o), new od(t, o + 1));
              o++;
              continue;
            }
            this._unwrapChildren(e, 0, e.childCount, i);
            o++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e || t.offset == n) {
              continue;
            }
            const i = this.mergeAttributes(t);
            if (!i.isEqual(t)) {
              s++;
              n--;
            }
          }
          return rd._createFromParentsAndOffsets(t, e, t, n);
        }
        _wrapRange(t, e) {
          const { start: n, end: i } = this._breakAttributesRange(
            t,
            true
          );
          const o = n.parent;
          const r = this._wrapChildren(o, n.offset, i.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new rd(s, a);
        }
        _wrapPosition(t, e) {
          if (e.isSimilar(t.parent)) {
            return ch(t.clone());
          }
          if (t.parent.is('$text')) {
            t = lh(t);
          }
          const n = this.createAttributeElement(
            '_wrapPosition-fake-element'
          );
          n._priority = Number.POSITIVE_INFINITY;
          n.isSimilar = () => false;
          t.parent._insertChild(t.offset, n);
          const i = new rd(t, t.getShiftedBy(1));
          this.wrap(i, e);
          const o = new od(n.parent, n.index);
          n._remove();
          const r = o.nodeBefore;
          const s = o.nodeAfter;
          if (r instanceof Ga && s instanceof Ga) {
            return dh(r, s);
          }
          return ch(o);
        }
        _wrapAttributeElement(t, e) {
          if (!mh(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue;
            }
            if (
              e.hasAttribute(n) &&
              e.getAttribute(n) !== t.getAttribute(n)
            ) {
              return false;
            }
          }
          for (const n of t.getStyleNames()) {
            if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue;
            }
            if (!e.hasAttribute(n)) {
              this.setAttribute(n, t.getAttribute(n), e);
            }
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n)) {
              this.setStyle(n, t.getStyle(n), e);
            }
          }
          for (const n of t.getClassNames()) {
            if (!e.hasClass(n)) {
              this.addClass(n, e);
            }
          }
          return true;
        }
        _unwrapAttributeElement(t, e) {
          if (!mh(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue;
            }
            if (
              !e.hasAttribute(n) ||
              e.getAttribute(n) !== t.getAttribute(n)
            ) {
              return false;
            }
          }
          if (!e.hasClass(...t.getClassNames())) {
            return false;
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue;
            }
            this.removeAttribute(n, e);
          }
          this.removeClass(Array.from(t.getClassNames()), e);
          this.removeStyle(Array.from(t.getStyleNames()), e);
          return true;
        }
        _breakAttributesRange(t, e = false) {
          const n = t.start;
          const i = t.end;
          gh(t, this.document);
          if (t.isCollapsed) {
            const n = this._breakAttributes(t.start, e);
            return new rd(n, n);
          }
          const o = this._breakAttributes(i, e);
          const r = o.parent.childCount;
          const s = this._breakAttributes(n, e);
          o.offset += o.parent.childCount - r;
          return new rd(s, o);
        }
        _breakAttributes(t, e = false) {
          const n = t.offset;
          const i = t.parent;
          if (t.parent.is('emptyElement')) {
            throw new h(
              'view-writer-cannot-break-empty-element',
              this.document
            );
          }
          if (t.parent.is('uiElement')) {
            throw new h(
              'view-writer-cannot-break-ui-element',
              this.document
            );
          }
          if (t.parent.is('rawElement')) {
            throw new h(
              'view-writer-cannot-break-raw-element',
              this.document
            );
          }
          if (!e && i.is('$text') && fh(i.parent)) {
            return t.clone();
          }
          if (fh(i)) {
            return t.clone();
          }
          if (i.is('$text')) {
            return this._breakAttributes(lh(t), e);
          }
          const o = i.childCount;
          if (n == o) {
            const t = new od(i.parent, i.index + 1);
            return this._breakAttributes(t, e);
          } else {
            if (n === 0) {
              const t = new od(i.parent, i.index);
              return this._breakAttributes(t, e);
            } else {
              const t = i.index + 1;
              const o = i._clone();
              i.parent._insertChild(t, o);
              this._addToClonedElementsGroup(o);
              const r = i.childCount - n;
              const s = i._removeChildren(n, r);
              o._appendChild(s);
              const a = new od(i.parent, t);
              return this._breakAttributes(a, e);
            }
          }
        }
        _addToClonedElementsGroup(t) {
          if (!t.root.is('rootElement')) {
            return;
          }
          if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._addToClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          let n = this._cloneGroups.get(e);
          if (!n) {
            n = new Set();
            this._cloneGroups.set(e, n);
          }
          n.add(t);
          t._clonesGroup = n;
        }
        _removeFromClonedElementsGroup(t) {
          if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._removeFromClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          const n = this._cloneGroups.get(e);
          if (!n) {
            return;
          }
          n.delete(t);
        }
      }
      function rh(t) {
        return Array.from(t.getChildren()).some(
          (t) => !t.is('uiElement')
        );
      }
      function sh(t) {
        let e = t.parent;
        while (!fh(e)) {
          if (!e) {
            return undefined;
          }
          e = e.parent;
        }
        return e;
      }
      function ah(t, e) {
        if (t.priority < e.priority) {
          return true;
        } else if (t.priority > e.priority) {
          return false;
        }
        return t.getIdentity() < e.getIdentity();
      }
      function ch(t) {
        const e = t.nodeBefore;
        if (e && e.is('$text')) {
          return new od(e, e.data.length);
        }
        const n = t.nodeAfter;
        if (n && n.is('$text')) {
          return new od(n, 0);
        }
        return t;
      }
      function lh(t) {
        if (t.offset == t.parent.data.length) {
          return new od(t.parent.parent, t.parent.index + 1);
        }
        if (t.offset === 0) {
          return new od(t.parent.parent, t.parent.index);
        }
        const e = t.parent.data.slice(t.offset);
        t.parent._data = t.parent.data.slice(0, t.offset);
        t.parent.parent._insertChild(
          t.parent.index + 1,
          new Ga(t.root.document, e)
        );
        return new od(t.parent.parent, t.parent.index + 1);
      }
      function dh(t, e) {
        const n = t.data.length;
        t._data += e.data;
        e._remove();
        return new od(t, n);
      }
      const hh = [Ga, _d, Ql, Cd, th, Jd];
      function uh(t, e) {
        for (const n of t) {
          if (!hh.some((t) => n instanceof t)) {
            throw new h('view-writer-insert-invalid-node-type', e);
          }
          if (!n.is('$text')) {
            uh(n.getChildren(), e);
          }
        }
      }
      function fh(t) {
        return (
          t && (t.is('containerElement') || t.is('documentFragment'))
        );
      }
      function gh(t, e) {
        const n = sh(t.start);
        const i = sh(t.end);
        if (!n || !i || n !== i) {
          throw new h('view-writer-invalid-range-container', e);
        }
      }
      function mh(t, e) {
        return t.id === null && e.id === null;
      }
      function ph(t) {
        return Object.prototype.toString.call(t) == '[object Text]';
      }
      const kh = (t) => t.createTextNode(' ');
      const bh = (t) => {
        const e = t.createElement('span');
        e.dataset.ckeFiller = 'true';
        e.innerText = ' ';
        return e;
      };
      const wh = (t) => {
        const e = t.createElement('br');
        e.dataset.ckeFiller = 'true';
        return e;
      };
      const _h = 7;
      const vh = '⁠'.repeat(_h);
      function Ah(t) {
        return ph(t) && t.data.substr(0, _h) === vh;
      }
      function Ch(t) {
        return t.data.length == _h && Ah(t);
      }
      function yh(t) {
        if (Ah(t)) {
          return t.data.slice(_h);
        } else {
          return t.data;
        }
      }
      function xh(t) {
        t.document.on('arrowKey', Eh, { priority: 'low' });
      }
      function Eh(t, e) {
        if (e.keyCode == Ld.arrowleft) {
          const t =
            e.domTarget.ownerDocument.defaultView.getSelection();
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const e = t.getRangeAt(0).startContainer;
            const n = t.getRangeAt(0).startOffset;
            if (Ah(e) && n <= _h) {
              t.collapse(e, 0);
            }
          }
        }
      }
      function Dh(t, e, n, i = false) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const o = Array.isArray(t)
          ? t
          : Array.prototype.slice.call(t);
        const r = Array.isArray(e)
          ? e
          : Array.prototype.slice.call(e);
        const s = Sh(o, r, n);
        return i ? Ih(s, r.length) : Ph(r, s);
      }
      function Sh(t, e, n) {
        const i = Th(t, e, n);
        if (i === -1) {
          return {
            firstIndex: -1,
            lastIndexOld: -1,
            lastIndexNew: -1,
          };
        }
        const o = Bh(t, i);
        const r = Bh(e, i);
        const s = Th(o, r, n);
        const a = t.length - s;
        const c = e.length - s;
        return { firstIndex: i, lastIndexOld: a, lastIndexNew: c };
      }
      function Th(t, e, n) {
        for (let i = 0; i < Math.max(t.length, e.length); i++) {
          if (
            t[i] === undefined ||
            e[i] === undefined ||
            !n(t[i], e[i])
          ) {
            return i;
          }
        }
        return -1;
      }
      function Bh(t, e) {
        return t.slice(e).reverse();
      }
      function Ph(t, e) {
        const n = [];
        const { firstIndex: i, lastIndexOld: o, lastIndexNew: r } = e;
        if (r - i > 0) {
          n.push({ index: i, type: 'insert', values: t.slice(i, r) });
        }
        if (o - i > 0) {
          n.push({
            index: i + (r - i),
            type: 'delete',
            howMany: o - i,
          });
        }
        return n;
      }
      function Ih(t, e) {
        const { firstIndex: n, lastIndexOld: i, lastIndexNew: o } = t;
        if (n === -1) {
          return Array(e).fill('equal');
        }
        let r = [];
        if (n > 0) {
          r = r.concat(Array(n).fill('equal'));
        }
        if (o - n > 0) {
          r = r.concat(Array(o - n).fill('insert'));
        }
        if (i - n > 0) {
          r = r.concat(Array(i - n).fill('delete'));
        }
        if (o < e) {
          r = r.concat(Array(e - o).fill('equal'));
        }
        return r;
      }
      function Rh(t, e, n) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const i = t.length;
        const o = e.length;
        if (i > 200 || o > 200 || i + o > 300) {
          return Rh.fastDiff(t, e, n, true);
        }
        let r, s;
        if (o < i) {
          const n = t;
          t = e;
          e = n;
          r = 'delete';
          s = 'insert';
        } else {
          r = 'insert';
          s = 'delete';
        }
        const a = t.length;
        const c = e.length;
        const l = c - a;
        const d = {};
        const h = {};
        function u(i) {
          const o = (h[i - 1] !== undefined ? h[i - 1] : -1) + 1;
          const l = h[i + 1] !== undefined ? h[i + 1] : -1;
          const u = o > l ? -1 : 1;
          if (d[i + u]) {
            d[i] = d[i + u].slice(0);
          }
          if (!d[i]) {
            d[i] = [];
          }
          d[i].push(o > l ? r : s);
          let f = Math.max(o, l);
          let g = f - i;
          while (g < a && f < c && n(t[g], e[f])) {
            g++;
            f++;
            d[i].push('equal');
          }
          return f;
        }
        let f = 0;
        let g;
        do {
          for (g = -f; g < l; g++) {
            h[g] = u(g);
          }
          for (g = l + f; g > l; g--) {
            h[g] = u(g);
          }
          h[l] = u(l);
          f++;
        } while (h[l] !== c);
        return d[l].slice(1);
      }
      Rh.fastDiff = Dh;
      function zh(t, e, n) {
        t.insertBefore(n, t.childNodes[e] || null);
      }
      function Oh(t) {
        const e = t.parentNode;
        if (e) {
          e.removeChild(t);
        }
      }
      function Fh(t) {
        return t && t.nodeType === Node.COMMENT_NODE;
      }
      function Nh(t) {
        if (t) {
          if (t.defaultView) {
            return t instanceof t.defaultView.Document;
          } else if (t.ownerDocument && t.ownerDocument.defaultView) {
            return t instanceof t.ownerDocument.defaultView.Node;
          }
        }
        return false;
      }
      var Mh = n(3379);
      var Lh = n.n(Mh);
      var Vh = n(4401);
      var Hh = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Hh.insert = 'head';
      Hh.singleton = true;
      var jh = Lh()(Vh.Z, Hh);
      const qh = Vh.Z.locals || {};
      class Wh extends W {
        constructor(t, e) {
          super();
          this.domDocuments = new Set();
          this.domConverter = t;
          this.markedAttributes = new Set();
          this.markedChildren = new Set();
          this.markedTexts = new Set();
          this.selection = e;
          this.set('isFocused', false);
          this.set('isSelecting', false);
          if (Sd.isBlink && !Sd.isAndroid) {
            this.on('change:isSelecting', () => {
              if (!this.isSelecting) {
                this.render();
              }
            });
          }
          this._inlineFiller = null;
          this._fakeSelectionContainer = null;
        }
        markToSync(t, e) {
          if (t === 'text') {
            if (this.domConverter.mapViewToDom(e.parent)) {
              this.markedTexts.add(e);
            }
          } else {
            if (!this.domConverter.mapViewToDom(e)) {
              return;
            }
            if (t === 'attributes') {
              this.markedAttributes.add(e);
            } else if (t === 'children') {
              this.markedChildren.add(e);
            } else {
              throw new h('view-renderer-unknown-type', this);
            }
          }
        }
        render() {
          let t = null;
          const e =
            Sd.isBlink && !Sd.isAndroid ? !this.isSelecting : true;
          for (const t of this.markedChildren) {
            this._updateChildrenMappings(t);
          }
          if (e) {
            if (
              this._inlineFiller &&
              !this._isSelectionInInlineFiller()
            ) {
              this._removeInlineFiller();
            }
            if (this._inlineFiller) {
              t = this._getInlineFillerPosition();
            } else if (this._needsInlineFillerAtSelection()) {
              t = this.selection.getFirstPosition();
              this.markedChildren.add(t.parent);
            }
          } else if (
            this._inlineFiller &&
            this._inlineFiller.parentNode
          ) {
            t = this.domConverter.domPositionToView(
              this._inlineFiller
            );
            if (t && t.parent.is('$text')) {
              t = od._createBefore(t.parent);
            }
          }
          for (const t of this.markedAttributes) {
            this._updateAttrs(t);
          }
          for (const e of this.markedChildren) {
            this._updateChildren(e, { inlineFillerPosition: t });
          }
          for (const e of this.markedTexts) {
            if (
              !this.markedChildren.has(e.parent) &&
              this.domConverter.mapViewToDom(e.parent)
            ) {
              this._updateText(e, { inlineFillerPosition: t });
            }
          }
          if (e) {
            if (t) {
              const e = this.domConverter.viewPositionToDom(t);
              const n = e.parent.ownerDocument;
              if (!Ah(e.parent)) {
                this._inlineFiller = Gh(n, e.parent, e.offset);
              } else {
                this._inlineFiller = e.parent;
              }
            } else {
              this._inlineFiller = null;
            }
          }
          this._updateFocus();
          this._updateSelection();
          this.markedTexts.clear();
          this.markedAttributes.clear();
          this.markedChildren.clear();
        }
        _updateChildrenMappings(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(
            this.domConverter.mapViewToDom(t).childNodes
          );
          const i = Array.from(
            this.domConverter.viewChildrenToDom(t, {
              withChildren: false,
            })
          );
          const o = this._diffNodeLists(n, i);
          const r = this._findReplaceActions(o, n, i);
          if (r.indexOf('replace') !== -1) {
            const e = { equal: 0, insert: 0, delete: 0 };
            for (const o of r) {
              if (o === 'replace') {
                const o = e.equal + e.insert;
                const r = e.equal + e.delete;
                const s = t.getChild(o);
                if (s && !(s.is('uiElement') || s.is('rawElement'))) {
                  this._updateElementMappings(s, n[r]);
                }
                Oh(i[o]);
                e.equal++;
              } else {
                e[o]++;
              }
            }
          }
        }
        _updateElementMappings(t, e) {
          this.domConverter.unbindDomElement(e);
          this.domConverter.bindElements(e, t);
          this.markedChildren.add(t);
          this.markedAttributes.add(t);
        }
        _getInlineFillerPosition() {
          const t = this.selection.getFirstPosition();
          if (t.parent.is('$text')) {
            return od._createBefore(t.parent);
          } else {
            return t;
          }
        }
        _isSelectionInInlineFiller() {
          if (
            this.selection.rangeCount != 1 ||
            !this.selection.isCollapsed
          ) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = this.domConverter.viewPositionToDom(t);
          if (e && ph(e.parent) && Ah(e.parent)) {
            return true;
          }
          return false;
        }
        _removeInlineFiller() {
          const t = this._inlineFiller;
          if (!Ah(t)) {
            throw new h('view-renderer-filler-was-lost', this);
          }
          if (Ch(t)) {
            t.remove();
          } else {
            t.data = t.data.substr(_h);
          }
          this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (
            this.selection.rangeCount != 1 ||
            !this.selection.isCollapsed
          ) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = t.parent;
          const n = t.offset;
          if (!this.domConverter.mapViewToDom(e.root)) {
            return false;
          }
          if (!e.is('element')) {
            return false;
          }
          if (!Uh(e)) {
            return false;
          }
          if (n === e.getFillerOffset()) {
            return false;
          }
          const i = t.nodeBefore;
          const o = t.nodeAfter;
          if (i instanceof Ga || o instanceof Ga) {
            return false;
          }
          return true;
        }
        _updateText(t, e) {
          const n = this.domConverter.findCorrespondingDomText(t);
          const i = this.domConverter.viewToDom(t);
          const o = n.data;
          let r = i.data;
          const s = e.inlineFillerPosition;
          if (s && s.parent == t.parent && s.offset == t.index) {
            r = vh + r;
          }
          if (o != r) {
            const t = Dh(o, r);
            for (const e of t) {
              if (e.type === 'insert') {
                n.insertData(e.index, e.values.join(''));
              } else {
                n.deleteData(e.index, e.howMany);
              }
            }
          }
        }
        _updateAttrs(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(e.attributes).map((t) => t.name);
          const i = t.getAttributeKeys();
          for (const n of i) {
            this.domConverter.setDomElementAttribute(
              e,
              n,
              t.getAttribute(n),
              t
            );
          }
          for (const i of n) {
            if (!t.hasAttribute(i)) {
              this.domConverter.removeDomElementAttribute(e, i);
            }
          }
        }
        _updateChildren(t, e) {
          const n = this.domConverter.mapViewToDom(t);
          if (!n) {
            return;
          }
          const i = e.inlineFillerPosition;
          const o = this.domConverter.mapViewToDom(t).childNodes;
          const r = Array.from(
            this.domConverter.viewChildrenToDom(t, { bind: true })
          );
          if (i && i.parent === t) {
            Gh(n.ownerDocument, r, i.offset);
          }
          const s = this._diffNodeLists(o, r);
          let a = 0;
          const c = new Set();
          for (const t of s) {
            if (t === 'delete') {
              c.add(o[a]);
              Oh(o[a]);
            } else if (t === 'equal') {
              a++;
            }
          }
          a = 0;
          for (const t of s) {
            if (t === 'insert') {
              zh(n, a, r[a]);
              a++;
            } else if (t === 'equal') {
              this._markDescendantTextToSync(
                this.domConverter.domToView(r[a])
              );
              a++;
            }
          }
          for (const t of c) {
            if (!t.parentNode) {
              this.domConverter.unbindDomElement(t);
            }
          }
        }
        _diffNodeLists(t, e) {
          t = Jh(t, this._fakeSelectionContainer);
          return Rh(t, e, Kh.bind(null, this.domConverter));
        }
        _findReplaceActions(t, e, n) {
          if (
            t.indexOf('insert') === -1 ||
            t.indexOf('delete') === -1
          ) {
            return t;
          }
          let i = [];
          let o = [];
          let r = [];
          const s = { equal: 0, insert: 0, delete: 0 };
          for (const a of t) {
            if (a === 'insert') {
              r.push(n[s.equal + s.insert]);
            } else if (a === 'delete') {
              o.push(e[s.equal + s.delete]);
            } else {
              i = i.concat(
                Rh(o, r, $h).map((t) =>
                  t === 'equal' ? 'replace' : t
                )
              );
              i.push('equal');
              o = [];
              r = [];
            }
            s[a]++;
          }
          return i.concat(
            Rh(o, r, $h).map((t) => (t === 'equal' ? 'replace' : t))
          );
        }
        _markDescendantTextToSync(t) {
          if (!t) {
            return;
          }
          if (t.is('$text')) {
            this.markedTexts.add(t);
          } else if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._markDescendantTextToSync(e);
            }
          }
        }
        _updateSelection() {
          if (
            Sd.isBlink &&
            !Sd.isAndroid &&
            this.isSelecting &&
            !this.markedChildren.size
          ) {
            return;
          }
          if (this.selection.rangeCount === 0) {
            this._removeDomSelection();
            this._removeFakeSelection();
            return;
          }
          const t = this.domConverter.mapViewToDom(
            this.selection.editableElement
          );
          if (!this.isFocused || !t) {
            return;
          }
          if (this.selection.isFake) {
            this._updateFakeSelection(t);
          } else {
            this._removeFakeSelection();
            this._updateDomSelection(t);
          }
        }
        _updateFakeSelection(t) {
          const e = t.ownerDocument;
          if (!this._fakeSelectionContainer) {
            this._fakeSelectionContainer = Yh(e);
          }
          const n = this._fakeSelectionContainer;
          this.domConverter.bindFakeSelection(n, this.selection);
          if (!this._fakeSelectionNeedsUpdate(t)) {
            return;
          }
          if (!n.parentElement || n.parentElement != t) {
            t.appendChild(n);
          }
          n.textContent = this.selection.fakeSelectionLabel || ' ';
          const i = e.getSelection();
          const o = e.createRange();
          i.removeAllRanges();
          o.selectNodeContents(n);
          i.addRange(o);
        }
        _updateDomSelection(t) {
          const e = t.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(e)) {
            return;
          }
          const n = this.domConverter.viewPositionToDom(
            this.selection.anchor
          );
          const i = this.domConverter.viewPositionToDom(
            this.selection.focus
          );
          e.collapse(n.parent, n.offset);
          e.extend(i.parent, i.offset);
          if (Sd.isGecko) {
            Zh(i, e);
          }
        }
        _domSelectionNeedsUpdate(t) {
          if (!this.domConverter.isDomSelectionCorrect(t)) {
            return true;
          }
          const e = t && this.domConverter.domSelectionToView(t);
          if (e && this.selection.isEqual(e)) {
            return false;
          }
          if (
            !this.selection.isCollapsed &&
            this.selection.isSimilar(e)
          ) {
            return false;
          }
          return true;
        }
        _fakeSelectionNeedsUpdate(t) {
          const e = this._fakeSelectionContainer;
          const n = t.ownerDocument.getSelection();
          if (!e || e.parentElement !== t) {
            return true;
          }
          if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
            return true;
          }
          return e.textContent !== this.selection.fakeSelectionLabel;
        }
        _removeDomSelection() {
          for (const t of this.domDocuments) {
            const e = t.getSelection();
            if (e.rangeCount) {
              const n = t.activeElement;
              const i = this.domConverter.mapDomToView(n);
              if (n && i) {
                e.removeAllRanges();
              }
            }
          }
        }
        _removeFakeSelection() {
          const t = this._fakeSelectionContainer;
          if (t) {
            t.remove();
          }
        }
        _updateFocus() {
          if (this.isFocused) {
            const t = this.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
            }
          }
        }
      }
      function Uh(t) {
        if (t.getAttribute('contenteditable') == 'false') {
          return false;
        }
        const e = t.findAncestor((t) =>
          t.hasAttribute('contenteditable')
        );
        return !e || e.getAttribute('contenteditable') == 'true';
      }
      function Gh(t, e, n) {
        const i = e instanceof Array ? e : e.childNodes;
        const o = i[n];
        if (ph(o)) {
          o.data = vh + o.data;
          return o;
        } else {
          const o = t.createTextNode(vh);
          if (Array.isArray(e)) {
            i.splice(n, 0, o);
          } else {
            zh(e, n, o);
          }
          return o;
        }
      }
      function $h(t, e) {
        return (
          Nh(t) &&
          Nh(e) &&
          !ph(t) &&
          !ph(e) &&
          !Fh(t) &&
          !Fh(e) &&
          t.tagName.toLowerCase() === e.tagName.toLowerCase()
        );
      }
      function Kh(t, e, n) {
        if (e === n) {
          return true;
        } else if (ph(e) && ph(n)) {
          return e.data === n.data;
        } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
          return true;
        }
        return false;
      }
      function Zh(t, e) {
        const n = t.parent;
        if (
          n.nodeType != Node.ELEMENT_NODE ||
          t.offset != n.childNodes.length - 1
        ) {
          return;
        }
        const i = n.childNodes[t.offset];
        if (i && i.tagName == 'BR') {
          e.addRange(e.getRangeAt(0));
        }
      }
      function Jh(t, e) {
        const n = Array.from(t);
        if (n.length == 0 || !e) {
          return n;
        }
        const i = n[n.length - 1];
        if (i == e) {
          n.pop();
        }
        return n;
      }
      function Yh(t) {
        const e = t.createElement('div');
        e.className = 'ck-fake-selection-container';
        Object.assign(e.style, {
          position: 'fixed',
          top: 0,
          left: '-9999px',
          width: '42px',
        });
        e.textContent = ' ';
        return e;
      }
      function Qh(t) {
        let e = 0;
        while (t.previousSibling) {
          t = t.previousSibling;
          e++;
        }
        return e;
      }
      function Xh(t) {
        const e = [];
        let n = t;
        while (n && n.nodeType != Node.DOCUMENT_NODE) {
          e.unshift(n);
          n = n.parentNode;
        }
        return e;
      }
      const tu = wh(Sa.document);
      const eu = kh(Sa.document);
      const nu = bh(Sa.document);
      const iu = 'data-ck-unsafe-attribute-';
      const ou = 'data-ck-unsafe-element';
      class ru {
        constructor(t, e = {}) {
          this.document = t;
          this.renderingMode = e.renderingMode || 'editing';
          this.blockFillerMode =
            e.blockFillerMode ||
            (this.renderingMode === 'editing' ? 'br' : 'nbsp');
          this.preElements = ['pre'];
          this.blockElements = [
            'address',
            'article',
            'aside',
            'blockquote',
            'caption',
            'center',
            'dd',
            'details',
            'dir',
            'div',
            'dl',
            'dt',
            'fieldset',
            'figcaption',
            'figure',
            'footer',
            'form',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'header',
            'hgroup',
            'legend',
            'li',
            'main',
            'menu',
            'nav',
            'ol',
            'p',
            'pre',
            'section',
            'summary',
            'table',
            'tbody',
            'td',
            'tfoot',
            'th',
            'thead',
            'tr',
            'ul',
          ];
          this.inlineObjectElements = [
            'object',
            'iframe',
            'input',
            'button',
            'textarea',
            'select',
            'option',
            'video',
            'embed',
            'audio',
            'img',
            'canvas',
          ];
          this.unsafeElements = ['script', 'style'];
          this._domDocument =
            this.renderingMode === 'editing'
              ? Sa.document
              : Sa.document.implementation.createHTMLDocument('');
          this._domToViewMapping = new WeakMap();
          this._viewToDomMapping = new WeakMap();
          this._fakeSelectionMapping = new WeakMap();
          this._rawContentElementMatcher = new Ja();
          this._encounteredRawContentDomNodes = new WeakSet();
        }
        bindFakeSelection(t, e) {
          this._fakeSelectionMapping.set(t, new cd(e));
        }
        fakeSelectionToView(t) {
          return this._fakeSelectionMapping.get(t);
        }
        bindElements(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        unbindDomElement(t) {
          const e = this._domToViewMapping.get(t);
          if (e) {
            this._domToViewMapping.delete(t);
            this._viewToDomMapping.delete(e);
            for (const e of Array.from(t.children)) {
              this.unbindDomElement(e);
            }
          }
        }
        bindDocumentFragments(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        shouldRenderAttribute(t, e, n) {
          if (this.renderingMode === 'data') {
            return true;
          }
          t = t.toLowerCase();
          if (t.startsWith('on')) {
            return false;
          }
          if (
            t === 'srcdoc' &&
            e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)
          ) {
            return false;
          }
          if (n === 'img' && (t === 'src' || t === 'srcset')) {
            return true;
          }
          if (n === 'source' && t === 'srcset') {
            return true;
          }
          if (
            e.match(
              /^\s*(javascript:|data:(image\/svg|text\/x?html))/i
            )
          ) {
            return false;
          }
          return true;
        }
        setContentOf(t, e) {
          if (this.renderingMode === 'data') {
            t.innerHTML = e;
            return;
          }
          const n = new DOMParser().parseFromString(e, 'text/html');
          const i = n.createDocumentFragment();
          const o = n.body.childNodes;
          while (o.length > 0) {
            i.appendChild(o[0]);
          }
          const r = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT);
          const s = [];
          let a;
          while ((a = r.nextNode())) {
            s.push(a);
          }
          for (const t of s) {
            for (const e of t.getAttributeNames()) {
              this.setDomElementAttribute(t, e, t.getAttribute(e));
            }
            const e = t.tagName.toLowerCase();
            if (this._shouldRenameElement(e)) {
              du(e);
              t.replaceWith(this._createReplacementDomElement(e, t));
            }
          }
          while (t.firstChild) {
            t.firstChild.remove();
          }
          t.append(i);
        }
        viewToDom(t, e = {}) {
          if (t.is('$text')) {
            const e = this._processDataFromViewText(t);
            return this._domDocument.createTextNode(e);
          } else {
            if (this.mapViewToDom(t)) {
              return this.mapViewToDom(t);
            }
            let n;
            if (t.is('documentFragment')) {
              n = this._domDocument.createDocumentFragment();
              if (e.bind) {
                this.bindDocumentFragments(n, t);
              }
            } else if (t.is('uiElement')) {
              if (t.name === '$comment') {
                n = this._domDocument.createComment(
                  t.getCustomProperty('$rawContent')
                );
              } else {
                n = t.render(this._domDocument, this);
              }
              if (e.bind) {
                this.bindElements(n, t);
              }
              return n;
            } else {
              if (this._shouldRenameElement(t.name)) {
                du(t.name);
                n = this._createReplacementDomElement(t.name);
              } else if (t.hasAttribute('xmlns')) {
                n = this._domDocument.createElementNS(
                  t.getAttribute('xmlns'),
                  t.name
                );
              } else {
                n = this._domDocument.createElement(t.name);
              }
              if (t.is('rawElement')) {
                t.render(n, this);
              }
              if (e.bind) {
                this.bindElements(n, t);
              }
              for (const e of t.getAttributeKeys()) {
                this.setDomElementAttribute(
                  n,
                  e,
                  t.getAttribute(e),
                  t
                );
              }
            }
            if (e.withChildren !== false) {
              for (const i of this.viewChildrenToDom(t, e)) {
                n.appendChild(i);
              }
            }
            return n;
          }
        }
        setDomElementAttribute(t, e, n, i) {
          const o =
            this.shouldRenderAttribute(
              e,
              n,
              t.tagName.toLowerCase()
            ) ||
            (i && i.shouldRenderUnsafeAttribute(e));
          if (!o) {
            u('domconverter-unsafe-attribute-detected', {
              domElement: t,
              key: e,
              value: n,
            });
          }
          if (t.hasAttribute(e) && !o) {
            t.removeAttribute(e);
          } else if (t.hasAttribute(iu + e) && o) {
            t.removeAttribute(iu + e);
          }
          t.setAttribute(o ? e : iu + e, n);
        }
        removeDomElementAttribute(t, e) {
          if (e == ou) {
            return;
          }
          t.removeAttribute(e);
          t.removeAttribute(iu + e);
        }
        *viewChildrenToDom(t, e = {}) {
          const n = t.getFillerOffset && t.getFillerOffset();
          let i = 0;
          for (const o of t.getChildren()) {
            if (n === i) {
              yield this._getBlockFiller();
            }
            const t =
              o.is('element') &&
              o.getCustomProperty(
                'dataPipeline:transparentRendering'
              );
            if (t && this.renderingMode == 'data') {
              yield* this.viewChildrenToDom(o, e);
            } else {
              if (t) {
                u(
                  'domconverter-transparent-rendering-unsupported-in-editing-pipeline',
                  { viewElement: o }
                );
              }
              yield this.viewToDom(o, e);
            }
            i++;
          }
          if (n === i) {
            yield this._getBlockFiller();
          }
        }
        viewRangeToDom(t) {
          const e = this.viewPositionToDom(t.start);
          const n = this.viewPositionToDom(t.end);
          const i = this._domDocument.createRange();
          i.setStart(e.parent, e.offset);
          i.setEnd(n.parent, n.offset);
          return i;
        }
        viewPositionToDom(t) {
          const e = t.parent;
          if (e.is('$text')) {
            const n = this.findCorrespondingDomText(e);
            if (!n) {
              return null;
            }
            let i = t.offset;
            if (Ah(n)) {
              i += _h;
            }
            return { parent: n, offset: i };
          } else {
            let n, i, o;
            if (t.offset === 0) {
              n = this.mapViewToDom(e);
              if (!n) {
                return null;
              }
              o = n.childNodes[0];
            } else {
              const e = t.nodeBefore;
              i = e.is('$text')
                ? this.findCorrespondingDomText(e)
                : this.mapViewToDom(e);
              if (!i) {
                return null;
              }
              n = i.parentNode;
              o = i.nextSibling;
            }
            if (ph(o) && Ah(o)) {
              return { parent: o, offset: _h };
            }
            const r = i ? Qh(i) + 1 : 0;
            return { parent: n, offset: r };
          }
        }
        domToView(t, e = {}) {
          if (this.isBlockFiller(t)) {
            return null;
          }
          const n = this.getHostViewElement(t);
          if (n) {
            return n;
          }
          if (Fh(t) && e.skipComments) {
            return null;
          }
          if (ph(t)) {
            if (Ch(t)) {
              return null;
            } else {
              const e = this._processDataFromDomText(t);
              return e === '' ? null : new Ga(this.document, e);
            }
          } else {
            if (this.mapDomToView(t)) {
              return this.mapDomToView(t);
            }
            let n;
            if (this.isDocumentFragment(t)) {
              n = new nh(this.document);
              if (e.bind) {
                this.bindDocumentFragments(t, n);
              }
            } else {
              n = this._createViewElement(t, e);
              if (e.bind) {
                this.bindElements(t, n);
              }
              const i = t.attributes;
              if (i) {
                for (let t = i.length, e = 0; e < t; e++) {
                  n._setAttribute(i[e].name, i[e].value);
                }
              }
              if (this._isViewElementWithRawContent(n, e) || Fh(t)) {
                const e = Fh(t) ? t.data : t.innerHTML;
                n._setCustomProperty('$rawContent', e);
                this._encounteredRawContentDomNodes.add(t);
                return n;
              }
            }
            if (e.withChildren !== false) {
              for (const i of this.domChildrenToView(t, e)) {
                n._appendChild(i);
              }
            }
            return n;
          }
        }
        *domChildrenToView(t, e) {
          for (let n = 0; n < t.childNodes.length; n++) {
            const i = t.childNodes[n];
            const o = this.domToView(i, e);
            if (o !== null) {
              yield o;
            }
          }
        }
        domSelectionToView(t) {
          if (t.rangeCount === 1) {
            let e = t.getRangeAt(0).startContainer;
            if (ph(e)) {
              e = e.parentNode;
            }
            const n = this.fakeSelectionToView(e);
            if (n) {
              return n;
            }
          }
          const e = this.isDomSelectionBackward(t);
          const n = [];
          for (let e = 0; e < t.rangeCount; e++) {
            const i = t.getRangeAt(e);
            const o = this.domRangeToView(i);
            if (o) {
              n.push(o);
            }
          }
          return new cd(n, { backward: e });
        }
        domRangeToView(t) {
          const e = this.domPositionToView(
            t.startContainer,
            t.startOffset
          );
          const n = this.domPositionToView(
            t.endContainer,
            t.endOffset
          );
          if (e && n) {
            return new rd(e, n);
          }
          return null;
        }
        domPositionToView(t, e = 0) {
          if (this.isBlockFiller(t)) {
            return this.domPositionToView(t.parentNode, Qh(t));
          }
          const n = this.mapDomToView(t);
          if (n && (n.is('uiElement') || n.is('rawElement'))) {
            return od._createBefore(n);
          }
          if (ph(t)) {
            if (Ch(t)) {
              return this.domPositionToView(t.parentNode, Qh(t));
            }
            const n = this.findCorrespondingViewText(t);
            let i = e;
            if (!n) {
              return null;
            }
            if (Ah(t)) {
              i -= _h;
              i = i < 0 ? 0 : i;
            }
            return new od(n, i);
          } else {
            if (e === 0) {
              const e = this.mapDomToView(t);
              if (e) {
                return new od(e, 0);
              }
            } else {
              const n = t.childNodes[e - 1];
              const i = ph(n)
                ? this.findCorrespondingViewText(n)
                : this.mapDomToView(n);
              if (i && i.parent) {
                return new od(i.parent, i.index + 1);
              }
            }
            return null;
          }
        }
        mapDomToView(t) {
          const e = this.getHostViewElement(t);
          return e || this._domToViewMapping.get(t);
        }
        findCorrespondingViewText(t) {
          if (Ch(t)) {
            return null;
          }
          const e = this.getHostViewElement(t);
          if (e) {
            return e;
          }
          const n = t.previousSibling;
          if (n) {
            if (!this.isElement(n)) {
              return null;
            }
            const t = this.mapDomToView(n);
            if (t) {
              const e = t.nextSibling;
              if (e instanceof Ga) {
                return e;
              } else {
                return null;
              }
            }
          } else {
            const e = this.mapDomToView(t.parentNode);
            if (e) {
              const t = e.getChild(0);
              if (t instanceof Ga) {
                return t;
              } else {
                return null;
              }
            }
          }
          return null;
        }
        mapViewToDom(t) {
          return this._viewToDomMapping.get(t);
        }
        findCorrespondingDomText(t) {
          const e = t.previousSibling;
          if (e && this.mapViewToDom(e)) {
            return this.mapViewToDom(e).nextSibling;
          }
          if (!e && t.parent && this.mapViewToDom(t.parent)) {
            return this.mapViewToDom(t.parent).childNodes[0];
          }
          return null;
        }
        focus(t) {
          const e = this.mapViewToDom(t);
          if (e && e.ownerDocument.activeElement !== e) {
            const { scrollX: t, scrollY: n } = Sa.window;
            const i = [];
            au(e, (t) => {
              const { scrollLeft: e, scrollTop: n } = t;
              i.push([e, n]);
            });
            e.focus();
            au(e, (t) => {
              const [e, n] = i.shift();
              t.scrollLeft = e;
              t.scrollTop = n;
            });
            Sa.window.scrollTo(t, n);
          }
        }
        isElement(t) {
          return t && t.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(t) {
          return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isBlockFiller(t) {
          if (this.blockFillerMode == 'br') {
            return t.isEqualNode(tu);
          }
          if (
            t.tagName === 'BR' &&
            lu(t, this.blockElements) &&
            t.parentNode.childNodes.length === 1
          ) {
            return true;
          }
          return t.isEqualNode(nu) || cu(t, this.blockElements);
        }
        isDomSelectionBackward(t) {
          if (t.isCollapsed) {
            return false;
          }
          const e = this._domDocument.createRange();
          e.setStart(t.anchorNode, t.anchorOffset);
          e.setEnd(t.focusNode, t.focusOffset);
          const n = e.collapsed;
          e.detach();
          return n;
        }
        getHostViewElement(t) {
          const e = Xh(t);
          e.pop();
          while (e.length) {
            const t = e.pop();
            const n = this._domToViewMapping.get(t);
            if (n && (n.is('uiElement') || n.is('rawElement'))) {
              return n;
            }
          }
          return null;
        }
        isDomSelectionCorrect(t) {
          return (
            this._isDomSelectionPositionCorrect(
              t.anchorNode,
              t.anchorOffset
            ) &&
            this._isDomSelectionPositionCorrect(
              t.focusNode,
              t.focusOffset
            )
          );
        }
        registerRawContentMatcher(t) {
          this._rawContentElementMatcher.add(t);
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case 'nbsp':
              return kh(this._domDocument);
            case 'markedNbsp':
              return bh(this._domDocument);
            case 'br':
              return wh(this._domDocument);
          }
        }
        _isDomSelectionPositionCorrect(t, e) {
          if (ph(t) && Ah(t) && e < _h) {
            return false;
          }
          if (this.isElement(t) && Ah(t.childNodes[e])) {
            return false;
          }
          const n = this.mapDomToView(t);
          if (n && (n.is('uiElement') || n.is('rawElement'))) {
            return false;
          }
          return true;
        }
        _processDataFromViewText(t) {
          let e = t.data;
          if (
            t
              .getAncestors()
              .some((t) => this.preElements.includes(t.name))
          ) {
            return e;
          }
          if (e.charAt(0) == ' ') {
            const n = this._getTouchingInlineViewNode(t, false);
            const i =
              n && n.is('$textProxy') && this._nodeEndsWithSpace(n);
            if (i || !n) {
              e = ' ' + e.substr(1);
            }
          }
          if (e.charAt(e.length - 1) == ' ') {
            const n = this._getTouchingInlineViewNode(t, true);
            const i =
              n && n.is('$textProxy') && n.data.charAt(0) == ' ';
            if (e.charAt(e.length - 2) == ' ' || !n || i) {
              e = e.substr(0, e.length - 1) + ' ';
            }
          }
          return e.replace(/ {2}/g, '  ');
        }
        _nodeEndsWithSpace(t) {
          if (
            t
              .getAncestors()
              .some((t) => this.preElements.includes(t.name))
          ) {
            return false;
          }
          const e = this._processDataFromViewText(t);
          return e.charAt(e.length - 1) == ' ';
        }
        _processDataFromDomText(t) {
          let e = t.data;
          if (su(t, this.preElements)) {
            return yh(t);
          }
          e = e.replace(/[ \n\t\r]{1,}/g, ' ');
          const n = this._getTouchingInlineDomNode(t, false);
          const i = this._getTouchingInlineDomNode(t, true);
          const o = this._checkShouldLeftTrimDomText(t, n);
          const r = this._checkShouldRightTrimDomText(t, i);
          if (o) {
            e = e.replace(/^ /, '');
          }
          if (r) {
            e = e.replace(/ $/, '');
          }
          e = yh(new Text(e));
          e = e.replace(/ \u00A0/g, '  ');
          const s = i && this.isElement(i) && i.tagName != 'BR';
          const a = i && ph(i) && i.data.charAt(0) == ' ';
          if (/( |\u00A0)\u00A0$/.test(e) || !i || s || a) {
            e = e.replace(/\u00A0$/, ' ');
          }
          if (o || (n && this.isElement(n) && n.tagName != 'BR')) {
            e = e.replace(/^\u00A0/, ' ');
          }
          return e;
        }
        _checkShouldLeftTrimDomText(t, e) {
          if (!e) {
            return true;
          }
          if (this.isElement(e)) {
            return e.tagName === 'BR';
          }
          if (
            this._encounteredRawContentDomNodes.has(t.previousSibling)
          ) {
            return false;
          }
          return /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1));
        }
        _checkShouldRightTrimDomText(t, e) {
          if (e) {
            return false;
          }
          return !Ah(t);
        }
        _getTouchingInlineViewNode(t, e) {
          const n = new id({
            startPosition: e
              ? od._createAfter(t)
              : od._createBefore(t),
            direction: e ? 'forward' : 'backward',
          });
          for (const t of n) {
            if (
              t.item.is('element') &&
              this.inlineObjectElements.includes(t.item.name)
            ) {
              return t.item;
            } else if (t.item.is('containerElement')) {
              return null;
            } else if (t.item.is('element', 'br')) {
              return null;
            } else if (t.item.is('$textProxy')) {
              return t.item;
            }
          }
          return null;
        }
        _getTouchingInlineDomNode(t, e) {
          if (!t.parentNode) {
            return null;
          }
          const n = e ? 'firstChild' : 'lastChild';
          const i = e ? 'nextSibling' : 'previousSibling';
          let o = true;
          let r = t;
          do {
            if (!o && r[n]) {
              r = r[n];
            } else if (r[i]) {
              r = r[i];
              o = false;
            } else {
              r = r.parentNode;
              o = true;
            }
            if (!r || this._isBlockElement(r)) {
              return null;
            }
          } while (
            !(
              ph(r) ||
              r.tagName == 'BR' ||
              this._isInlineObjectElement(r)
            )
          );
          return r;
        }
        _isBlockElement(t) {
          return (
            this.isElement(t) &&
            this.blockElements.includes(t.tagName.toLowerCase())
          );
        }
        _isInlineObjectElement(t) {
          return (
            this.isElement(t) &&
            this.inlineObjectElements.includes(
              t.tagName.toLowerCase()
            )
          );
        }
        _createViewElement(t, e) {
          if (Fh(t)) {
            return new Jd(this.document, '$comment');
          }
          const n = e.keepOriginalCase
            ? t.tagName
            : t.tagName.toLowerCase();
          return new Kl(this.document, n);
        }
        _isViewElementWithRawContent(t, e) {
          return (
            e.withChildren !== false &&
            !!this._rawContentElementMatcher.match(t)
          );
        }
        _shouldRenameElement(t) {
          const e = t.toLowerCase();
          return (
            this.renderingMode === 'editing' &&
            this.unsafeElements.includes(e)
          );
        }
        _createReplacementDomElement(t, e) {
          const n = this._domDocument.createElement('span');
          n.setAttribute(ou, t);
          if (e) {
            while (e.firstChild) {
              n.appendChild(e.firstChild);
            }
            for (const t of e.getAttributeNames()) {
              n.setAttribute(t, e.getAttribute(t));
            }
          }
          return n;
        }
      }
      function su(t, e) {
        const n = Xh(t);
        return n.some(
          (t) => t.tagName && e.includes(t.tagName.toLowerCase())
        );
      }
      function au(t, e) {
        let n = t;
        while (n) {
          e(n);
          n = n.parentElement;
        }
      }
      function cu(t, e) {
        const n = t.isEqualNode(eu);
        return n && lu(t, e) && t.parentNode.childNodes.length === 1;
      }
      function lu(t, e) {
        const n = t.parentNode;
        return (
          !!n && !!n.tagName && e.includes(n.tagName.toLowerCase())
        );
      }
      function du(t) {
        if (t === 'script') {
          u('domconverter-unsafe-script-element-detected');
        }
        if (t === 'style') {
          u('domconverter-unsafe-style-element-detected');
        }
      }
      function hu(t) {
        const e = Object.prototype.toString.apply(t);
        if (e == '[object Window]') {
          return true;
        }
        if (e == '[object global]') {
          return true;
        }
        return false;
      }
      function uu(t) {
        class e extends t {
          listenTo(t, e, n, i = {}) {
            if (Nh(t) || hu(t)) {
              const o = {
                capture: !!i.useCapture,
                passive: !!i.usePassive,
              };
              const r = this._getProxyEmitter(t, o) || new gu(t, o);
              this.listenTo(r, e, n, i);
            } else {
              y.prototype.listenTo.call(this, t, e, n, i);
            }
          }
          stopListening(t, e, n) {
            if (Nh(t) || hu(t)) {
              const i = this._getAllProxyEmitters(t);
              for (const t of i) {
                this.stopListening(t, e, n);
              }
            } else {
              y.prototype.stopListening.call(this, t, e, n);
            }
          }
          _getProxyEmitter(t, e) {
            return x(this, pu(t, e));
          }
          _getAllProxyEmitters(t) {
            return [
              { capture: false, passive: false },
              { capture: false, passive: true },
              { capture: true, passive: false },
              { capture: true, passive: true },
            ]
              .map((e) => this._getProxyEmitter(t, e))
              .filter((t) => !!t);
          }
        }
        return e;
      }
      const fu = uu(y);
      [
        '_getProxyEmitter',
        '_getAllProxyEmitters',
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach((t) => {
        uu[t] = fu.prototype[t];
      });
      class gu extends y {
        constructor(t, e) {
          super();
          E(this, pu(t, e));
          this._domNode = t;
          this._options = e;
        }
        attach(t) {
          if (this._domListeners && this._domListeners[t]) {
            return;
          }
          const e = this._createDomListener(t);
          this._domNode.addEventListener(t, e, this._options);
          if (!this._domListeners) {
            this._domListeners = {};
          }
          this._domListeners[t] = e;
        }
        detach(t) {
          let e;
          if (
            this._domListeners[t] &&
            (!(e = this._events[t]) || !e.callbacks.length)
          ) {
            this._domListeners[t].removeListener();
          }
        }
        _addEventListener(t, e, n) {
          this.attach(t);
          y.prototype._addEventListener.call(this, t, e, n);
        }
        _removeEventListener(t, e) {
          y.prototype._removeEventListener.call(this, t, e);
          this.detach(t);
        }
        _createDomListener(t) {
          const e = (e) => {
            this.fire(t, e);
          };
          e.removeListener = () => {
            this._domNode.removeEventListener(t, e, this._options);
            delete this._domListeners[t];
          };
          return e;
        }
      }
      function mu(t) {
        return t['data-ck-expando'] || (t['data-ck-expando'] = s());
      }
      function pu(t, e) {
        let n = mu(t);
        for (const t of Object.keys(e).sort()) {
          if (e[t]) {
            n += '-' + t;
          }
        }
        return n;
      }
      class ku extends fu {
        constructor(t) {
          super();
          this.view = t;
          this.document = t.document;
          this.isEnabled = false;
        }
        enable() {
          this.isEnabled = true;
        }
        disable() {
          this.isEnabled = false;
        }
        destroy() {
          this.disable();
          this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(t) {
          if (t && t.nodeType === 3) {
            t = t.parentNode;
          }
          if (!t || t.nodeType !== 1) {
            return false;
          }
          return t.matches(
            '[data-cke-ignore-events], [data-cke-ignore-events] *'
          );
        }
      }
      var bu = '__lodash_hash_undefined__';
      function wu(t) {
        this.__data__.set(t, bu);
        return this;
      }
      const _u = wu;
      function vu(t) {
        return this.__data__.has(t);
      }
      const Au = vu;
      function Cu(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.__data__ = new Dn();
        while (++e < n) {
          this.add(t[e]);
        }
      }
      Cu.prototype.add = Cu.prototype.push = _u;
      Cu.prototype.has = Au;
      const yu = Cu;
      function xu(t, e) {
        var n = -1,
          i = t == null ? 0 : t.length;
        while (++n < i) {
          if (e(t[n], n, t)) {
            return true;
          }
        }
        return false;
      }
      const Eu = xu;
      function Du(t, e) {
        return t.has(e);
      }
      const Su = Du;
      var Tu = 1,
        Bu = 2;
      function Pu(t, e, n, i, o, r) {
        var s = n & Tu,
          a = t.length,
          c = e.length;
        if (a != c && !(s && c > a)) {
          return false;
        }
        var l = r.get(t);
        var d = r.get(e);
        if (l && d) {
          return l == e && d == t;
        }
        var h = -1,
          u = true,
          f = n & Bu ? new yu() : undefined;
        r.set(t, e);
        r.set(e, t);
        while (++h < a) {
          var g = t[h],
            m = e[h];
          if (i) {
            var p = s ? i(m, g, h, e, t, r) : i(g, m, h, t, e, r);
          }
          if (p !== undefined) {
            if (p) {
              continue;
            }
            u = false;
            break;
          }
          if (f) {
            if (
              !Eu(e, function (t, e) {
                if (!Su(f, e) && (g === t || o(g, t, n, i, r))) {
                  return f.push(e);
                }
              })
            ) {
              u = false;
              break;
            }
          } else if (!(g === m || o(g, m, n, i, r))) {
            u = false;
            break;
          }
        }
        r['delete'](t);
        r['delete'](e);
        return u;
      }
      const Iu = Pu;
      function Ru(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t, i) {
          n[++e] = [i, t];
        });
        return n;
      }
      const zu = Ru;
      function Ou(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t) {
          n[++e] = t;
        });
        return n;
      }
      const Fu = Ou;
      var Nu = 1,
        Mu = 2;
      var Lu = '[object Boolean]',
        Vu = '[object Date]',
        Hu = '[object Error]',
        ju = '[object Map]',
        qu = '[object Number]',
        Wu = '[object RegExp]',
        Uu = '[object Set]',
        Gu = '[object String]',
        $u = '[object Symbol]';
      var Ku = '[object ArrayBuffer]',
        Zu = '[object DataView]';
      var Ju = ft ? ft.prototype : undefined,
        Yu = Ju ? Ju.valueOf : undefined;
      function Qu(t, e, n, i, o, r, s) {
        switch (n) {
          case Zu:
            if (
              t.byteLength != e.byteLength ||
              t.byteOffset != e.byteOffset
            ) {
              return false;
            }
            t = t.buffer;
            e = e.buffer;
          case Ku:
            if (
              t.byteLength != e.byteLength ||
              !r(new Mr(t), new Mr(e))
            ) {
              return false;
            }
            return true;
          case Lu:
          case Vu:
          case qu:
            return Gt(+t, +e);
          case Hu:
            return t.name == e.name && t.message == e.message;
          case Wu:
          case Gu:
            return t == e + '';
          case ju:
            var a = zu;
          case Uu:
            var c = i & Nu;
            a || (a = Fu);
            if (t.size != e.size && !c) {
              return false;
            }
            var l = s.get(t);
            if (l) {
              return l == e;
            }
            i |= Mu;
            s.set(t, e);
            var d = Iu(a(t), a(e), i, o, r, s);
            s['delete'](t);
            return d;
          case $u:
            if (Yu) {
              return Yu.call(t) == Yu.call(e);
            }
        }
        return false;
      }
      const Xu = Qu;
      var tf = 1;
      var ef = Object.prototype;
      var nf = ef.hasOwnProperty;
      function of(t, e, n, i, o, r) {
        var s = n & tf,
          a = lr(t),
          c = a.length,
          l = lr(e),
          d = l.length;
        if (c != d && !s) {
          return false;
        }
        var h = c;
        while (h--) {
          var u = a[h];
          if (!(s ? u in e : nf.call(e, u))) {
            return false;
          }
        }
        var f = r.get(t);
        var g = r.get(e);
        if (f && g) {
          return f == e && g == t;
        }
        var m = true;
        r.set(t, e);
        r.set(e, t);
        var p = s;
        while (++h < c) {
          u = a[h];
          var k = t[u],
            b = e[u];
          if (i) {
            var w = s ? i(b, k, u, e, t, r) : i(k, b, u, t, e, r);
          }
          if (!(w === undefined ? k === b || o(k, b, n, i, r) : w)) {
            m = false;
            break;
          }
          p || (p = u == 'constructor');
        }
        if (m && !p) {
          var _ = t.constructor,
            v = e.constructor;
          if (
            _ != v &&
            'constructor' in t &&
            'constructor' in e &&
            !(
              typeof _ == 'function' &&
              _ instanceof _ &&
              typeof v == 'function' &&
              v instanceof v
            )
          ) {
            m = false;
          }
        }
        r['delete'](t);
        r['delete'](e);
        return m;
      }
      const rf = of;
      var sf = 1;
      var af = '[object Arguments]',
        cf = '[object Array]',
        lf = '[object Object]';
      var df = Object.prototype;
      var hf = df.hasOwnProperty;
      function uf(t, e, n, i, o, r) {
        var s = ni(t),
          a = ni(e),
          c = s ? cf : Ir(t),
          l = a ? cf : Ir(e);
        c = c == af ? lf : c;
        l = l == af ? lf : l;
        var d = c == lf,
          h = l == lf,
          u = c == l;
        if (u && hi(t)) {
          if (!hi(e)) {
            return false;
          }
          s = true;
          d = false;
        }
        if (u && !d) {
          r || (r = new In());
          return s || no(t)
            ? Iu(t, e, n, i, o, r)
            : Xu(t, e, c, n, i, o, r);
        }
        if (!(n & sf)) {
          var f = d && hf.call(t, '__wrapped__'),
            g = h && hf.call(e, '__wrapped__');
          if (f || g) {
            var m = f ? t.value() : t,
              p = g ? e.value() : e;
            r || (r = new In());
            return o(m, p, n, i, r);
          }
        }
        if (!u) {
          return false;
        }
        r || (r = new In());
        return rf(t, e, n, i, o, r);
      }
      const ff = uf;
      function gf(t, e, n, i, o) {
        if (t === e) {
          return true;
        }
        if (t == null || e == null || (!zt(t) && !zt(e))) {
          return t !== t && e !== e;
        }
        return ff(t, e, n, i, gf, o);
      }
      const mf = gf;
      function pf(t, e, n) {
        n = typeof n == 'function' ? n : undefined;
        var i = n ? n(t, e) : undefined;
        return i === undefined ? mf(t, e, undefined, n) : !!i;
      }
      const kf = pf;
      class bf extends ku {
        constructor(t) {
          super(t);
          this._config = {
            childList: true,
            characterData: true,
            characterDataOldValue: true,
            subtree: true,
          };
          this.domConverter = t.domConverter;
          this.renderer = t._renderer;
          this._domElements = [];
          this._mutationObserver = new window.MutationObserver(
            this._onMutations.bind(this)
          );
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(t) {
          this._domElements.push(t);
          if (this.isEnabled) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        enable() {
          super.enable();
          for (const t of this._domElements) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        disable() {
          super.disable();
          this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy();
          this._mutationObserver.disconnect();
        }
        _onMutations(t) {
          if (t.length === 0) {
            return;
          }
          const e = this.domConverter;
          const n = new Map();
          const i = new Set();
          for (const n of t) {
            if (n.type === 'childList') {
              const t = e.mapDomToView(n.target);
              if (t && (t.is('uiElement') || t.is('rawElement'))) {
                continue;
              }
              if (t && !this._isBogusBrMutation(n)) {
                i.add(t);
              }
            }
          }
          for (const o of t) {
            const t = e.mapDomToView(o.target);
            if (t && (t.is('uiElement') || t.is('rawElement'))) {
              continue;
            }
            if (o.type === 'characterData') {
              const t = e.findCorrespondingViewText(o.target);
              if (t && !i.has(t.parent)) {
                n.set(t, {
                  type: 'text',
                  oldText: t.data,
                  newText: yh(o.target),
                  node: t,
                });
              } else if (!t && Ah(o.target)) {
                i.add(e.mapDomToView(o.target.parentNode));
              }
            }
          }
          const o = [];
          for (const t of n.values()) {
            this.renderer.markToSync('text', t.node);
            o.push(t);
          }
          for (const t of i) {
            const n = e.mapViewToDom(t);
            const i = Array.from(t.getChildren());
            const r = Array.from(
              e.domChildrenToView(n, { withChildren: false })
            );
            if (!kf(i, r, a)) {
              this.renderer.markToSync('children', t);
              o.push({
                type: 'children',
                oldChildren: i,
                newChildren: r,
                node: t,
              });
            }
          }
          const r = t[0].target.ownerDocument.getSelection();
          let s = null;
          if (r && r.anchorNode) {
            const t = e.domPositionToView(
              r.anchorNode,
              r.anchorOffset
            );
            const n = e.domPositionToView(r.focusNode, r.focusOffset);
            if (t && n) {
              s = new cd(t);
              s.setFocus(n);
            }
          }
          if (o.length) {
            this.document.fire('mutations', o, s);
            this.view.forceRender();
          }
          function a(t, e) {
            if (Array.isArray(t)) {
              return;
            }
            if (t === e) {
              return true;
            } else if (t.is('$text') && e.is('$text')) {
              return t.data === e.data;
            }
            return false;
          }
        }
        _isBogusBrMutation(t) {
          let e = null;
          if (
            t.nextSibling === null &&
            t.removedNodes.length === 0 &&
            t.addedNodes.length == 1
          ) {
            e = this.domConverter.domToView(t.addedNodes[0], {
              withChildren: false,
            });
          }
          return e && e.is('element', 'br');
        }
      }
      var wf = Fl(function (t, e) {
        Wn(e, Bo(e), t);
      });
      const _f = wf;
      class vf {
        constructor(t, e, n) {
          this.view = t;
          this.document = t.document;
          this.domEvent = e;
          this.domTarget = e.target;
          _f(this, n);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class Af extends ku {
        constructor(t) {
          super(t);
          this.useCapture = false;
        }
        observe(t) {
          const e =
            typeof this.domEventType == 'string'
              ? [this.domEventType]
              : this.domEventType;
          e.forEach((e) => {
            this.listenTo(
              t,
              e,
              (t, e) => {
                if (
                  this.isEnabled &&
                  !this.checkShouldIgnoreEventFromTarget(e.target)
                ) {
                  this.onDomEvent(e);
                }
              },
              { useCapture: this.useCapture }
            );
          });
        }
        fire(t, e, n) {
          if (this.isEnabled) {
            this.document.fire(t, new vf(this.view, e, n));
          }
        }
      }
      class Cf extends Af {
        constructor(t) {
          super(t);
          this.domEventType = ['keydown', 'keyup'];
        }
        onDomEvent(t) {
          const e = {
            keyCode: t.keyCode,
            altKey: t.altKey,
            ctrlKey: t.ctrlKey,
            shiftKey: t.shiftKey,
            metaKey: t.metaKey,
            get keystroke() {
              return Hd(this);
            },
          };
          this.fire(t.type, t, e);
        }
      }
      var yf = function () {
        return ht.Date.now();
      };
      const xf = yf;
      var Ef = /\s/;
      function Df(t) {
        var e = t.length;
        while (e-- && Ef.test(t.charAt(e))) {}
        return e;
      }
      const Sf = Df;
      var Tf = /^\s+/;
      function Bf(t) {
        return t ? t.slice(0, Sf(t) + 1).replace(Tf, '') : t;
      }
      const Pf = Bf;
      var If = 0 / 0;
      var Rf = /^[-+]0x[0-9a-f]+$/i;
      var zf = /^0b[01]+$/i;
      var Of = /^0o[0-7]+$/i;
      var Ff = parseInt;
      function Nf(t) {
        if (typeof t == 'number') {
          return t;
        }
        if (cc(t)) {
          return If;
        }
        if (N(t)) {
          var e = typeof t.valueOf == 'function' ? t.valueOf() : t;
          t = N(e) ? e + '' : e;
        }
        if (typeof t != 'string') {
          return t === 0 ? t : +t;
        }
        t = Pf(t);
        var n = zf.test(t);
        return n || Of.test(t)
          ? Ff(t.slice(2), n ? 2 : 8)
          : Rf.test(t)
          ? If
          : +t;
      }
      const Mf = Nf;
      var Lf = 'Expected a function';
      var Vf = Math.max,
        Hf = Math.min;
      function jf(t, e, n) {
        var i,
          o,
          r,
          s,
          a,
          c,
          l = 0,
          d = false,
          h = false,
          u = true;
        if (typeof t != 'function') {
          throw new TypeError(Lf);
        }
        e = Mf(e) || 0;
        if (N(n)) {
          d = !!n.leading;
          h = 'maxWait' in n;
          r = h ? Vf(Mf(n.maxWait) || 0, e) : r;
          u = 'trailing' in n ? !!n.trailing : u;
        }
        function f(e) {
          var n = i,
            r = o;
          i = o = undefined;
          l = e;
          s = t.apply(r, n);
          return s;
        }
        function g(t) {
          l = t;
          a = setTimeout(k, e);
          return d ? f(t) : s;
        }
        function m(t) {
          var n = t - c,
            i = t - l,
            o = e - n;
          return h ? Hf(o, r - i) : o;
        }
        function p(t) {
          var n = t - c,
            i = t - l;
          return c === undefined || n >= e || n < 0 || (h && i >= r);
        }
        function k() {
          var t = xf();
          if (p(t)) {
            return b(t);
          }
          a = setTimeout(k, m(t));
        }
        function b(t) {
          a = undefined;
          if (u && i) {
            return f(t);
          }
          i = o = undefined;
          return s;
        }
        function w() {
          if (a !== undefined) {
            clearTimeout(a);
          }
          l = 0;
          i = c = o = a = undefined;
        }
        function _() {
          return a === undefined ? s : b(xf());
        }
        function v() {
          var t = xf(),
            n = p(t);
          i = arguments;
          o = this;
          c = t;
          if (n) {
            if (a === undefined) {
              return g(c);
            }
            if (h) {
              clearTimeout(a);
              a = setTimeout(k, e);
              return f(c);
            }
          }
          if (a === undefined) {
            a = setTimeout(k, e);
          }
          return s;
        }
        v.cancel = w;
        v.flush = _;
        return v;
      }
      const qf = jf;
      class Wf extends ku {
        constructor(t) {
          super(t);
          this._fireSelectionChangeDoneDebounced = qf((t) => {
            this.document.fire('selectionChangeDone', t);
          }, 200);
        }
        observe() {
          const t = this.document;
          t.on(
            'arrowKey',
            (e, n) => {
              const i = t.selection;
              if (i.isFake && this.isEnabled) {
                n.preventDefault();
              }
            },
            { context: '$capture' }
          );
          t.on(
            'arrowKey',
            (e, n) => {
              const i = t.selection;
              if (i.isFake && this.isEnabled) {
                this._handleSelectionMove(n.keyCode);
              }
            },
            { priority: 'lowest' }
          );
        }
        destroy() {
          super.destroy();
          this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(t) {
          const e = this.document.selection;
          const n = new cd(e.getRanges(), {
            backward: e.isBackward,
            fake: false,
          });
          if (t == Ld.arrowleft || t == Ld.arrowup) {
            n.setTo(n.getFirstPosition());
          }
          if (t == Ld.arrowright || t == Ld.arrowdown) {
            n.setTo(n.getLastPosition());
          }
          const i = {
            oldSelection: e,
            newSelection: n,
            domSelection: null,
          };
          this.document.fire('selectionChange', i);
          this._fireSelectionChangeDoneDebounced(i);
        }
      }
      class Uf extends ku {
        constructor(t) {
          super(t);
          this.mutationObserver = t.getObserver(bf);
          this.selection = this.document.selection;
          this.domConverter = t.domConverter;
          this._documents = new WeakSet();
          this._fireSelectionChangeDoneDebounced = qf((t) => {
            this.document.fire('selectionChangeDone', t);
          }, 200);
          this._clearInfiniteLoopInterval = setInterval(
            () => this._clearInfiniteLoop(),
            1e3
          );
          this._documentIsSelectingInactivityTimeoutDebounced = qf(
            () => (this.document.isSelecting = false),
            5e3
          );
          this._loopbackCounter = 0;
        }
        observe(t) {
          const e = t.ownerDocument;
          const n = () => {
            this.document.isSelecting = true;
            this._documentIsSelectingInactivityTimeoutDebounced();
          };
          const i = () => {
            this.document.isSelecting = false;
            this._documentIsSelectingInactivityTimeoutDebounced.cancel();
          };
          this.listenTo(t, 'selectstart', n, { priority: 'highest' });
          this.listenTo(t, 'keydown', i, { priority: 'highest' });
          this.listenTo(t, 'keyup', i, { priority: 'highest' });
          if (this._documents.has(e)) {
            return;
          }
          this.listenTo(e, 'mouseup', i, { priority: 'highest' });
          this.listenTo(e, 'selectionchange', (t, n) => {
            this._handleSelectionChange(n, e);
            this._documentIsSelectingInactivityTimeoutDebounced();
          });
          this._documents.add(e);
        }
        destroy() {
          super.destroy();
          clearInterval(this._clearInfiniteLoopInterval);
          this._fireSelectionChangeDoneDebounced.cancel();
          this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        }
        _handleSelectionChange(t, e) {
          if (!this.isEnabled) {
            return;
          }
          const n = e.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
            return;
          }
          this.mutationObserver.flush();
          const i = this.domConverter.domSelectionToView(n);
          if (i.rangeCount == 0) {
            this.view.hasDomSelection = false;
            return;
          }
          this.view.hasDomSelection = true;
          if (
            this.selection.isEqual(i) &&
            this.domConverter.isDomSelectionCorrect(n)
          ) {
            return;
          }
          if (++this._loopbackCounter > 60) {
            return;
          }
          if (this.selection.isSimilar(i)) {
            this.view.forceRender();
          } else {
            const t = {
              oldSelection: this.selection,
              newSelection: i,
              domSelection: n,
            };
            this.document.fire('selectionChange', t);
            this._fireSelectionChangeDoneDebounced(t);
          }
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class Gf extends Af {
        constructor(t) {
          super(t);
          this.domEventType = ['focus', 'blur'];
          this.useCapture = true;
          const e = this.document;
          e.on('focus', () => {
            e.isFocused = true;
            this._renderTimeoutId = setTimeout(
              () => t.change(() => {}),
              50
            );
          });
          e.on('blur', (n, i) => {
            const o = e.selection.editableElement;
            if (o === null || o === i.target) {
              e.isFocused = false;
              t.change(() => {});
            }
          });
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
        destroy() {
          if (this._renderTimeoutId) {
            clearTimeout(this._renderTimeoutId);
          }
          super.destroy();
        }
      }
      class $f extends Af {
        constructor(t) {
          super(t);
          this.domEventType = [
            'compositionstart',
            'compositionupdate',
            'compositionend',
          ];
          const e = this.document;
          e.on('compositionstart', () => {
            e.isComposing = true;
          });
          e.on('compositionend', () => {
            e.isComposing = false;
          });
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class Kf extends Af {
        constructor(t) {
          super(t);
          this.domEventType = ['beforeinput'];
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class Zf {
        constructor() {
          this._replacedElements = [];
        }
        replace(t, e) {
          this._replacedElements.push({ element: t, newElement: e });
          t.style.display = 'none';
          if (e) {
            t.parentNode.insertBefore(e, t.nextSibling);
          }
        }
        restore() {
          this._replacedElements.forEach(
            ({ element: t, newElement: e }) => {
              t.style.display = '';
              if (e) {
                e.remove();
              }
            }
          );
          this._replacedElements = [];
        }
      }
      function Jf(t) {
        if (t instanceof HTMLTextAreaElement) {
          return t.value;
        }
        return t.innerHTML;
      }
      class Yf {
        constructor(t, e) {
          if (!Yf._observerInstance) {
            Yf._createObserver();
          }
          this._element = t;
          this._callback = e;
          Yf._addElementCallback(t, e);
          Yf._observerInstance.observe(t);
        }
        destroy() {
          Yf._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(t, e) {
          if (!Yf._elementCallbacks) {
            Yf._elementCallbacks = new Map();
          }
          let n = Yf._elementCallbacks.get(t);
          if (!n) {
            n = new Set();
            Yf._elementCallbacks.set(t, n);
          }
          n.add(e);
        }
        static _deleteElementCallback(t, e) {
          const n = Yf._getElementCallbacks(t);
          if (n) {
            n.delete(e);
            if (!n.size) {
              Yf._elementCallbacks.delete(t);
              Yf._observerInstance.unobserve(t);
            }
          }
          if (Yf._elementCallbacks && !Yf._elementCallbacks.size) {
            Yf._observerInstance = null;
            Yf._elementCallbacks = null;
          }
        }
        static _getElementCallbacks(t) {
          if (!Yf._elementCallbacks) {
            return null;
          }
          return Yf._elementCallbacks.get(t);
        }
        static _createObserver() {
          Yf._observerInstance = new Sa.window.ResizeObserver((t) => {
            for (const e of t) {
              const t = Yf._getElementCallbacks(e.target);
              if (t) {
                for (const n of t) {
                  n(e);
                }
              }
            }
          });
        }
      }
      Yf._observerInstance = null;
      Yf._elementCallbacks = null;
      function Qf(t) {
        return !!(t && t.getClientRects && t.getClientRects().length);
      }
      function Xf(t) {
        const e = t.next();
        if (e.done) {
          return null;
        }
        return e.value;
      }
      class tg extends uu(W) {
        constructor() {
          super();
          this.set('isFocused', false);
          this.set('focusedElement', null);
          this._elements = new Set();
          this._nextEventLoopTimeout = null;
        }
        add(t) {
          if (this._elements.has(t)) {
            throw new h(
              'focustracker-add-element-already-exist',
              this
            );
          }
          this.listenTo(t, 'focus', () => this._focus(t), {
            useCapture: true,
          });
          this.listenTo(t, 'blur', () => this._blur(), {
            useCapture: true,
          });
          this._elements.add(t);
        }
        remove(t) {
          if (t === this.focusedElement) {
            this._blur();
          }
          if (this._elements.has(t)) {
            this.stopListening(t);
            this._elements.delete(t);
          }
        }
        destroy() {
          this.stopListening();
        }
        _focus(t) {
          clearTimeout(this._nextEventLoopTimeout);
          this.focusedElement = t;
          this.isFocused = true;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout);
          this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null;
            this.isFocused = false;
          }, 0);
        }
      }
      class eg {
        constructor() {
          this._listener = Object.create(uu);
        }
        listenTo(t) {
          this._listener.listenTo(t, 'keydown', (t, e) => {
            this._listener.fire('_keydown:' + Hd(e), e);
          });
        }
        set(t, e, n = {}) {
          const i = jd(t);
          const o = n.priority;
          this._listener.listenTo(
            this._listener,
            '_keydown:' + i,
            (t, n) => {
              e(n, () => {
                n.preventDefault();
                n.stopPropagation();
                t.stop();
              });
              t.return = true;
            },
            { priority: o }
          );
        }
        press(t) {
          return !!this._listener.fire('_keydown:' + Hd(t), t);
        }
        destroy() {
          this._listener.stopListening();
        }
      }
      class ng extends ku {
        constructor(t) {
          super(t);
          this.document.on('keydown', (t, e) => {
            if (this.isEnabled && Wd(e.keyCode)) {
              const n = new dd(
                this.document,
                'arrowKey',
                this.document.selection.getFirstRange()
              );
              this.document.fire(n, e);
              if (n.stop.called) {
                t.stop();
              }
            }
          });
        }
        observe() {}
      }
      class ig extends ku {
        constructor(t) {
          super(t);
          const e = this.document;
          e.on('keydown', (t, n) => {
            if (!this.isEnabled || n.keyCode != Ld.tab || n.ctrlKey) {
              return;
            }
            const i = new dd(e, 'tab', e.selection.getFirstRange());
            e.fire(i, n);
            if (i.stop.called) {
              t.stop();
            }
          });
        }
        observe() {}
      }
      function og(t) {
        return Object.prototype.toString.apply(t) == '[object Range]';
      }
      function rg(t) {
        const e = t.ownerDocument.defaultView.getComputedStyle(t);
        return {
          top: parseInt(e.borderTopWidth, 10),
          right: parseInt(e.borderRightWidth, 10),
          bottom: parseInt(e.borderBottomWidth, 10),
          left: parseInt(e.borderLeftWidth, 10),
        };
      }
      const sg = [
        'top',
        'right',
        'bottom',
        'left',
        'width',
        'height',
      ];
      class ag {
        constructor(t) {
          const e = og(t);
          Object.defineProperty(this, '_source', {
            value: t._source || t,
            writable: true,
            enumerable: false,
          });
          if (dg(t) || e) {
            if (e) {
              const e = ag.getDomRangeRects(t);
              cg(this, ag.getBoundingRect(e));
            } else {
              cg(this, t.getBoundingClientRect());
            }
          } else if (hu(t)) {
            const { innerWidth: e, innerHeight: n } = t;
            cg(this, {
              top: 0,
              right: e,
              bottom: n,
              left: 0,
              width: e,
              height: n,
            });
          } else {
            cg(this, t);
          }
        }
        clone() {
          return new ag(this);
        }
        moveTo(t, e) {
          this.top = e;
          this.right = t + this.width;
          this.bottom = e + this.height;
          this.left = t;
          return this;
        }
        moveBy(t, e) {
          this.top += e;
          this.right += t;
          this.left += t;
          this.bottom += e;
          return this;
        }
        getIntersection(t) {
          const e = {
            top: Math.max(this.top, t.top),
            right: Math.min(this.right, t.right),
            bottom: Math.min(this.bottom, t.bottom),
            left: Math.max(this.left, t.left),
            width: 0,
            height: 0,
          };
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          if (e.width < 0 || e.height < 0) {
            return null;
          } else {
            return new ag(e);
          }
        }
        getIntersectionArea(t) {
          const e = this.getIntersection(t);
          if (e) {
            return e.getArea();
          } else {
            return 0;
          }
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const t = this._source;
          let e = this.clone();
          if (!lg(t)) {
            let n = t.parentNode || t.commonAncestorContainer;
            while (n && !lg(n)) {
              const t = new ag(n);
              const i = e.getIntersection(t);
              if (i) {
                if (i.getArea() < e.getArea()) {
                  e = i;
                }
              } else {
                return null;
              }
              n = n.parentNode;
            }
          }
          return e;
        }
        isEqual(t) {
          for (const e of sg) {
            if (this[e] !== t[e]) {
              return false;
            }
          }
          return true;
        }
        contains(t) {
          const e = this.getIntersection(t);
          return !!(e && e.isEqual(t));
        }
        excludeScrollbarsAndBorders() {
          const t = this._source;
          let e, n, i;
          if (hu(t)) {
            e = t.innerWidth - t.document.documentElement.clientWidth;
            n =
              t.innerHeight - t.document.documentElement.clientHeight;
            i = t.getComputedStyle(
              t.document.documentElement
            ).direction;
          } else {
            const o = rg(t);
            e = t.offsetWidth - t.clientWidth - o.left - o.right;
            n = t.offsetHeight - t.clientHeight - o.top - o.bottom;
            i =
              t.ownerDocument.defaultView.getComputedStyle(
                t
              ).direction;
            this.left += o.left;
            this.top += o.top;
            this.right -= o.right;
            this.bottom -= o.bottom;
            this.width = this.right - this.left;
            this.height = this.bottom - this.top;
          }
          this.width -= e;
          if (i === 'ltr') {
            this.right -= e;
          } else {
            this.left += e;
          }
          this.height -= n;
          this.bottom -= n;
          return this;
        }
        static getDomRangeRects(t) {
          const e = [];
          const n = Array.from(t.getClientRects());
          if (n.length) {
            for (const t of n) {
              e.push(new ag(t));
            }
          } else {
            let n = t.startContainer;
            if (ph(n)) {
              n = n.parentNode;
            }
            const i = new ag(n.getBoundingClientRect());
            i.right = i.left;
            i.width = 0;
            e.push(i);
          }
          return e;
        }
        static getBoundingRect(t) {
          const e = {
            left: Number.POSITIVE_INFINITY,
            top: Number.POSITIVE_INFINITY,
            right: Number.NEGATIVE_INFINITY,
            bottom: Number.NEGATIVE_INFINITY,
            width: 0,
            height: 0,
          };
          let n = 0;
          for (const i of t) {
            n++;
            e.left = Math.min(e.left, i.left);
            e.top = Math.min(e.top, i.top);
            e.right = Math.max(e.right, i.right);
            e.bottom = Math.max(e.bottom, i.bottom);
          }
          if (n == 0) {
            return null;
          }
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          return new ag(e);
        }
      }
      function cg(t, e) {
        for (const n of sg) {
          t[n] = e[n];
        }
      }
      function lg(t) {
        if (!dg(t)) {
          return false;
        }
        return t === t.ownerDocument.body;
      }
      function dg(t) {
        return wa(t);
      }
      function hg({ target: t, viewportOffset: e = 0 }) {
        const n = wg(t);
        let i = n;
        let o = null;
        while (i) {
          let r;
          if (i == n) {
            r = _g(t);
          } else {
            r = _g(o);
          }
          gg(r, () => vg(t, i));
          const s = vg(t, i);
          fg(i, s, e);
          if (i.parent != i) {
            o = i.frameElement;
            i = i.parent;
            if (!o) {
              return;
            }
          } else {
            i = null;
          }
        }
      }
      function ug(t) {
        const e = _g(t);
        gg(e, () => new Rect(t));
      }
      function fg(t, e, n) {
        const i = e.clone().moveBy(0, n);
        const o = e.clone().moveBy(0, -n);
        const r = new ag(t).excludeScrollbarsAndBorders();
        const s = [o, i];
        if (!s.every((t) => r.contains(t))) {
          let { scrollX: s, scrollY: a } = t;
          if (pg(o, r)) {
            a -= r.top - e.top + n;
          } else if (mg(i, r)) {
            a += e.bottom - r.bottom + n;
          }
          if (kg(e, r)) {
            s -= r.left - e.left + n;
          } else if (bg(e, r)) {
            s += e.right - r.right + n;
          }
          t.scrollTo(s, a);
        }
      }
      function gg(t, e) {
        const n = wg(t);
        let i, o;
        while (t != n.document.body) {
          o = e();
          i = new ag(t).excludeScrollbarsAndBorders();
          if (!i.contains(o)) {
            if (pg(o, i)) {
              t.scrollTop -= i.top - o.top;
            } else if (mg(o, i)) {
              t.scrollTop += o.bottom - i.bottom;
            }
            if (kg(o, i)) {
              t.scrollLeft -= i.left - o.left;
            } else if (bg(o, i)) {
              t.scrollLeft += o.right - i.right;
            }
          }
          t = t.parentNode;
        }
      }
      function mg(t, e) {
        return t.bottom > e.bottom;
      }
      function pg(t, e) {
        return t.top < e.top;
      }
      function kg(t, e) {
        return t.left < e.left;
      }
      function bg(t, e) {
        return t.right > e.right;
      }
      function wg(t) {
        if (og(t)) {
          return t.startContainer.ownerDocument.defaultView;
        } else {
          return t.ownerDocument.defaultView;
        }
      }
      function _g(t) {
        if (og(t)) {
          let e = t.commonAncestorContainer;
          if (ph(e)) {
            e = e.parentNode;
          }
          return e;
        } else {
          return t.parentNode;
        }
      }
      function vg(t, e) {
        const n = wg(t);
        const i = new ag(t);
        if (n === e) {
          return i;
        } else {
          let t = n;
          while (t != e) {
            const e = t.frameElement;
            const n = new ag(e).excludeScrollbarsAndBorders();
            i.moveBy(n.left, n.top);
            t = t.parent;
          }
        }
        return i;
      }
      class Ag extends W {
        constructor(t) {
          super();
          this.document = new bd(t);
          this.domConverter = new ru(this.document);
          this.domRoots = new Map();
          this.set('isRenderingInProgress', false);
          this.set('hasDomSelection', false);
          this._renderer = new Wh(
            this.domConverter,
            this.document.selection
          );
          this._renderer
            .bind('isFocused', 'isSelecting')
            .to(this.document, 'isFocused', 'isSelecting');
          this._initialDomRootAttributes = new WeakMap();
          this._observers = new Map();
          this._ongoingChange = false;
          this._postFixersInProgress = false;
          this._renderingDisabled = false;
          this._hasChangedSinceTheLastRendering = false;
          this._writer = new oh(this.document);
          this.addObserver(bf);
          this.addObserver(Uf);
          this.addObserver(Gf);
          this.addObserver(Cf);
          this.addObserver(Wf);
          this.addObserver($f);
          this.addObserver(ng);
          this.addObserver(ig);
          if (Sd.isAndroid) {
            this.addObserver(Kf);
          }
          xh(this);
          Yd(this);
          this.on('render', () => {
            this._render();
            this.document.fire('layoutChanged');
            this._hasChangedSinceTheLastRendering = false;
          });
          this.listenTo(this.document.selection, 'change', () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          this.listenTo(this.document, 'change:isFocused', () => {
            this._hasChangedSinceTheLastRendering = true;
          });
        }
        attachDomRoot(t, e = 'main') {
          const n = this.document.getRoot(e);
          n._name = t.tagName.toLowerCase();
          const i = {};
          for (const { name: e, value: o } of Array.from(
            t.attributes
          )) {
            i[e] = o;
            if (e === 'class') {
              this._writer.addClass(o.split(' '), n);
            } else {
              this._writer.setAttribute(e, o, n);
            }
          }
          this._initialDomRootAttributes.set(t, i);
          const o = () => {
            this._writer.setAttribute(
              'contenteditable',
              (!n.isReadOnly).toString(),
              n
            );
            if (n.isReadOnly) {
              this._writer.addClass('ck-read-only', n);
            } else {
              this._writer.removeClass('ck-read-only', n);
            }
          };
          o();
          this.domRoots.set(e, t);
          this.domConverter.bindElements(t, n);
          this._renderer.markToSync('children', n);
          this._renderer.markToSync('attributes', n);
          this._renderer.domDocuments.add(t.ownerDocument);
          n.on('change:children', (t, e) =>
            this._renderer.markToSync('children', e)
          );
          n.on('change:attributes', (t, e) =>
            this._renderer.markToSync('attributes', e)
          );
          n.on('change:text', (t, e) =>
            this._renderer.markToSync('text', e)
          );
          n.on('change:isReadOnly', () => this.change(o));
          n.on('change', () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          for (const n of this._observers.values()) {
            n.observe(t, e);
          }
        }
        detachDomRoot(t) {
          const e = this.domRoots.get(t);
          Array.from(e.attributes).forEach(({ name: t }) =>
            e.removeAttribute(t)
          );
          const n = this._initialDomRootAttributes.get(e);
          for (const t in n) {
            e.setAttribute(t, n[t]);
          }
          this.domRoots.delete(t);
          this.domConverter.unbindDomElement(e);
        }
        getDomRoot(t = 'main') {
          return this.domRoots.get(t);
        }
        addObserver(t) {
          let e = this._observers.get(t);
          if (e) {
            return e;
          }
          e = new t(this);
          this._observers.set(t, e);
          for (const [t, n] of this.domRoots) {
            e.observe(n, t);
          }
          e.enable();
          return e;
        }
        getObserver(t) {
          return this._observers.get(t);
        }
        disableObservers() {
          for (const t of this._observers.values()) {
            t.disable();
          }
        }
        enableObservers() {
          for (const t of this._observers.values()) {
            t.enable();
          }
        }
        scrollToTheSelection() {
          const t = this.document.selection.getFirstRange();
          if (t) {
            hg({
              target: this.domConverter.viewRangeToDom(t),
              viewportOffset: 20,
            });
          }
        }
        focus() {
          if (!this.document.isFocused) {
            const t = this.document.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
              this.forceRender();
            } else {
            }
          }
        }
        change(t) {
          if (
            this.isRenderingInProgress ||
            this._postFixersInProgress
          ) {
            throw new h('cannot-change-view-tree', this);
          }
          try {
            if (this._ongoingChange) {
              return t(this._writer);
            }
            this._ongoingChange = true;
            const e = t(this._writer);
            this._ongoingChange = false;
            if (
              !this._renderingDisabled &&
              this._hasChangedSinceTheLastRendering
            ) {
              this._postFixersInProgress = true;
              this.document._callPostFixers(this._writer);
              this._postFixersInProgress = false;
              this.fire('render');
            }
            return e;
          } catch (t) {
            h.rethrowUnexpectedError(t, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true;
          this.change(() => {});
        }
        destroy() {
          for (const t of this._observers.values()) {
            t.destroy();
          }
          this.document.destroy();
          this.stopListening();
        }
        createPositionAt(t, e) {
          return od._createAt(t, e);
        }
        createPositionAfter(t) {
          return od._createAfter(t);
        }
        createPositionBefore(t) {
          return od._createBefore(t);
        }
        createRange(...t) {
          return new rd(...t);
        }
        createRangeOn(t) {
          return rd._createOn(t);
        }
        createRangeIn(t) {
          return rd._createIn(t);
        }
        createSelection(...t) {
          return new cd(...t);
        }
        _disableRendering(t) {
          this._renderingDisabled = t;
          if (t == false) {
            this.change(() => {});
          }
        }
        _render() {
          this.isRenderingInProgress = true;
          this.disableObservers();
          this._renderer.render();
          this.enableObservers();
          this.isRenderingInProgress = false;
        }
      }
      class Cg {
        is() {
          throw new Error('is() method is abstract');
        }
      }
      class yg extends Cg {
        constructor(t) {
          super();
          this.parent = null;
          this._attrs = Za(t);
        }
        get document() {
          return null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) === null) {
            throw new h('model-node-not-found-in-parent', this);
          }
          return t;
        }
        get startOffset() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildStartOffset(this)) === null) {
            throw new h('model-node-not-found-in-parent', this);
          }
          return t;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          if (!this.parent) {
            return null;
          }
          return this.startOffset + this.offsetSize;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.root.is('rootElement');
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.startOffset);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const i = t.getAncestors(e);
          let o = 0;
          while (n[o] == i[o] && n[o]) {
            o++;
          }
          return o === 0 ? null : n[o - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const i = Ha(e, n);
          switch (i) {
            case 'prefix':
              return true;
            case 'extension':
              return false;
            default:
              return e[i] < n[i];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const t = {};
          if (this._attrs.size) {
            t.attributes = Array.from(this._attrs).reduce((t, e) => {
              t[e[0]] = e[1];
              return t;
            }, {});
          }
          return t;
        }
        _clone(t) {
          return new yg(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(t, e) {
          this._attrs.set(t, e);
        }
        _setAttributesTo(t) {
          this._attrs = Za(t);
        }
        _removeAttribute(t) {
          return this._attrs.delete(t);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      yg.prototype.is = function (t) {
        return t === 'node' || t === 'model:node';
      };
      class xg {
        constructor(t) {
          this._nodes = [];
          if (t) {
            this._insertNodes(0, t);
          }
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
        }
        getNode(t) {
          return this._nodes[t] || null;
        }
        getNodeIndex(t) {
          const e = this._nodes.indexOf(t);
          return e == -1 ? null : e;
        }
        getNodeStartOffset(t) {
          const e = this.getNodeIndex(t);
          return e === null
            ? null
            : this._nodes
                .slice(0, e)
                .reduce((t, e) => t + e.offsetSize, 0);
        }
        indexToOffset(t) {
          if (t == this._nodes.length) {
            return this.maxOffset;
          }
          const e = this._nodes[t];
          if (!e) {
            throw new h('model-nodelist-index-out-of-bounds', this);
          }
          return this.getNodeStartOffset(e);
        }
        offsetToIndex(t) {
          let e = 0;
          for (const n of this._nodes) {
            if (t >= e && t < e + n.offsetSize) {
              return this.getNodeIndex(n);
            }
            e += n.offsetSize;
          }
          if (e != t) {
            throw new h('model-nodelist-offset-out-of-bounds', this, {
              offset: t,
              nodeList: this,
            });
          }
          return this.length;
        }
        _insertNodes(t, e) {
          for (const t of e) {
            if (!(t instanceof yg)) {
              throw new h(
                'model-nodelist-insertnodes-not-node',
                this
              );
            }
          }
          this._nodes.splice(t, 0, ...e);
        }
        _removeNodes(t, e = 1) {
          return this._nodes.splice(t, e);
        }
        toJSON() {
          return this._nodes.map((t) => t.toJSON());
        }
      }
      class Eg extends yg {
        constructor(t, e) {
          super(e);
          this._data = t || '';
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        toJSON() {
          const t = super.toJSON();
          t.data = this.data;
          return t;
        }
        _clone() {
          return new Eg(this.data, this.getAttributes());
        }
        static fromJSON(t) {
          return new Eg(t.data, t.attributes);
        }
      }
      Eg.prototype.is = function (t) {
        return (
          t === '$text' ||
          t === 'model:$text' ||
          t === 'text' ||
          t === 'model:text' ||
          t === 'node' ||
          t === 'model:node'
        );
      };
      class Dg extends Cg {
        constructor(t, e, n) {
          super();
          this.textNode = t;
          if (e < 0 || e > t.offsetSize) {
            throw new h('model-textproxy-wrong-offsetintext', this);
          }
          if (n < 0 || e + n > t.offsetSize) {
            throw new h('model-textproxy-wrong-length', this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get startOffset() {
          return this.textNode.startOffset !== null
            ? this.textNode.startOffset + this.offsetInText
            : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null
            ? this.startOffset + this.offsetSize
            : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        getPath() {
          const t = this.textNode.getPath();
          if (t.length > 0) {
            t[t.length - 1] += this.offsetInText;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n);
            n = n.parent;
          }
          return e;
        }
        hasAttribute(t) {
          return this.textNode.hasAttribute(t);
        }
        getAttribute(t) {
          return this.textNode.getAttribute(t);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      Dg.prototype.is = function (t) {
        return (
          t === '$textProxy' ||
          t === 'model:$textProxy' ||
          t === 'textProxy' ||
          t === 'model:textProxy'
        );
      };
      class Sg extends yg {
        constructor(t, e, n) {
          super(e);
          this.name = t;
          this._children = new xg();
          if (n) {
            this._insertChild(0, n);
          }
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        findAncestor(t, e = {}) {
          let n = e.includeSelf ? this : this.parent;
          while (n) {
            if (n.name === t) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        toJSON() {
          const t = super.toJSON();
          t.name = this.name;
          if (this._children.length > 0) {
            t.children = [];
            for (const e of this._children) {
              t.children.push(e.toJSON());
            }
          }
          return t;
        }
        _clone(t = false) {
          const e = t
            ? Array.from(this._children).map((t) => t._clone(true))
            : undefined;
          return new Sg(this.name, this.getAttributes(), e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = Tg(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
        static fromJSON(t) {
          let e;
          if (t.children) {
            e = [];
            for (const n of t.children) {
              if (n.name) {
                e.push(Sg.fromJSON(n));
              } else {
                e.push(Eg.fromJSON(n));
              }
            }
          }
          return new Sg(t.name, t.attributes, e);
        }
      }
      Sg.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'element' ||
            t === 'model:element' ||
            t === 'node' ||
            t === 'model:node'
          );
        }
        return (
          e === this.name &&
          (t === 'element' || t === 'model:element')
        );
      };
      function Tg(t) {
        if (typeof t == 'string') {
          return [new Eg(t)];
        }
        if (!Ca(t)) {
          t = [t];
        }
        return Array.from(t).map((t) => {
          if (typeof t == 'string') {
            return new Eg(t);
          }
          if (t instanceof Dg) {
            return new Eg(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class Bg {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new h('model-tree-walker-no-start-position', null);
          }
          const e = t.direction || 'forward';
          if (e != 'forward' && e != 'backward') {
            throw new h('model-tree-walker-unknown-direction', t, {
              direction: e,
            });
          }
          this.direction = e;
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this.position = t.startPosition.clone();
          } else {
            this.position = Ig._createAt(
              this.boundaries[
                this.direction == 'backward' ? 'end' : 'start'
              ]
            );
          }
          this.position.stickiness = 'toNone';
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null;
          this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null;
          this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        skip(t) {
          let e, n, i, o;
          do {
            i = this.position;
            o = this._visitedParent;
            ({ done: e, value: n } = this.next());
          } while (!e && t(n));
          if (!e) {
            this.position = i;
            this._visitedParent = o;
          }
        }
        next() {
          if (this.direction == 'forward') {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === n.maxOffset) {
            return { done: true, value: undefined };
          }
          if (
            n === this._boundaryEndParent &&
            e.offset == this.boundaries.end.offset
          ) {
            return { done: true, value: undefined };
          }
          const i = Rg(e, n);
          const o = i ? i : zg(e, n, i);
          if (o instanceof Sg) {
            if (!this.shallow) {
              e.path.push(0);
              this._visitedParent = o;
            } else {
              e.offset++;
            }
            this.position = e;
            return Pg('elementStart', o, t, e, 1);
          } else if (o instanceof Eg) {
            let i;
            if (this.singleCharacters) {
              i = 1;
            } else {
              let t = o.endOffset;
              if (
                this._boundaryEndParent == n &&
                this.boundaries.end.offset < t
              ) {
                t = this.boundaries.end.offset;
              }
              i = t - e.offset;
            }
            const r = e.offset - o.startOffset;
            const s = new Dg(o, r, i);
            e.offset += i;
            this.position = e;
            return Pg('text', s, t, e, i);
          } else {
            e.path.pop();
            e.offset++;
            this.position = e;
            this._visitedParent = n.parent;
            if (this.ignoreElementEnd) {
              return this._next();
            } else {
              return Pg('elementEnd', n, t, e);
            }
          }
        }
        _previous() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === 0) {
            return { done: true, value: undefined };
          }
          if (
            n == this._boundaryStartParent &&
            e.offset == this.boundaries.start.offset
          ) {
            return { done: true, value: undefined };
          }
          const i = e.parent;
          const o = Rg(e, i);
          const r = o ? o : Og(e, i, o);
          if (r instanceof Sg) {
            e.offset--;
            if (!this.shallow) {
              e.path.push(r.maxOffset);
              this.position = e;
              this._visitedParent = r;
              if (this.ignoreElementEnd) {
                return this._previous();
              } else {
                return Pg('elementEnd', r, t, e);
              }
            } else {
              this.position = e;
              return Pg('elementStart', r, t, e, 1);
            }
          } else if (r instanceof Eg) {
            let i;
            if (this.singleCharacters) {
              i = 1;
            } else {
              let t = r.startOffset;
              if (
                this._boundaryStartParent == n &&
                this.boundaries.start.offset > t
              ) {
                t = this.boundaries.start.offset;
              }
              i = e.offset - t;
            }
            const o = e.offset - r.startOffset;
            const s = new Dg(r, o - i, i);
            e.offset -= i;
            this.position = e;
            return Pg('text', s, t, e, i);
          } else {
            e.path.pop();
            this.position = e;
            this._visitedParent = n.parent;
            return Pg('elementStart', n, t, e, 1);
          }
        }
      }
      function Pg(t, e, n, i, o) {
        return {
          done: false,
          value: {
            type: t,
            item: e,
            previousPosition: n,
            nextPosition: i,
            length: o,
          },
        };
      }
      class Ig extends Cg {
        constructor(t, e, n = 'toNone') {
          super();
          if (!t.is('element') && !t.is('documentFragment')) {
            throw new h('model-position-root-invalid', t);
          }
          if (!(e instanceof Array) || e.length === 0) {
            throw new h('model-position-path-incorrect-format', t, {
              path: e,
            });
          }
          if (t.is('rootElement')) {
            e = e.slice();
          } else {
            e = [...t.getPath(), ...e];
            t = t.root;
          }
          this.root = t;
          this.path = e;
          this.stickiness = n;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(t) {
          this.path[this.path.length - 1] = t;
        }
        get parent() {
          let t = this.root;
          for (let e = 0; e < this.path.length - 1; e++) {
            t = t.getChild(t.offsetToIndex(this.path[e]));
            if (!t) {
              throw new h('model-position-path-incorrect', this, {
                position: this,
              });
            }
          }
          if (t.is('$text')) {
            throw new h('model-position-path-incorrect', this, {
              position: this,
            });
          }
          return t;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Rg(this, this.parent);
        }
        get nodeAfter() {
          const t = this.parent;
          return zg(this, t, Rg(this, t));
        }
        get nodeBefore() {
          const t = this.parent;
          return Og(this, t, Rg(this, t));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(t) {
          if (this.root != t.root) {
            return 'different';
          }
          const e = Ha(this.path, t.path);
          switch (e) {
            case 'same':
              return 'same';
            case 'prefix':
              return 'before';
            case 'extension':
              return 'after';
            default:
              return this.path[e] < t.path[e] ? 'before' : 'after';
          }
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new Bg(e);
          n.skip(t);
          return n.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const t = this.parent;
          if (t.is('documentFragment')) {
            return [t];
          } else {
            return t.getAncestors({ includeSelf: true });
          }
        }
        findAncestor(t) {
          const e = this.parent;
          if (e.is('element')) {
            return e.findAncestor(t, { includeSelf: true });
          }
          return null;
        }
        getCommonPath(t) {
          if (this.root != t.root) {
            return [];
          }
          const e = Ha(this.path, t.path);
          const n =
            typeof e == 'string'
              ? Math.min(this.path.length, t.path.length)
              : e;
          return this.path.slice(0, n);
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let i = 0;
          while (e[i] == n[i] && e[i]) {
            i++;
          }
          return i === 0 ? null : e[i - 1];
        }
        getShiftedBy(t) {
          const e = this.clone();
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        isAfter(t) {
          return this.compareWith(t) == 'after';
        }
        isBefore(t) {
          return this.compareWith(t) == 'before';
        }
        isEqual(t) {
          return this.compareWith(t) == 'same';
        }
        isTouching(t) {
          let e = null;
          let n = null;
          const i = this.compareWith(t);
          switch (i) {
            case 'same':
              return true;
            case 'before':
              e = Ig._createAt(this);
              n = Ig._createAt(t);
              break;
            case 'after':
              e = Ig._createAt(t);
              n = Ig._createAt(this);
              break;
            default:
              return false;
          }
          let o = e.parent;
          while (e.path.length + n.path.length) {
            if (e.isEqual(n)) {
              return true;
            }
            if (e.path.length > n.path.length) {
              if (e.offset !== o.maxOffset) {
                return false;
              }
              e.path = e.path.slice(0, -1);
              o = o.parent;
              e.offset++;
            } else {
              if (n.offset !== 0) {
                return false;
              }
              n.path = n.path.slice(0, -1);
            }
          }
          throw new Error('unreachable code');
        }
        hasSameParentAs(t) {
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getParentPath();
          const n = t.getParentPath();
          return Ha(e, n) == 'same';
        }
        getTransformedByOperation(t) {
          let e;
          switch (t.type) {
            case 'insert':
              e = this._getTransformedByInsertOperation(t);
              break;
            case 'move':
            case 'remove':
            case 'reinsert':
              e = this._getTransformedByMoveOperation(t);
              break;
            case 'split':
              e = this._getTransformedBySplitOperation(t);
              break;
            case 'merge':
              e = this._getTransformedByMergeOperation(t);
              break;
            default:
              e = Ig._createAt(this);
              break;
          }
          return e;
        }
        _getTransformedByInsertOperation(t) {
          return this._getTransformedByInsertion(
            t.position,
            t.howMany
          );
        }
        _getTransformedByMoveOperation(t) {
          return this._getTransformedByMove(
            t.sourcePosition,
            t.targetPosition,
            t.howMany
          );
        }
        _getTransformedBySplitOperation(t) {
          const e = t.movedRange;
          const n =
            e.containsPosition(this) ||
            (e.start.isEqual(this) && this.stickiness == 'toNext');
          if (n) {
            return this._getCombined(
              t.splitPosition,
              t.moveTargetPosition
            );
          } else {
            if (t.graveyardPosition) {
              return this._getTransformedByMove(
                t.graveyardPosition,
                t.insertionPosition,
                1
              );
            } else {
              return this._getTransformedByInsertion(
                t.insertionPosition,
                1
              );
            }
          }
        }
        _getTransformedByMergeOperation(t) {
          const e = t.movedRange;
          const n = e.containsPosition(this) || e.start.isEqual(this);
          let i;
          if (n) {
            i = this._getCombined(t.sourcePosition, t.targetPosition);
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              i = i._getTransformedByDeletion(t.deletionPosition, 1);
            }
          } else if (this.isEqual(t.deletionPosition)) {
            i = Ig._createAt(t.deletionPosition);
          } else {
            i = this._getTransformedByMove(
              t.deletionPosition,
              t.graveyardPosition,
              1
            );
          }
          return i;
        }
        _getTransformedByDeletion(t, e) {
          const n = Ig._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (Ha(t.getParentPath(), this.getParentPath()) == 'same') {
            if (t.offset < this.offset) {
              if (t.offset + e > this.offset) {
                return null;
              } else {
                n.offset -= e;
              }
            }
          } else if (
            Ha(t.getParentPath(), this.getParentPath()) == 'prefix'
          ) {
            const i = t.path.length - 1;
            if (t.offset <= this.path[i]) {
              if (t.offset + e > this.path[i]) {
                return null;
              } else {
                n.path[i] -= e;
              }
            }
          }
          return n;
        }
        _getTransformedByInsertion(t, e) {
          const n = Ig._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (Ha(t.getParentPath(), this.getParentPath()) == 'same') {
            if (
              t.offset < this.offset ||
              (t.offset == this.offset &&
                this.stickiness != 'toPrevious')
            ) {
              n.offset += e;
            }
          } else if (
            Ha(t.getParentPath(), this.getParentPath()) == 'prefix'
          ) {
            const i = t.path.length - 1;
            if (t.offset <= this.path[i]) {
              n.path[i] += e;
            }
          }
          return n;
        }
        _getTransformedByMove(t, e, n) {
          e = e._getTransformedByDeletion(t, n);
          if (t.isEqual(e)) {
            return Ig._createAt(this);
          }
          const i = this._getTransformedByDeletion(t, n);
          const o =
            i === null ||
            (t.isEqual(this) && this.stickiness == 'toNext') ||
            (t.getShiftedBy(n).isEqual(this) &&
              this.stickiness == 'toPrevious');
          if (o) {
            return this._getCombined(t, e);
          } else {
            return i._getTransformedByInsertion(e, n);
          }
        }
        _getCombined(t, e) {
          const n = t.path.length - 1;
          const i = Ig._createAt(e);
          i.stickiness = this.stickiness;
          i.offset = i.offset + this.path[n] - t.offset;
          i.path = [...i.path, ...this.path.slice(n + 1)];
          return i;
        }
        toJSON() {
          return {
            root: this.root.toJSON(),
            path: Array.from(this.path),
            stickiness: this.stickiness,
          };
        }
        clone() {
          return new this.constructor(
            this.root,
            this.path,
            this.stickiness
          );
        }
        static _createAt(t, e, n = 'toNone') {
          if (t instanceof Ig) {
            return new Ig(t.root, t.path, t.stickiness);
          } else {
            const i = t;
            if (e == 'end') {
              e = i.maxOffset;
            } else if (e == 'before') {
              return this._createBefore(i, n);
            } else if (e == 'after') {
              return this._createAfter(i, n);
            } else if (e !== 0 && !e) {
              throw new h('model-createpositionat-offset-required', [
                this,
                t,
              ]);
            }
            if (!i.is('element') && !i.is('documentFragment')) {
              throw new h('model-position-parent-incorrect', [
                this,
                t,
              ]);
            }
            const o = i.getPath();
            o.push(e);
            return new this(i.root, o, n);
          }
        }
        static _createAfter(t, e) {
          if (!t.parent) {
            throw new h('model-position-after-root', [this, t], {
              root: t,
            });
          }
          return this._createAt(t.parent, t.endOffset, e);
        }
        static _createBefore(t, e) {
          if (!t.parent) {
            throw new h('model-position-before-root', t, { root: t });
          }
          return this._createAt(t.parent, t.startOffset, e);
        }
        static fromJSON(t, e) {
          if (t.root === '$graveyard') {
            const n = new Ig(e.graveyard, t.path);
            n.stickiness = t.stickiness;
            return n;
          }
          if (!e.getRoot(t.root)) {
            throw new h('model-position-fromjson-no-root', e, {
              rootName: t.root,
            });
          }
          return new Ig(e.getRoot(t.root), t.path, t.stickiness);
        }
      }
      Ig.prototype.is = function (t) {
        return t === 'position' || t === 'model:position';
      };
      function Rg(t, e) {
        const n = e.getChild(e.offsetToIndex(t.offset));
        if (n && n.is('$text') && n.startOffset < t.offset) {
          return n;
        }
        return null;
      }
      function zg(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset));
      }
      function Og(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset) - 1);
      }
      class Fg extends Cg {
        constructor(t, e) {
          super();
          this.start = Ig._createAt(t);
          this.end = e ? Ig._createAt(e) : Ig._createAt(t);
          this.start.stickiness = this.isCollapsed
            ? 'toNone'
            : 'toNext';
          this.end.stickiness = this.isCollapsed
            ? 'toNone'
            : 'toPrevious';
        }
        *[Symbol.iterator]() {
          yield* new Bg({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          const t = this.start.getParentPath();
          const e = this.end.getParentPath();
          return Ha(t, e) == 'same';
        }
        get root() {
          return this.start.root;
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start));
          const i =
            this.containsPosition(t.end) ||
            (e && this.end.isEqual(t.end));
          return n && i;
        }
        containsItem(t) {
          const e = Ig._createBefore(t);
          return this.containsPosition(e) || this.start.isEqual(e);
        }
        isEqual(t) {
          return (
            this.start.isEqual(t.start) && this.end.isEqual(t.end)
          );
        }
        isIntersecting(t) {
          return (
            this.start.isBefore(t.end) && this.end.isAfter(t.start)
          );
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new Fg(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new Fg(t.end, this.end));
            }
          } else {
            e.push(new Fg(this.start, this.end));
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new Fg(e, n);
          }
          return null;
        }
        getJoined(t, e = false) {
          let n = this.isIntersecting(t);
          if (!n) {
            if (this.start.isBefore(t.start)) {
              n = e
                ? this.end.isTouching(t.start)
                : this.end.isEqual(t.start);
            } else {
              n = e
                ? t.end.isTouching(this.start)
                : t.end.isEqual(this.start);
            }
          }
          if (!n) {
            return null;
          }
          let i = this.start;
          let o = this.end;
          if (t.start.isBefore(i)) {
            i = t.start;
          }
          if (t.end.isAfter(o)) {
            o = t.end;
          }
          return new Fg(i, o);
        }
        getMinimalFlatRanges() {
          const t = [];
          const e = this.start.getCommonPath(this.end).length;
          const n = Ig._createAt(this.start);
          let i = n.parent;
          while (n.path.length > e + 1) {
            const e = i.maxOffset - n.offset;
            if (e !== 0) {
              t.push(new Fg(n, n.getShiftedBy(e)));
            }
            n.path = n.path.slice(0, -1);
            n.offset++;
            i = i.parent;
          }
          while (n.path.length <= this.end.path.length) {
            const e = this.end.path[n.path.length - 1];
            const i = e - n.offset;
            if (i !== 0) {
              t.push(new Fg(n, n.getShiftedBy(i)));
            }
            n.offset = e;
            n.path.push(0);
          }
          return t;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new Bg(t);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new Bg(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new Bg(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        getTransformedByOperation(t) {
          switch (t.type) {
            case 'insert':
              return this._getTransformedByInsertOperation(t);
            case 'move':
            case 'remove':
            case 'reinsert':
              return this._getTransformedByMoveOperation(t);
            case 'split':
              return [this._getTransformedBySplitOperation(t)];
            case 'merge':
              return [this._getTransformedByMergeOperation(t)];
          }
          return [new Fg(this.start, this.end)];
        }
        getTransformedByOperations(t) {
          const e = [new Fg(this.start, this.end)];
          for (const n of t) {
            for (let t = 0; t < e.length; t++) {
              const i = e[t].getTransformedByOperation(n);
              e.splice(t, 1, ...i);
              t += i.length - 1;
            }
          }
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            for (let i = t + 1; i < e.length; i++) {
              const t = e[i];
              if (
                n.containsRange(t) ||
                t.containsRange(n) ||
                n.isEqual(t)
              ) {
                e.splice(i, 1);
              }
            }
          }
          return e;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          const t = this.start.nodeAfter;
          const e = this.end.nodeBefore;
          if (t && t.is('element') && t === e) {
            return t;
          }
          return null;
        }
        toJSON() {
          return {
            start: this.start.toJSON(),
            end: this.end.toJSON(),
          };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(t, e = false) {
          return this._getTransformedByInsertion(
            t.position,
            t.howMany,
            e
          );
        }
        _getTransformedByMoveOperation(t, e = false) {
          const n = t.sourcePosition;
          const i = t.howMany;
          const o = t.targetPosition;
          return this._getTransformedByMove(n, o, i, e);
        }
        _getTransformedBySplitOperation(t) {
          const e = this.start._getTransformedBySplitOperation(t);
          let n = this.end._getTransformedBySplitOperation(t);
          if (this.end.isEqual(t.insertionPosition)) {
            n = this.end.getShiftedBy(1);
          }
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          return new Fg(e, n);
        }
        _getTransformedByMergeOperation(t) {
          if (
            this.start.isEqual(t.targetPosition) &&
            this.end.isEqual(t.deletionPosition)
          ) {
            return new Fg(this.start);
          }
          let e = this.start._getTransformedByMergeOperation(t);
          let n = this.end._getTransformedByMergeOperation(t);
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          if (e.isAfter(n)) {
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              e = Ig._createAt(n);
              e.offset = 0;
            } else {
              if (!t.deletionPosition.isEqual(e)) {
                n = t.deletionPosition;
              }
              e = t.targetPosition;
            }
            return new Fg(e, n);
          }
          return new Fg(e, n);
        }
        _getTransformedByInsertion(t, e, n = false) {
          if (n && this.containsPosition(t)) {
            return [
              new Fg(this.start, t),
              new Fg(
                t.getShiftedBy(e),
                this.end._getTransformedByInsertion(t, e)
              ),
            ];
          } else {
            const n = new Fg(this.start, this.end);
            n.start = n.start._getTransformedByInsertion(t, e);
            n.end = n.end._getTransformedByInsertion(t, e);
            return [n];
          }
        }
        _getTransformedByMove(t, e, n, i = false) {
          if (this.isCollapsed) {
            const i = this.start._getTransformedByMove(t, e, n);
            return [new Fg(i)];
          }
          const o = Fg._createFromPositionAndShift(t, n);
          const r = e._getTransformedByDeletion(t, n);
          if (this.containsPosition(e) && !i) {
            if (
              o.containsPosition(this.start) ||
              o.containsPosition(this.end)
            ) {
              const i = this.start._getTransformedByMove(t, e, n);
              const o = this.end._getTransformedByMove(t, e, n);
              return [new Fg(i, o)];
            }
          }
          let s;
          const a = this.getDifference(o);
          let c = null;
          const l = this.getIntersection(o);
          if (a.length == 1) {
            c = new Fg(
              a[0].start._getTransformedByDeletion(t, n),
              a[0].end._getTransformedByDeletion(t, n)
            );
          } else if (a.length == 2) {
            c = new Fg(
              this.start,
              this.end._getTransformedByDeletion(t, n)
            );
          }
          if (c) {
            s = c._getTransformedByInsertion(r, n, l !== null || i);
          } else {
            s = [];
          }
          if (l) {
            const t = new Fg(
              l.start._getCombined(o.start, r),
              l.end._getCombined(o.start, r)
            );
            if (s.length == 2) {
              s.splice(1, 0, t);
            } else {
              s.push(t);
            }
          }
          return s;
        }
        _getTransformedByDeletion(t, e) {
          let n = this.start._getTransformedByDeletion(t, e);
          let i = this.end._getTransformedByDeletion(t, e);
          if (n == null && i == null) {
            return null;
          }
          if (n == null) {
            n = t;
          }
          if (i == null) {
            i = t;
          }
          return new Fg(n, i);
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const i = t.getShiftedBy(e);
          return e > 0 ? new this(n, i) : new this(i, n);
        }
        static _createIn(t) {
          return new this(
            Ig._createAt(t, 0),
            Ig._createAt(t, t.maxOffset)
          );
        }
        static _createOn(t) {
          return this._createFromPositionAndShift(
            Ig._createBefore(t),
            t.offsetSize
          );
        }
        static _createFromRanges(t) {
          if (t.length === 0) {
            throw new h('range-create-from-ranges-empty-array', null);
          } else if (t.length == 1) {
            return t[0].clone();
          }
          const e = t[0];
          t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
          const n = t.indexOf(e);
          const i = new this(e.start, e.end);
          if (n > 0) {
            for (let e = n - 1; true; e++) {
              if (t[e].end.isEqual(i.start)) {
                i.start = Ig._createAt(t[e].start);
              } else {
                break;
              }
            }
          }
          for (let e = n + 1; e < t.length; e++) {
            if (t[e].start.isEqual(i.end)) {
              i.end = Ig._createAt(t[e].end);
            } else {
              break;
            }
          }
          return i;
        }
        static fromJSON(t, e) {
          return new this(
            Ig.fromJSON(t.start, e),
            Ig.fromJSON(t.end, e)
          );
        }
      }
      Fg.prototype.is = function (t) {
        return t === 'range' || t === 'model:range';
      };
      class Ng extends y {
        constructor() {
          super();
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._viewToModelLengthCallbacks = new Map();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._deferredBindingRemovals = new Map();
          this._unboundMarkerNames = new Set();
          this.on(
            'modelToViewPosition',
            (t, e) => {
              if (e.viewPosition) {
                return;
              }
              const n = this._modelToViewMapping.get(
                e.modelPosition.parent
              );
              if (!n) {
                throw new h(
                  'mapping-model-position-view-parent-not-found',
                  this,
                  { modelPosition: e.modelPosition }
                );
              }
              e.viewPosition = this.findPositionIn(
                n,
                e.modelPosition.offset
              );
            },
            { priority: 'low' }
          );
          this.on(
            'viewToModelPosition',
            (t, e) => {
              if (e.modelPosition) {
                return;
              }
              const n = this.findMappedViewAncestor(e.viewPosition);
              const i = this._viewToModelMapping.get(n);
              const o = this._toModelOffset(
                e.viewPosition.parent,
                e.viewPosition.offset,
                n
              );
              e.modelPosition = Ig._createAt(i, o);
            },
            { priority: 'low' }
          );
        }
        bindElements(t, e) {
          this._modelToViewMapping.set(t, e);
          this._viewToModelMapping.set(e, t);
        }
        unbindViewElement(t, e = {}) {
          const n = this.toModelElement(t);
          if (this._elementToMarkerNames.has(t)) {
            for (const e of this._elementToMarkerNames.get(t)) {
              this._unboundMarkerNames.add(e);
            }
          }
          if (e.defer) {
            this._deferredBindingRemovals.set(t, t.root);
          } else {
            this._viewToModelMapping.delete(t);
            if (this._modelToViewMapping.get(n) == t) {
              this._modelToViewMapping.delete(n);
            }
          }
        }
        unbindModelElement(t) {
          const e = this.toViewElement(t);
          this._modelToViewMapping.delete(t);
          if (this._viewToModelMapping.get(e) == t) {
            this._viewToModelMapping.delete(e);
          }
        }
        bindElementToMarker(t, e) {
          const n = this._markerNameToElements.get(e) || new Set();
          n.add(t);
          const i = this._elementToMarkerNames.get(t) || new Set();
          i.add(e);
          this._markerNameToElements.set(e, n);
          this._elementToMarkerNames.set(t, i);
        }
        unbindElementFromMarkerName(t, e) {
          const n = this._markerNameToElements.get(e);
          if (n) {
            n.delete(t);
            if (n.size == 0) {
              this._markerNameToElements.delete(e);
            }
          }
          const i = this._elementToMarkerNames.get(t);
          if (i) {
            i.delete(e);
            if (i.size == 0) {
              this._elementToMarkerNames.delete(t);
            }
          }
        }
        flushUnboundMarkerNames() {
          const t = Array.from(this._unboundMarkerNames);
          this._unboundMarkerNames.clear();
          return t;
        }
        flushDeferredBindings() {
          for (const [t, e] of this._deferredBindingRemovals) {
            if (t.root == e) {
              this.unbindViewElement(t);
            }
          }
          this._deferredBindingRemovals = new Map();
        }
        clearBindings() {
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._unboundMarkerNames = new Set();
          this._deferredBindingRemovals = new Map();
        }
        toModelElement(t) {
          return this._viewToModelMapping.get(t);
        }
        toViewElement(t) {
          return this._modelToViewMapping.get(t);
        }
        toModelRange(t) {
          return new Fg(
            this.toModelPosition(t.start),
            this.toModelPosition(t.end)
          );
        }
        toViewRange(t) {
          return new rd(
            this.toViewPosition(t.start),
            this.toViewPosition(t.end)
          );
        }
        toModelPosition(t) {
          const e = { viewPosition: t, mapper: this };
          this.fire('viewToModelPosition', e);
          return e.modelPosition;
        }
        toViewPosition(t, e = {}) {
          const n = {
            modelPosition: t,
            mapper: this,
            isPhantom: e.isPhantom,
          };
          this.fire('modelToViewPosition', n);
          return n.viewPosition;
        }
        markerNameToElements(t) {
          const e = this._markerNameToElements.get(t);
          if (!e) {
            return null;
          }
          const n = new Set();
          for (const t of e) {
            if (t.is('attributeElement')) {
              for (const e of t.getElementsWithSameId()) {
                n.add(e);
              }
            } else {
              n.add(t);
            }
          }
          return n;
        }
        registerViewToModelLength(t, e) {
          this._viewToModelLengthCallbacks.set(t, e);
        }
        findMappedViewAncestor(t) {
          let e = t.parent;
          while (!this._viewToModelMapping.has(e)) {
            e = e.parent;
          }
          return e;
        }
        _toModelOffset(t, e, n) {
          if (n != t) {
            const i = this._toModelOffset(t.parent, t.index, n);
            const o = this._toModelOffset(t, e, t);
            return i + o;
          }
          if (t.is('$text')) {
            return e;
          }
          let i = 0;
          for (let n = 0; n < e; n++) {
            i += this.getModelLength(t.getChild(n));
          }
          return i;
        }
        getModelLength(t) {
          if (this._viewToModelLengthCallbacks.get(t.name)) {
            const e = this._viewToModelLengthCallbacks.get(t.name);
            return e(t);
          } else if (this._viewToModelMapping.has(t)) {
            return 1;
          } else if (t.is('$text')) {
            return t.data.length;
          } else if (t.is('uiElement')) {
            return 0;
          } else {
            let e = 0;
            for (const n of t.getChildren()) {
              e += this.getModelLength(n);
            }
            return e;
          }
        }
        findPositionIn(t, e) {
          let n;
          let i = 0;
          let o = 0;
          let r = 0;
          if (t.is('$text')) {
            return new od(t, e);
          }
          while (o < e) {
            n = t.getChild(r);
            i = this.getModelLength(n);
            o += i;
            r++;
          }
          if (o == e) {
            return this._moveViewPositionToTextNode(new od(t, r));
          } else {
            return this.findPositionIn(n, e - (o - i));
          }
        }
        _moveViewPositionToTextNode(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (e instanceof Ga) {
            return new od(e, e.data.length);
          } else if (n instanceof Ga) {
            return new od(n, 0);
          }
          return t;
        }
      }
      class Mg {
        constructor() {
          this._consumable = new Map();
          this._textProxyRegistry = new Map();
        }
        add(t, e) {
          e = Lg(e);
          if (t instanceof Dg) {
            t = this._getSymbolForTextProxy(t);
          }
          if (!this._consumable.has(t)) {
            this._consumable.set(t, new Map());
          }
          this._consumable.get(t).set(e, true);
        }
        consume(t, e) {
          e = Lg(e);
          if (t instanceof Dg) {
            t = this._getSymbolForTextProxy(t);
          }
          if (this.test(t, e)) {
            this._consumable.get(t).set(e, false);
            return true;
          } else {
            return false;
          }
        }
        test(t, e) {
          e = Lg(e);
          if (t instanceof Dg) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this._consumable.get(t);
          if (n === undefined) {
            return null;
          }
          const i = n.get(e);
          if (i === undefined) {
            return null;
          }
          return i;
        }
        revert(t, e) {
          e = Lg(e);
          if (t instanceof Dg) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this.test(t, e);
          if (n === false) {
            this._consumable.get(t).set(e, true);
            return true;
          } else if (n === true) {
            return false;
          }
          return null;
        }
        verifyAllConsumed(t) {
          const e = [];
          for (const [n, i] of this._consumable) {
            for (const [o, r] of i) {
              const i = o.split(':')[0];
              if (r && t == i) {
                e.push({ event: o, item: n.name || n.description });
              }
            }
          }
          if (e.length) {
            throw new h(
              'conversion-model-consumable-not-consumed',
              null,
              { items: e }
            );
          }
        }
        _getSymbolForTextProxy(t) {
          let e = null;
          const n = this._textProxyRegistry.get(t.startOffset);
          if (n) {
            const i = n.get(t.endOffset);
            if (i) {
              e = i.get(t.parent);
            }
          }
          if (!e) {
            e = this._addSymbolForTextProxy(t);
          }
          return e;
        }
        _addSymbolForTextProxy(t) {
          const e = t.startOffset;
          const n = t.endOffset;
          const i = t.parent;
          const o = Symbol('$textProxy:' + t.data);
          let r;
          let s;
          r = this._textProxyRegistry.get(e);
          if (!r) {
            r = new Map();
            this._textProxyRegistry.set(e, r);
          }
          s = r.get(n);
          if (!s) {
            s = new Map();
            r.set(n, s);
          }
          s.set(i, o);
          return o;
        }
      }
      function Lg(t) {
        const e = t.split(':');
        if (e[0] == 'insert') {
          return e[0];
        }
        if (e[0] == 'addMarker' || e[0] == 'removeMarker') {
          return t;
        }
        return e.length > 1 ? e[0] + ':' + e[1] : e[0];
      }
      class Vg extends y {
        constructor(t) {
          super();
          this._conversionApi = { dispatcher: this, ...t };
          this._firedEventsMap = new WeakMap();
        }
        convertChanges(t, e, n) {
          const i = this._createConversionApi(
            n,
            t.getRefreshedItems()
          );
          for (const e of t.getMarkersToRemove()) {
            this._convertMarkerRemove(e.name, e.range, i);
          }
          const o = this._reduceChanges(t.getChanges());
          for (const t of o) {
            if (t.type === 'insert') {
              this._convertInsert(
                Fg._createFromPositionAndShift(t.position, t.length),
                i
              );
            } else if (t.type === 'reinsert') {
              this._convertReinsert(
                Fg._createFromPositionAndShift(t.position, t.length),
                i
              );
            } else if (t.type === 'remove') {
              this._convertRemove(t.position, t.length, t.name, i);
            } else {
              this._convertAttribute(
                t.range,
                t.attributeKey,
                t.attributeOldValue,
                t.attributeNewValue,
                i
              );
            }
          }
          for (const t of i.mapper.flushUnboundMarkerNames()) {
            const n = e.get(t).getRange();
            this._convertMarkerRemove(t, n, i);
            this._convertMarkerAdd(t, n, i);
          }
          for (const e of t.getMarkersToAdd()) {
            this._convertMarkerAdd(e.name, e.range, i);
          }
          i.mapper.flushDeferredBindings();
          i.consumable.verifyAllConsumed('insert');
        }
        convert(t, e, n, i = {}) {
          const o = this._createConversionApi(n, undefined, i);
          this._convertInsert(t, o);
          for (const [t, n] of e) {
            this._convertMarkerAdd(t, n, o);
          }
          o.consumable.verifyAllConsumed('insert');
        }
        convertSelection(t, e, n) {
          const i = Array.from(
            e.getMarkersAtPosition(t.getFirstPosition())
          );
          const o = this._createConversionApi(n);
          this._addConsumablesForSelection(o.consumable, t, i);
          this.fire('selection', { selection: t }, o);
          if (!t.isCollapsed) {
            return;
          }
          for (const e of i) {
            const n = e.getRange();
            if (!Hg(t.getFirstPosition(), e, o.mapper)) {
              continue;
            }
            const i = { item: t, markerName: e.name, markerRange: n };
            if (o.consumable.test(t, 'addMarker:' + e.name)) {
              this.fire(`addMarker:${e.name}`, i, o);
            }
          }
          for (const e of t.getAttributeKeys()) {
            const n = {
              item: t,
              range: t.getFirstRange(),
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: t.getAttribute(e),
            };
            if (o.consumable.test(t, 'attribute:' + n.attributeKey)) {
              this.fire(`attribute:${n.attributeKey}:$text`, n, o);
            }
          }
        }
        _convertInsert(t, e, n = {}) {
          if (!n.doNotAddConsumables) {
            this._addConsumablesForInsert(
              e.consumable,
              Array.from(t)
            );
          }
          for (const n of Array.from(
            t.getWalker({ shallow: true })
          ).map(qg)) {
            this._testAndFire('insert', n, e);
          }
        }
        _convertRemove(t, e, n, i) {
          this.fire(`remove:${n}`, { position: t, length: e }, i);
        }
        _convertAttribute(t, e, n, i, o) {
          this._addConsumablesForRange(
            o.consumable,
            t,
            `attribute:${e}`
          );
          for (const r of t) {
            const t = {
              item: r.item,
              range: Fg._createFromPositionAndShift(
                r.previousPosition,
                r.length
              ),
              attributeKey: e,
              attributeOldValue: n,
              attributeNewValue: i,
            };
            this._testAndFire(`attribute:${e}`, t, o);
          }
        }
        _convertReinsert(t, e) {
          const n = Array.from(t.getWalker({ shallow: true }));
          this._addConsumablesForInsert(e.consumable, n);
          for (const t of n.map(qg)) {
            this._testAndFire(
              'insert',
              { ...t, reconversion: true },
              e
            );
          }
        }
        _convertMarkerAdd(t, e, n) {
          if (e.root.rootName == '$graveyard') {
            return;
          }
          const i = `addMarker:${t}`;
          n.consumable.add(e, i);
          this.fire(i, { markerName: t, markerRange: e }, n);
          if (!n.consumable.consume(e, i)) {
            return;
          }
          this._addConsumablesForRange(n.consumable, e, i);
          for (const o of e.getItems()) {
            if (!n.consumable.test(o, i)) {
              continue;
            }
            const r = {
              item: o,
              range: Fg._createOn(o),
              markerName: t,
              markerRange: e,
            };
            this.fire(i, r, n);
          }
        }
        _convertMarkerRemove(t, e, n) {
          if (e.root.rootName == '$graveyard') {
            return;
          }
          this.fire(
            `removeMarker:${t}`,
            { markerName: t, markerRange: e },
            n
          );
        }
        _reduceChanges(t) {
          const e = { changes: t };
          this.fire('reduceChanges', e);
          return e.changes;
        }
        _addConsumablesForInsert(t, e) {
          for (const n of e) {
            const e = n.item;
            if (t.test(e, 'insert') === null) {
              t.add(e, 'insert');
              for (const n of e.getAttributeKeys()) {
                t.add(e, 'attribute:' + n);
              }
            }
          }
          return t;
        }
        _addConsumablesForRange(t, e, n) {
          for (const i of e.getItems()) {
            t.add(i, n);
          }
          return t;
        }
        _addConsumablesForSelection(t, e, n) {
          t.add(e, 'selection');
          for (const i of n) {
            t.add(e, 'addMarker:' + i.name);
          }
          for (const n of e.getAttributeKeys()) {
            t.add(e, 'attribute:' + n);
          }
          return t;
        }
        _testAndFire(t, e, n) {
          const i = jg(t, e);
          const o = e.item.is('$textProxy')
            ? n.consumable._getSymbolForTextProxy(e.item)
            : e.item;
          const r = this._firedEventsMap.get(n);
          const s = r.get(o);
          if (!s) {
            r.set(o, new Set([i]));
          } else if (!s.has(i)) {
            s.add(i);
          } else {
            return;
          }
          this.fire(i, e, n);
        }
        _testAndFireAddAttributes(t, e) {
          const n = { item: t, range: Fg._createOn(t) };
          for (const t of n.item.getAttributeKeys()) {
            n.attributeKey = t;
            n.attributeOldValue = null;
            n.attributeNewValue = n.item.getAttribute(t);
            this._testAndFire(`attribute:${t}`, n, e);
          }
        }
        _createConversionApi(t, e = new Set(), n = {}) {
          const i = {
            ...this._conversionApi,
            consumable: new Mg(),
            writer: t,
            options: n,
            convertItem: (t) =>
              this._convertInsert(Fg._createOn(t), i),
            convertChildren: (t) =>
              this._convertInsert(Fg._createIn(t), i, {
                doNotAddConsumables: true,
              }),
            convertAttributes: (t) =>
              this._testAndFireAddAttributes(t, i),
            canReuseView: (t) => !e.has(i.mapper.toModelElement(t)),
          };
          this._firedEventsMap.set(i, new Map());
          return i;
        }
      }
      function Hg(t, e, n) {
        const i = e.getRange();
        const o = Array.from(t.getAncestors());
        o.shift();
        o.reverse();
        const r = o.some((t) => {
          if (i.containsItem(t)) {
            const e = n.toViewElement(t);
            return !!e.getCustomProperty('addHighlight');
          }
        });
        return !r;
      }
      function jg(t, e) {
        const n = e.item.is('element') ? e.item.name : '$text';
        return `${t}:${n}`;
      }
      function qg(t) {
        const e = t.item;
        const n = Fg._createFromPositionAndShift(
          t.previousPosition,
          t.length
        );
        return { item: e, range: n };
      }
      class Wg extends C(Cg) {
        constructor(...t) {
          super();
          this._lastRangeBackward = false;
          this._ranges = [];
          this._attrs = new Map();
          if (t.length) {
            this.setTo(...t);
          }
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.end : t.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.start : t.end;
          }
          return null;
        }
        get isCollapsed() {
          const t = this._ranges.length;
          if (t === 1) {
            return this._ranges[0].isCollapsed;
          } else {
            return false;
          }
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(t) {
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (
            !this.anchor.isEqual(t.anchor) ||
            !this.focus.isEqual(t.focus)
          ) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const i of t._ranges) {
              if (e.isEqual(i)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield new Fg(t.start, t.end);
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? new Fg(t.start, t.end) : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? new Fg(t.start, t.end) : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        setTo(...t) {
          let [e, n, i] = t;
          if (typeof n == 'object') {
            i = n;
            n = undefined;
          }
          if (e === null) {
            this._setRanges([]);
          } else if (e instanceof Wg) {
            this._setRanges(e.getRanges(), e.isBackward);
          } else if (e && typeof e.getRanges == 'function') {
            this._setRanges(e.getRanges(), e.isBackward);
          } else if (e instanceof Fg) {
            this._setRanges([e], !!i && !!i.backward);
          } else if (e instanceof Ig) {
            this._setRanges([new Fg(e)]);
          } else if (e instanceof yg) {
            const t = !!i && !!i.backward;
            let o;
            if (n == 'in') {
              o = Fg._createIn(e);
            } else if (n == 'on') {
              o = Fg._createOn(e);
            } else if (n !== undefined) {
              o = new Fg(Ig._createAt(e, n));
            } else {
              throw new h(
                'model-selection-setto-required-second-parameter',
                [this, e]
              );
            }
            this._setRanges([o], t);
          } else if (Ca(e)) {
            this._setRanges(e, i && !!i.backward);
          } else {
            throw new h('model-selection-setto-not-selectable', [
              this,
              e,
            ]);
          }
        }
        _setRanges(t, e = false) {
          const n = Array.from(t);
          const i = n.some((e) => {
            if (!(e instanceof Fg)) {
              throw new h('model-selection-set-ranges-not-range', [
                this,
                t,
              ]);
            }
            return this._ranges.every((t) => !t.isEqual(e));
          });
          if (n.length === this._ranges.length && !i) {
            return;
          }
          this._replaceAllRanges(n);
          this._lastRangeBackward = !!e;
          this.fire('change:range', { directChange: true });
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new h('model-selection-setfocus-no-ranges', [
              this,
              t,
            ]);
          }
          const n = Ig._createAt(t, e);
          if (n.compareWith(this.focus) == 'same') {
            return;
          }
          const i = this.anchor;
          if (this._ranges.length) {
            this._popRange();
          }
          if (n.compareWith(i) == 'before') {
            this._pushRange(new Fg(n, i));
            this._lastRangeBackward = true;
          } else {
            this._pushRange(new Fg(i, n));
            this._lastRangeBackward = false;
          }
          this.fire('change:range', { directChange: true });
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        removeAttribute(t) {
          if (this.hasAttribute(t)) {
            this._attrs.delete(t);
            this.fire('change:attribute', {
              attributeKeys: [t],
              directChange: true,
            });
          }
        }
        setAttribute(t, e) {
          if (this.getAttribute(t) !== e) {
            this._attrs.set(t, e);
            this.fire('change:attribute', {
              attributeKeys: [t],
              directChange: true,
            });
          }
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        *getSelectedBlocks() {
          const t = new WeakSet();
          for (const e of this.getRanges()) {
            const n = $g(e.start, t);
            if (n && Kg(n, e)) {
              yield n;
            }
            for (const n of e.getWalker()) {
              const i = n.item;
              if (n.type == 'elementEnd' && Gg(i, t, e)) {
                yield i;
              }
            }
            const i = $g(e.end, t);
            if (
              i &&
              !e.end.isTouching(Ig._createAt(i, 0)) &&
              Kg(i, e)
            ) {
              yield i;
            }
          }
        }
        containsEntireContent(t = this.anchor.root) {
          const e = Ig._createAt(t, 0);
          const n = Ig._createAt(t, 'end');
          return (
            e.isTouching(this.getFirstPosition()) &&
            n.isTouching(this.getLastPosition())
          );
        }
        _pushRange(t) {
          this._checkRange(t);
          this._ranges.push(new Fg(t.start, t.end));
        }
        _checkRange(t) {
          for (let e = 0; e < this._ranges.length; e++) {
            if (t.isIntersecting(this._ranges[e])) {
              throw new h(
                'model-selection-range-intersects',
                [this, t],
                { addedRange: t, intersectingRange: this._ranges[e] }
              );
            }
          }
        }
        _replaceAllRanges(t) {
          this._removeAllRanges();
          for (const e of t) {
            this._pushRange(e);
          }
        }
        _removeAllRanges() {
          while (this._ranges.length > 0) {
            this._popRange();
          }
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      Wg.prototype.is = function (t) {
        return t === 'selection' || t === 'model:selection';
      };
      function Ug(t, e) {
        if (e.has(t)) {
          return false;
        }
        e.add(t);
        return t.root.document.model.schema.isBlock(t) && t.parent;
      }
      function Gg(t, e, n) {
        return Ug(t, e) && Kg(t, n);
      }
      function $g(t, e) {
        const n = t.parent;
        const i = n.root.document.model.schema;
        const o = t.parent.getAncestors({
          parentFirst: true,
          includeSelf: true,
        });
        let r = false;
        const s = o.find((t) => {
          if (r) {
            return false;
          }
          r = i.isLimit(t);
          return !r && Ug(t, e);
        });
        o.forEach((t) => e.add(t));
        return s;
      }
      function Kg(t, e) {
        const n = Zg(t);
        if (!n) {
          return true;
        }
        const i = e.containsRange(Fg._createOn(n), true);
        return !i;
      }
      function Zg(t) {
        const e = t.root.document.model.schema;
        let n = t.parent;
        while (n) {
          if (e.isBlock(n)) {
            return n;
          }
          n = n.parent;
        }
      }
      class Jg extends C(Fg) {
        constructor(t, e) {
          super(t, e);
          Yg.call(this);
        }
        detach() {
          this.stopListening();
        }
        toRange() {
          return new Fg(this.start, this.end);
        }
        static fromRange(t) {
          return new Jg(t.start, t.end);
        }
      }
      Jg.prototype.is = function (t) {
        return (
          t === 'liveRange' ||
          t === 'model:liveRange' ||
          t == 'range' ||
          t === 'model:range'
        );
      };
      function Yg() {
        this.listenTo(
          this.root.document.model,
          'applyOperation',
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            Qg.call(this, n);
          },
          { priority: 'low' }
        );
      }
      function Qg(t) {
        const e = this.getTransformedByOperation(t);
        const n = Fg._createFromRanges(e);
        const i = !n.isEqual(this);
        const o = Xg(this, t);
        let r = null;
        if (i) {
          if (n.root.rootName == '$graveyard') {
            if (t.type == 'remove') {
              r = t.sourcePosition;
            } else {
              r = t.deletionPosition;
            }
          }
          const e = this.toRange();
          this.start = n.start;
          this.end = n.end;
          this.fire('change:range', e, { deletionPosition: r });
        } else if (o) {
          this.fire('change:content', this.toRange(), {
            deletionPosition: r,
          });
        }
      }
      function Xg(t, e) {
        switch (e.type) {
          case 'insert':
            return t.containsPosition(e.position);
          case 'move':
          case 'remove':
          case 'reinsert':
          case 'merge':
            return (
              t.containsPosition(e.sourcePosition) ||
              t.start.isEqual(e.sourcePosition) ||
              t.containsPosition(e.targetPosition)
            );
          case 'split':
            return (
              t.containsPosition(e.splitPosition) ||
              t.containsPosition(e.insertionPosition)
            );
        }
        return false;
      }
      const tm = 'selection:';
      class em extends C(Cg) {
        constructor(t) {
          super();
          this._selection = new nm(t);
          this._selection.delegate('change:range').to(this);
          this._selection.delegate('change:attribute').to(this);
          this._selection.delegate('change:marker').to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(t) {
          return this._selection.containsEntireContent(t);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(t) {
          return this._selection.getAttribute(t);
        }
        hasAttribute(t) {
          return this._selection.hasAttribute(t);
        }
        refresh() {
          this._selection.updateMarkers();
          this._selection._updateAttributes(false);
        }
        observeMarkers(t) {
          this._selection.observeMarkers(t);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
        _setTo(...t) {
          this._selection.setTo(...t);
        }
        _setAttribute(t, e) {
          this._selection.setAttribute(t, e);
        }
        _removeAttribute(t) {
          this._selection.removeAttribute(t);
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(t) {
          this._selection.restoreGravity(t);
        }
        static _getStoreAttributeKey(t) {
          return tm + t;
        }
        static _isStoreAttributeKey(t) {
          return t.startsWith(tm);
        }
      }
      em.prototype.is = function (t) {
        return (
          t === 'selection' ||
          t == 'model:selection' ||
          t == 'documentSelection' ||
          t == 'model:documentSelection'
        );
      };
      class nm extends Wg {
        constructor(t) {
          super();
          this.markers = new ya({ idProperty: 'name' });
          this._model = t.model;
          this._document = t;
          this._attributePriority = new Map();
          this._selectionRestorePosition = null;
          this._hasChangedRange = false;
          this._overriddenGravityRegister = new Set();
          this._observedMarkers = new Set();
          this.listenTo(
            this._model,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              if (
                !n.isDocumentOperation ||
                n.type == 'marker' ||
                n.type == 'rename' ||
                n.type == 'noop'
              ) {
                return;
              }
              if (
                this._ranges.length == 0 &&
                this._selectionRestorePosition
              ) {
                this._fixGraveyardSelection(
                  this._selectionRestorePosition
                );
              }
              this._selectionRestorePosition = null;
              if (this._hasChangedRange) {
                this._hasChangedRange = false;
                this.fire('change:range', { directChange: false });
              }
            },
            { priority: 'lowest' }
          );
          this.on('change:range', () => {
            this._validateSelectionRanges(this.getRanges());
          });
          this.listenTo(
            this._model.markers,
            'update',
            (t, e, n, i) => {
              this._updateMarker(e, i);
            }
          );
          this.listenTo(this._document, 'change', (t, e) => {
            om(this._model, e);
          });
        }
        get isCollapsed() {
          const t = this._ranges.length;
          return t === 0
            ? this._document._getDefaultRange().isCollapsed
            : super.isCollapsed;
        }
        get anchor() {
          return (
            super.anchor || this._document._getDefaultRange().start
          );
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let t = 0; t < this._ranges.length; t++) {
            this._ranges[t].detach();
          }
          this.stopListening();
        }
        *getRanges() {
          if (this._ranges.length) {
            yield* super.getRanges();
          } else {
            yield this._document._getDefaultRange();
          }
        }
        getFirstRange() {
          return (
            super.getFirstRange() || this._document._getDefaultRange()
          );
        }
        getLastRange() {
          return (
            super.getLastRange() || this._document._getDefaultRange()
          );
        }
        setTo(...t) {
          super.setTo(...t);
          this._updateAttributes(true);
          this.updateMarkers();
        }
        setFocus(t, e) {
          super.setFocus(t, e);
          this._updateAttributes(true);
          this.updateMarkers();
        }
        setAttribute(t, e) {
          if (this._setAttribute(t, e)) {
            const e = [t];
            this.fire('change:attribute', {
              attributeKeys: e,
              directChange: true,
            });
          }
        }
        removeAttribute(t) {
          if (this._removeAttribute(t)) {
            const e = [t];
            this.fire('change:attribute', {
              attributeKeys: e,
              directChange: true,
            });
          }
        }
        overrideGravity() {
          const t = s();
          this._overriddenGravityRegister.add(t);
          if (this._overriddenGravityRegister.size === 1) {
            this._updateAttributes(true);
          }
          return t;
        }
        restoreGravity(t) {
          if (!this._overriddenGravityRegister.has(t)) {
            throw new h(
              'document-selection-gravity-wrong-restore',
              this,
              { uid: t }
            );
          }
          this._overriddenGravityRegister.delete(t);
          if (!this.isGravityOverridden) {
            this._updateAttributes(true);
          }
        }
        observeMarkers(t) {
          this._observedMarkers.add(t);
          this.updateMarkers();
        }
        _replaceAllRanges(t) {
          this._validateSelectionRanges(t);
          super._replaceAllRanges(t);
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(t) {
          const e = this._prepareRange(t);
          if (e) {
            this._ranges.push(e);
          }
        }
        _validateSelectionRanges(t) {
          for (const e of t) {
            if (!this._document._validateSelectionRange(e)) {
              throw new h('document-selection-wrong-position', this, {
                range: e,
              });
            }
          }
        }
        _prepareRange(t) {
          this._checkRange(t);
          if (t.root == this._document.graveyard) {
            return;
          }
          const e = Jg.fromRange(t);
          e.on('change:range', (t, n, i) => {
            this._hasChangedRange = true;
            if (e.root == this._document.graveyard) {
              this._selectionRestorePosition = i.deletionPosition;
              const t = this._ranges.indexOf(e);
              this._ranges.splice(t, 1);
              e.detach();
            }
          });
          return e;
        }
        updateMarkers() {
          if (!this._observedMarkers.size) {
            return;
          }
          const t = [];
          let e = false;
          for (const e of this._model.markers) {
            const n = e.name.split(':', 1)[0];
            if (!this._observedMarkers.has(n)) {
              continue;
            }
            const i = e.getRange();
            for (const n of this.getRanges()) {
              if (i.containsRange(n, !n.isCollapsed)) {
                t.push(e);
              }
            }
          }
          const n = Array.from(this.markers);
          for (const n of t) {
            if (!this.markers.has(n)) {
              this.markers.add(n);
              e = true;
            }
          }
          for (const n of Array.from(this.markers)) {
            if (!t.includes(n)) {
              this.markers.remove(n);
              e = true;
            }
          }
          if (e) {
            this.fire('change:marker', {
              oldMarkers: n,
              directChange: false,
            });
          }
        }
        _updateMarker(t, e) {
          const n = t.name.split(':', 1)[0];
          if (!this._observedMarkers.has(n)) {
            return;
          }
          let i = false;
          const o = Array.from(this.markers);
          const r = this.markers.has(t);
          if (!e) {
            if (r) {
              this.markers.remove(t);
              i = true;
            }
          } else {
            let n = false;
            for (const t of this.getRanges()) {
              if (e.containsRange(t, !t.isCollapsed)) {
                n = true;
                break;
              }
            }
            if (n && !r) {
              this.markers.add(t);
              i = true;
            } else if (!n && r) {
              this.markers.remove(t);
              i = true;
            }
          }
          if (i) {
            this.fire('change:marker', {
              oldMarkers: o,
              directChange: false,
            });
          }
        }
        _updateAttributes(t) {
          const e = Za(this._getSurroundingAttributes());
          const n = Za(this.getAttributes());
          if (t) {
            this._attributePriority = new Map();
            this._attrs = new Map();
          } else {
            for (const [t, e] of this._attributePriority) {
              if (e == 'low') {
                this._attrs.delete(t);
                this._attributePriority.delete(t);
              }
            }
          }
          this._setAttributesTo(e);
          const i = [];
          for (const [t, e] of this.getAttributes()) {
            if (!n.has(t) || n.get(t) !== e) {
              i.push(t);
            }
          }
          for (const [t] of n) {
            if (!this.hasAttribute(t)) {
              i.push(t);
            }
          }
          if (i.length > 0) {
            this.fire('change:attribute', {
              attributeKeys: i,
              directChange: false,
            });
          }
        }
        _setAttribute(t, e, n = true) {
          const i = n ? 'normal' : 'low';
          if (
            i == 'low' &&
            this._attributePriority.get(t) == 'normal'
          ) {
            return false;
          }
          const o = super.getAttribute(t);
          if (o === e) {
            return false;
          }
          this._attrs.set(t, e);
          this._attributePriority.set(t, i);
          return true;
        }
        _removeAttribute(t, e = true) {
          const n = e ? 'normal' : 'low';
          if (
            n == 'low' &&
            this._attributePriority.get(t) == 'normal'
          ) {
            return false;
          }
          this._attributePriority.set(t, n);
          if (!super.hasAttribute(t)) {
            return false;
          }
          this._attrs.delete(t);
          return true;
        }
        _setAttributesTo(t) {
          const e = new Set();
          for (const [e, n] of this.getAttributes()) {
            if (t.get(e) === n) {
              continue;
            }
            this._removeAttribute(e, false);
          }
          for (const [n, i] of t) {
            const t = this._setAttribute(n, i, false);
            if (t) {
              e.add(n);
            }
          }
          return e;
        }
        *getStoredAttributes() {
          const t = this.getFirstPosition().parent;
          if (this.isCollapsed && t.isEmpty) {
            for (const e of t.getAttributeKeys()) {
              if (e.startsWith(tm)) {
                const n = e.substr(tm.length);
                yield [n, t.getAttribute(e)];
              }
            }
          }
        }
        _getSurroundingAttributes() {
          const t = this.getFirstPosition();
          const e = this._model.schema;
          let n = null;
          if (!this.isCollapsed) {
            const t = this.getFirstRange();
            for (const i of t) {
              if (i.item.is('element') && e.isObject(i.item)) {
                break;
              }
              if (i.type == 'text') {
                n = i.item.getAttributes();
                break;
              }
            }
          } else {
            const i = t.textNode ? t.textNode : t.nodeBefore;
            const o = t.textNode ? t.textNode : t.nodeAfter;
            if (!this.isGravityOverridden) {
              n = im(i);
            }
            if (!n) {
              n = im(o);
            }
            if (!this.isGravityOverridden && !n) {
              let t = i;
              while (t && !e.isInline(t) && !n) {
                t = t.previousSibling;
                n = im(t);
              }
            }
            if (!n) {
              let t = o;
              while (t && !e.isInline(t) && !n) {
                t = t.nextSibling;
                n = im(t);
              }
            }
            if (!n) {
              n = this.getStoredAttributes();
            }
          }
          return n;
        }
        _fixGraveyardSelection(t) {
          const e = this._model.schema.getNearestSelectionRange(t);
          if (e) {
            this._pushRange(e);
          }
        }
      }
      function im(t) {
        if (t instanceof Dg || t instanceof Eg) {
          return t.getAttributes();
        }
        return null;
      }
      function om(t, e) {
        const n = t.document.differ;
        for (const i of n.getChanges()) {
          if (i.type != 'insert') {
            continue;
          }
          const n = i.position.parent;
          const o = i.length === n.maxOffset;
          if (o) {
            t.enqueueChange(e, (t) => {
              const e = Array.from(n.getAttributeKeys()).filter((t) =>
                t.startsWith(tm)
              );
              for (const i of e) {
                t.removeAttribute(i, n);
              }
            });
          }
        }
      }
      class rm {
        constructor(t) {
          this._dispatchers = t;
        }
        add(t) {
          for (const e of this._dispatchers) {
            t(e);
          }
          return this;
        }
      }
      var sm = 1,
        am = 4;
      function cm(t) {
        return fa(t, sm | am);
      }
      const lm = cm;
      class dm extends rm {
        elementToElement(t) {
          return this.add(Im(t));
        }
        elementToStructure(t) {
          return this.add(Rm(t));
        }
        attributeToElement(t) {
          return this.add(zm(t));
        }
        attributeToAttribute(t) {
          return this.add(Om(t));
        }
        markerToElement(t) {
          return this.add(Fm(t));
        }
        markerToHighlight(t) {
          return this.add(Mm(t));
        }
        markerToData(t) {
          return this.add(Nm(t));
        }
      }
      function hm() {
        return (t, e, n) => {
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const i = n.writer;
          const o = n.mapper.toViewPosition(e.range.start);
          const r = i.createText(e.item.data);
          i.insert(o, r);
        };
      }
      function um() {
        return (t, e, n) => {
          n.convertAttributes(e.item);
          if (
            !e.reconversion &&
            e.item.is('element') &&
            !e.item.isEmpty
          ) {
            n.convertChildren(e.item);
          }
        };
      }
      function fm() {
        return (t, e, n) => {
          const i = n.mapper.toViewPosition(e.position);
          const o = e.position.getShiftedBy(e.length);
          const r = n.mapper.toViewPosition(o, { isPhantom: true });
          const s = n.writer.createRange(i, r);
          const a = n.writer.remove(s.getTrimmed());
          for (const t of n.writer.createRangeIn(a).getItems()) {
            n.mapper.unbindViewElement(t, { defer: true });
          }
        };
      }
      function gm(t, e) {
        const n = t.createAttributeElement('span', e.attributes);
        if (e.classes) {
          n._addClass(e.classes);
        }
        if (typeof e.priority === 'number') {
          n._priority = e.priority;
        }
        n._id = e.id;
        return n;
      }
      function mm() {
        return (t, e, n) => {
          const i = e.selection;
          if (i.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(i, 'selection')) {
            return;
          }
          const o = [];
          for (const t of i.getRanges()) {
            o.push(n.mapper.toViewRange(t));
          }
          n.writer.setSelection(o, { backward: i.isBackward });
        };
      }
      function pm() {
        return (t, e, n) => {
          const i = e.selection;
          if (!i.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(i, 'selection')) {
            return;
          }
          const o = n.writer;
          const r = i.getFirstPosition();
          const s = n.mapper.toViewPosition(r);
          const a = o.breakAttributes(s);
          o.setSelection(a);
        };
      }
      function km() {
        return (t, e, n) => {
          const i = n.writer;
          const o = i.document.selection;
          for (const t of o.getRanges()) {
            if (t.isCollapsed) {
              if (t.end.parent.isAttached()) {
                n.writer.mergeAttributes(t.start);
              }
            }
          }
          i.setSelection(null);
        };
      }
      function bm(t) {
        return (e, n, i) => {
          if (!i.consumable.test(n.item, e.name)) {
            return;
          }
          const o = t(n.attributeOldValue, i, n);
          const r = t(n.attributeNewValue, i, n);
          if (!o && !r) {
            return;
          }
          i.consumable.consume(n.item, e.name);
          const s = i.writer;
          const a = s.document.selection;
          if (n.item instanceof Wg || n.item instanceof em) {
            s.wrap(a.getFirstRange(), r);
          } else {
            let t = i.mapper.toViewRange(n.range);
            if (n.attributeOldValue !== null && o) {
              t = s.unwrap(t, o);
            }
            if (n.attributeNewValue !== null && r) {
              s.wrap(t, r);
            }
          }
        };
      }
      function wm(t, e = Xm) {
        return (n, i, o) => {
          if (!e(i.item, o.consumable, { preflight: true })) {
            return;
          }
          const r = t(i.item, o, i);
          if (!r) {
            return;
          }
          e(i.item, o.consumable);
          const s = o.mapper.toViewPosition(i.range.start);
          o.mapper.bindElements(i.item, r);
          o.writer.insert(s, r);
          o.convertAttributes(i.item);
          Ym(r, i.item.getChildren(), o, {
            reconversion: i.reconversion,
          });
        };
      }
      function _m(t, e) {
        return (n, i, o) => {
          if (!e(i.item, o.consumable, { preflight: true })) {
            return;
          }
          const r = new Map();
          o.writer._registerSlotFactory(Km(i.item, r, o));
          const s = t(i.item, o, i);
          o.writer._clearSlotFactory();
          if (!s) {
            return;
          }
          Zm(i.item, r, o);
          e(i.item, o.consumable);
          const a = o.mapper.toViewPosition(i.range.start);
          o.mapper.bindElements(i.item, s);
          o.writer.insert(a, s);
          o.convertAttributes(i.item);
          Jm(s, r, o, { reconversion: i.reconversion });
        };
      }
      function vm(t) {
        return (e, n, i) => {
          n.isOpening = true;
          const o = t(n, i);
          n.isOpening = false;
          const r = t(n, i);
          if (!o || !r) {
            return;
          }
          const s = n.markerRange;
          if (s.isCollapsed && !i.consumable.consume(s, e.name)) {
            return;
          }
          for (const t of s) {
            if (!i.consumable.consume(t.item, e.name)) {
              return;
            }
          }
          const a = i.mapper;
          const c = i.writer;
          c.insert(a.toViewPosition(s.start), o);
          i.mapper.bindElementToMarker(o, n.markerName);
          if (!s.isCollapsed) {
            c.insert(a.toViewPosition(s.end), r);
            i.mapper.bindElementToMarker(r, n.markerName);
          }
          e.stop();
        };
      }
      function Am() {
        return (t, e, n) => {
          const i = n.mapper.markerNameToElements(e.markerName);
          if (!i) {
            return;
          }
          for (const t of i) {
            n.mapper.unbindElementFromMarkerName(t, e.markerName);
            n.writer.clear(n.writer.createRangeOn(t), t);
          }
          n.writer.clearClonedElementsGroup(e.markerName);
          t.stop();
        };
      }
      function Cm(t) {
        return (e, n, i) => {
          const o = t(n.markerName, i);
          if (!o) {
            return;
          }
          const r = n.markerRange;
          if (!i.consumable.consume(r, e.name)) {
            return;
          }
          ym(r, false, i, n, o);
          ym(r, true, i, n, o);
          e.stop();
        };
      }
      function ym(t, e, n, i, o) {
        const r = e ? t.start : t.end;
        const s =
          r.nodeAfter && r.nodeAfter.is('element')
            ? r.nodeAfter
            : null;
        const a =
          r.nodeBefore && r.nodeBefore.is('element')
            ? r.nodeBefore
            : null;
        if (s || a) {
          let t;
          let r;
          if ((e && s) || (!e && !a)) {
            t = s;
            r = true;
          } else {
            t = a;
            r = false;
          }
          const c = n.mapper.toViewElement(t);
          if (c) {
            xm(c, e, r, n, i, o);
            return;
          }
        }
        const c = n.mapper.toViewPosition(r);
        Em(c, e, n, i, o);
      }
      function xm(t, e, n, i, o, r) {
        const s = `data-${r.group}-${e ? 'start' : 'end'}-${
          n ? 'before' : 'after'
        }`;
        const a = t.hasAttribute(s)
          ? t.getAttribute(s).split(',')
          : [];
        a.unshift(r.name);
        i.writer.setAttribute(s, a.join(','), t);
        i.mapper.bindElementToMarker(t, o.markerName);
      }
      function Em(t, e, n, i, o) {
        const r = `${o.group}-${e ? 'start' : 'end'}`;
        const s = o.name ? { name: o.name } : null;
        const a = n.writer.createUIElement(r, s);
        n.writer.insert(t, a);
        n.mapper.bindElementToMarker(a, i.markerName);
      }
      function Dm(t) {
        return (e, n, i) => {
          const o = t(n.markerName, i);
          if (!o) {
            return;
          }
          const r = i.mapper.markerNameToElements(n.markerName);
          if (!r) {
            return;
          }
          for (const t of r) {
            i.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is('containerElement')) {
              s(`data-${o.group}-start-before`, t);
              s(`data-${o.group}-start-after`, t);
              s(`data-${o.group}-end-before`, t);
              s(`data-${o.group}-end-after`, t);
            } else {
              i.writer.clear(i.writer.createRangeOn(t), t);
            }
          }
          i.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
          function s(t, e) {
            if (e.hasAttribute(t)) {
              const n = new Set(e.getAttribute(t).split(','));
              n.delete(o.name);
              if (n.size == 0) {
                i.writer.removeAttribute(t, e);
              } else {
                i.writer.setAttribute(t, Array.from(n).join(','), e);
              }
            }
          }
        };
      }
      function Sm(t) {
        return (e, n, i) => {
          if (!i.consumable.test(n.item, e.name)) {
            return;
          }
          const o = t(n.attributeOldValue, i, n);
          const r = t(n.attributeNewValue, i, n);
          if (!o && !r) {
            return;
          }
          i.consumable.consume(n.item, e.name);
          const s = i.mapper.toViewElement(n.item);
          const a = i.writer;
          if (!s) {
            throw new h(
              'conversion-attribute-to-attribute-on-text',
              i.dispatcher,
              n
            );
          }
          if (n.attributeOldValue !== null && o) {
            if (o.key == 'class') {
              const t = Ea(o.value);
              for (const e of t) {
                a.removeClass(e, s);
              }
            } else if (o.key == 'style') {
              const t = Object.keys(o.value);
              for (const e of t) {
                a.removeStyle(e, s);
              }
            } else {
              a.removeAttribute(o.key, s);
            }
          }
          if (n.attributeNewValue !== null && r) {
            if (r.key == 'class') {
              const t = Ea(r.value);
              for (const e of t) {
                a.addClass(e, s);
              }
            } else if (r.key == 'style') {
              const t = Object.keys(r.value);
              for (const e of t) {
                a.setStyle(e, r.value[e], s);
              }
            } else {
              a.setAttribute(r.key, r.value, s);
            }
          }
        };
      }
      function Tm(t) {
        return (e, n, i) => {
          if (!n.item) {
            return;
          }
          if (
            !(n.item instanceof Wg || n.item instanceof em) &&
            !n.item.is('$textProxy')
          ) {
            return;
          }
          const o = Wm(t, n, i);
          if (!o) {
            return;
          }
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const r = i.writer;
          const s = gm(r, o);
          const a = r.document.selection;
          if (n.item instanceof Wg || n.item instanceof em) {
            r.wrap(a.getFirstRange(), s);
          } else {
            const t = i.mapper.toViewRange(n.range);
            const e = r.wrap(t, s);
            for (const t of e.getItems()) {
              if (t.is('attributeElement') && t.isSimilar(s)) {
                i.mapper.bindElementToMarker(t, n.markerName);
                break;
              }
            }
          }
        };
      }
      function Bm(t) {
        return (e, n, i) => {
          if (!n.item) {
            return;
          }
          if (!(n.item instanceof Sg)) {
            return;
          }
          const o = Wm(t, n, i);
          if (!o) {
            return;
          }
          if (!i.consumable.test(n.item, e.name)) {
            return;
          }
          const r = i.mapper.toViewElement(n.item);
          if (r && r.getCustomProperty('addHighlight')) {
            i.consumable.consume(n.item, e.name);
            for (const t of Fg._createIn(n.item)) {
              i.consumable.consume(t.item, e.name);
            }
            const t = r.getCustomProperty('addHighlight');
            t(r, o, i.writer);
            i.mapper.bindElementToMarker(r, n.markerName);
          }
        };
      }
      function Pm(t) {
        return (e, n, i) => {
          if (n.markerRange.isCollapsed) {
            return;
          }
          const o = Wm(t, n, i);
          if (!o) {
            return;
          }
          const r = gm(i.writer, o);
          const s = i.mapper.markerNameToElements(n.markerName);
          if (!s) {
            return;
          }
          for (const t of s) {
            i.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is('attributeElement')) {
              i.writer.unwrap(i.writer.createRangeOn(t), r);
            } else {
              const e = t.getCustomProperty('removeHighlight');
              e(t, o.id, i.writer);
            }
          }
          i.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
        };
      }
      function Im(t) {
        const e = Lm(t.model);
        const n = Vm(t.view, 'container');
        if (e.attributes.length) {
          e.children = true;
        }
        return (i) => {
          i.on(`insert:${e.name}`, wm(n, $m(e)), {
            priority: t.converterPriority || 'normal',
          });
          if (e.children || e.attributes.length) {
            i.on('reduceChanges', Gm(e), { priority: 'low' });
          }
        };
      }
      function Rm(t) {
        const e = Lm(t.model);
        const n = Vm(t.view, 'container');
        e.children = true;
        return (i) => {
          if (i._conversionApi.schema.checkChild(e.name, '$text')) {
            throw new h(
              'conversion-element-to-structure-disallowed-text',
              i,
              { elementName: e.name }
            );
          }
          i.on(`insert:${e.name}`, _m(n, $m(e)), {
            priority: t.converterPriority || 'normal',
          });
          i.on('reduceChanges', Gm(e), { priority: 'low' });
        };
      }
      function zm(t) {
        t = lm(t);
        let e = t.model;
        if (typeof e == 'string') {
          e = { key: e };
        }
        let n = `attribute:${e.key}`;
        if (e.name) {
          n += ':' + e.name;
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Vm(t.view[n], 'attribute');
          }
        } else {
          t.view = Vm(t.view, 'attribute');
        }
        const i = jm(t);
        return (e) => {
          e.on(n, bm(i), {
            priority: t.converterPriority || 'normal',
          });
        };
      }
      function Om(t) {
        t = lm(t);
        let e = t.model;
        if (typeof e == 'string') {
          e = { key: e };
        }
        let n = `attribute:${e.key}`;
        if (e.name) {
          n += ':' + e.name;
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = qm(t.view[n]);
          }
        } else {
          t.view = qm(t.view);
        }
        const i = jm(t);
        return (e) => {
          e.on(n, Sm(i), {
            priority: t.converterPriority || 'normal',
          });
        };
      }
      function Fm(t) {
        const e = Vm(t.view, 'ui');
        return (n) => {
          n.on(`addMarker:${t.model}`, vm(e), {
            priority: t.converterPriority || 'normal',
          });
          n.on(`removeMarker:${t.model}`, Am(), {
            priority: t.converterPriority || 'normal',
          });
        };
      }
      function Nm(t) {
        t = lm(t);
        const e = t.model;
        let n = t.view;
        if (!n) {
          n = (n) => ({
            group: e,
            name: n.substr(t.model.length + 1),
          });
        }
        return (i) => {
          i.on(`addMarker:${e}`, Cm(n), {
            priority: t.converterPriority || 'normal',
          });
          i.on(`removeMarker:${e}`, Dm(n), {
            priority: t.converterPriority || 'normal',
          });
        };
      }
      function Mm(t) {
        return (e) => {
          e.on(`addMarker:${t.model}`, Tm(t.view), {
            priority: t.converterPriority || 'normal',
          });
          e.on(`addMarker:${t.model}`, Bm(t.view), {
            priority: t.converterPriority || 'normal',
          });
          e.on(`removeMarker:${t.model}`, Pm(t.view), {
            priority: t.converterPriority || 'normal',
          });
        };
      }
      function Lm(t) {
        if (typeof t == 'string') {
          t = { name: t };
        }
        if (!t.attributes) {
          t.attributes = [];
        } else if (!Array.isArray(t.attributes)) {
          t.attributes = [t.attributes];
        }
        t.children = !!t.children;
        return t;
      }
      function Vm(t, e) {
        if (typeof t == 'function') {
          return t;
        }
        return (n, i) => Hm(t, i, e);
      }
      function Hm(t, e, n) {
        if (typeof t == 'string') {
          t = { name: t };
        }
        let i;
        const o = e.writer;
        const r = Object.assign({}, t.attributes);
        if (n == 'container') {
          i = o.createContainerElement(t.name, r);
        } else if (n == 'attribute') {
          const e = { priority: t.priority || _d.DEFAULT_PRIORITY };
          i = o.createAttributeElement(t.name, r, e);
        } else {
          i = o.createUIElement(t.name, r);
        }
        if (t.styles) {
          const e = Object.keys(t.styles);
          for (const n of e) {
            o.setStyle(n, t.styles[n], i);
          }
        }
        if (t.classes) {
          const e = t.classes;
          if (typeof e == 'string') {
            o.addClass(e, i);
          } else {
            for (const t of e) {
              o.addClass(t, i);
            }
          }
        }
        return i;
      }
      function jm(t) {
        if (t.model.values) {
          return (e, n, i) => {
            const o = t.view[e];
            if (o) {
              return o(e, n, i);
            }
            return null;
          };
        } else {
          return t.view;
        }
      }
      function qm(t) {
        if (typeof t == 'string') {
          return (e) => ({ key: t, value: e });
        } else if (typeof t == 'object') {
          if (t.value) {
            return () => t;
          } else {
            return (e) => ({ key: t.key, value: e });
          }
        } else {
          return t;
        }
      }
      function Wm(t, e, n) {
        const i = typeof t == 'function' ? t(e, n) : t;
        if (!i) {
          return null;
        }
        if (!i.priority) {
          i.priority = 10;
        }
        if (!i.id) {
          i.id = e.markerName;
        }
        return i;
      }
      function Um(t) {
        return (e, n) => {
          if (!e.is('element', t.name)) {
            return false;
          }
          if (n.type == 'attribute') {
            if (t.attributes.includes(n.attributeKey)) {
              return true;
            }
          } else {
            if (t.children) {
              return true;
            }
          }
          return false;
        };
      }
      function Gm(t) {
        const e = Um(t);
        return (t, n) => {
          const i = [];
          if (!n.reconvertedElements) {
            n.reconvertedElements = new Set();
          }
          for (const t of n.changes) {
            const o =
              t.type == 'attribute'
                ? t.range.start.nodeAfter
                : t.position.parent;
            if (!o || !e(o, t)) {
              i.push(t);
              continue;
            }
            if (!n.reconvertedElements.has(o)) {
              n.reconvertedElements.add(o);
              const t = Ig._createBefore(o);
              i.push(
                {
                  type: 'remove',
                  name: o.name,
                  position: t,
                  length: 1,
                },
                {
                  type: 'reinsert',
                  name: o.name,
                  position: t,
                  length: 1,
                }
              );
            }
          }
          n.changes = i;
        };
      }
      function $m(t) {
        return (e, n, i = {}) => {
          const o = ['insert'];
          for (const n of t.attributes) {
            if (e.hasAttribute(n)) {
              o.push(`attribute:${n}`);
            }
          }
          if (!o.every((t) => n.test(e, t))) {
            return false;
          }
          if (!i.preflight) {
            o.forEach((t) => n.consume(e, t));
          }
          return true;
        };
      }
      function Km(t, e, n) {
        return (i, o = 'children') => {
          const r = i.createContainerElement('$slot');
          let s = null;
          if (o === 'children') {
            s = Array.from(t.getChildren());
          } else if (typeof o == 'function') {
            s = Array.from(t.getChildren()).filter((t) => o(t));
          } else {
            throw new h(
              'conversion-slot-mode-unknown',
              n.dispatcher,
              { modeOrFilter: o }
            );
          }
          e.set(r, s);
          return r;
        };
      }
      function Zm(t, e, n) {
        const i = Array.from(e.values()).flat();
        const o = new Set(i);
        if (o.size != i.length) {
          throw new h(
            'conversion-slot-filter-overlap',
            n.dispatcher,
            { element: t }
          );
        }
        if (o.size != t.childCount) {
          throw new h(
            'conversion-slot-filter-incomplete',
            n.dispatcher,
            { element: t }
          );
        }
      }
      function Jm(t, e, n, i) {
        n.mapper.on('modelToViewPosition', s, {
          priority: 'highest',
        });
        let o = null;
        let r = null;
        for ([o, r] of e) {
          Ym(t, r, n, i);
          n.writer.move(
            n.writer.createRangeIn(o),
            n.writer.createPositionBefore(o)
          );
          n.writer.remove(o);
        }
        n.mapper.off('modelToViewPosition', s);
        function s(t, e) {
          const n = e.modelPosition.nodeAfter;
          const i = r.indexOf(n);
          if (i < 0) {
            return;
          }
          e.viewPosition = e.mapper.findPositionIn(o, i);
        }
      }
      function Ym(t, e, n, i) {
        for (const o of e) {
          if (!Qm(t.root, o, n, i)) {
            n.convertItem(o);
          }
        }
      }
      function Qm(t, e, n, i) {
        const { writer: o, mapper: r } = n;
        if (!i.reconversion) {
          return false;
        }
        const s = r.toViewElement(e);
        if (!s || s.root == t) {
          return false;
        }
        if (!n.canReuseView(s)) {
          return false;
        }
        o.move(
          o.createRangeOn(s),
          r.toViewPosition(Ig._createBefore(e))
        );
        return true;
      }
      function Xm(t, e, { preflight: n } = {}) {
        if (n) {
          return e.test(t, 'insert');
        } else {
          return e.consume(t, 'insert');
        }
      }
      function tp(t) {
        const { schema: e, document: n } = t.model;
        for (const i of n.getRootNames()) {
          const o = n.getRoot(i);
          if (o.isEmpty && !e.checkChild(o, '$text')) {
            if (e.checkChild(o, 'paragraph')) {
              t.insertElement('paragraph', o);
              return true;
            }
          }
        }
        return false;
      }
      function ep(t, e, n) {
        const i = n.createContext(t);
        if (!n.checkChild(i, 'paragraph')) {
          return false;
        }
        if (!n.checkChild(i.push('paragraph'), e)) {
          return false;
        }
        return true;
      }
      function np(t, e) {
        const n = e.createElement('paragraph');
        e.insert(n, t);
        return e.createPositionAt(n, 0);
      }
      class ip extends rm {
        elementToElement(t) {
          return this.add(ap(t));
        }
        elementToAttribute(t) {
          return this.add(cp(t));
        }
        attributeToAttribute(t) {
          return this.add(lp(t));
        }
        elementToMarker(t) {
          return this.add(dp(t));
        }
        dataToMarker(t) {
          return this.add(hp(t));
        }
      }
      function op() {
        return (t, e, n) => {
          if (
            !e.modelRange &&
            n.consumable.consume(e.viewItem, { name: true })
          ) {
            const { modelRange: t, modelCursor: i } =
              n.convertChildren(e.viewItem, e.modelCursor);
            e.modelRange = t;
            e.modelCursor = i;
          }
        };
      }
      function rp() {
        return (t, e, { schema: n, consumable: i, writer: o }) => {
          let r = e.modelCursor;
          if (!i.test(e.viewItem)) {
            return;
          }
          if (!n.checkChild(r, '$text')) {
            if (!ep(r, '$text', n)) {
              return;
            }
            if (e.viewItem.data.trim().length == 0) {
              return;
            }
            r = np(r, o);
          }
          i.consume(e.viewItem);
          const s = o.createText(e.viewItem.data);
          o.insert(s, r);
          e.modelRange = o.createRange(
            r,
            r.getShiftedBy(s.offsetSize)
          );
          e.modelCursor = e.modelRange.end;
        };
      }
      function sp(t, e) {
        return (n, i) => {
          const o = i.newSelection;
          const r = [];
          for (const t of o.getRanges()) {
            r.push(e.toModelRange(t));
          }
          const s = t.createSelection(r, { backward: o.isBackward });
          if (!s.isEqual(t.document.selection)) {
            t.change((t) => {
              t.setSelection(s);
            });
          }
        };
      }
      function ap(t) {
        t = lm(t);
        const e = gp(t);
        const n = fp(t.view);
        const i = n ? `element:${n}` : 'element';
        return (n) => {
          n.on(i, e, { priority: t.converterPriority || 'normal' });
        };
      }
      function cp(t) {
        t = lm(t);
        kp(t);
        const e = bp(t, false);
        const n = fp(t.view);
        const i = n ? `element:${n}` : 'element';
        return (n) => {
          n.on(i, e, { priority: t.converterPriority || 'low' });
        };
      }
      function lp(t) {
        t = lm(t);
        let e = null;
        if (typeof t.view == 'string' || t.view.key) {
          e = pp(t);
        }
        kp(t, e);
        const n = bp(t, true);
        return (e) => {
          e.on('element', n, {
            priority: t.converterPriority || 'low',
          });
        };
      }
      function dp(t) {
        const e = vp(t.model);
        return ap({ ...t, model: e });
      }
      function hp(t) {
        t = lm(t);
        if (!t.model) {
          t.model = (e) => (e ? t.view + ':' + e : t.view);
        }
        const e = { view: t.view, model: t.model };
        const n = gp(Ap(e, 'start'));
        const i = gp(Ap(e, 'end'));
        return (o) => {
          o.on(`element:${t.view}-start`, n, {
            priority: t.converterPriority || 'normal',
          });
          o.on(`element:${t.view}-end`, i, {
            priority: t.converterPriority || 'normal',
          });
          const r = c.get('low');
          const s = c.get('highest');
          const a = c.get(t.converterPriority) / s;
          o.on('element', up(e), { priority: r + a });
        };
      }
      function up(t) {
        return (e, n, i) => {
          const o = `data-${t.view}`;
          if (
            !i.consumable.test(n.viewItem, {
              attributes: o + '-end-after',
            }) &&
            !i.consumable.test(n.viewItem, {
              attributes: o + '-start-after',
            }) &&
            !i.consumable.test(n.viewItem, {
              attributes: o + '-end-before',
            }) &&
            !i.consumable.test(n.viewItem, {
              attributes: o + '-start-before',
            })
          ) {
            return;
          }
          if (!n.modelRange) {
            Object.assign(
              n,
              i.convertChildren(n.viewItem, n.modelCursor)
            );
          }
          if (
            i.consumable.consume(n.viewItem, {
              attributes: o + '-end-after',
            })
          ) {
            r(
              n.modelRange.end,
              n.viewItem.getAttribute(o + '-end-after').split(',')
            );
          }
          if (
            i.consumable.consume(n.viewItem, {
              attributes: o + '-start-after',
            })
          ) {
            r(
              n.modelRange.end,
              n.viewItem.getAttribute(o + '-start-after').split(',')
            );
          }
          if (
            i.consumable.consume(n.viewItem, {
              attributes: o + '-end-before',
            })
          ) {
            r(
              n.modelRange.start,
              n.viewItem.getAttribute(o + '-end-before').split(',')
            );
          }
          if (
            i.consumable.consume(n.viewItem, {
              attributes: o + '-start-before',
            })
          ) {
            r(
              n.modelRange.start,
              n.viewItem.getAttribute(o + '-start-before').split(',')
            );
          }
          function r(e, o) {
            for (const r of o) {
              const o = t.model(r, i);
              const s = i.writer.createElement('$marker', {
                'data-name': o,
              });
              i.writer.insert(s, e);
              if (n.modelCursor.isEqual(e)) {
                n.modelCursor = n.modelCursor.getShiftedBy(1);
              } else {
                n.modelCursor =
                  n.modelCursor._getTransformedByInsertion(e, 1);
              }
              n.modelRange = n.modelRange._getTransformedByInsertion(
                e,
                1
              )[0];
            }
          }
        };
      }
      function fp(t) {
        if (typeof t == 'string') {
          return t;
        }
        if (typeof t == 'object' && typeof t.name == 'string') {
          return t.name;
        }
        return null;
      }
      function gp(t) {
        const e = new Ja(t.view);
        return (n, i, o) => {
          const r = e.match(i.viewItem);
          if (!r) {
            return;
          }
          const s = r.match;
          s.name = true;
          if (!o.consumable.test(i.viewItem, s)) {
            return;
          }
          const a = mp(t.model, i.viewItem, o);
          if (!a) {
            return;
          }
          if (!o.safeInsert(a, i.modelCursor)) {
            return;
          }
          o.consumable.consume(i.viewItem, s);
          o.convertChildren(i.viewItem, a);
          o.updateConversionResult(a, i);
        };
      }
      function mp(t, e, n) {
        if (t instanceof Function) {
          return t(e, n);
        } else {
          return n.writer.createElement(t);
        }
      }
      function pp(t) {
        if (typeof t.view == 'string') {
          t.view = { key: t.view };
        }
        const e = t.view.key;
        let n;
        if (e == 'class' || e == 'style') {
          const i = e == 'class' ? 'classes' : 'styles';
          n = { [i]: t.view.value };
        } else {
          const i =
            typeof t.view.value == 'undefined'
              ? /[\s\S]*/
              : t.view.value;
          n = { attributes: { [e]: i } };
        }
        if (t.view.name) {
          n.name = t.view.name;
        }
        t.view = n;
        return e;
      }
      function kp(t, e = null) {
        const n = e === null ? true : (t) => t.getAttribute(e);
        const i = typeof t.model != 'object' ? t.model : t.model.key;
        const o =
          typeof t.model != 'object' ||
          typeof t.model.value == 'undefined'
            ? n
            : t.model.value;
        t.model = { key: i, value: o };
      }
      function bp(t, e) {
        const n = new Ja(t.view);
        return (i, o, r) => {
          if (!o.modelRange && e) {
            return;
          }
          const s = n.match(o.viewItem);
          if (!s) {
            return;
          }
          if (wp(t.view, o.viewItem)) {
            s.match.name = true;
          } else {
            delete s.match.name;
          }
          if (!r.consumable.test(o.viewItem, s.match)) {
            return;
          }
          const a = t.model.key;
          const c =
            typeof t.model.value == 'function'
              ? t.model.value(o.viewItem, r)
              : t.model.value;
          if (c === null) {
            return;
          }
          if (!o.modelRange) {
            Object.assign(
              o,
              r.convertChildren(o.viewItem, o.modelCursor)
            );
          }
          const l = _p(o.modelRange, { key: a, value: c }, e, r);
          if (l) {
            if (r.consumable.test(o.viewItem, { name: true })) {
              s.match.name = true;
            }
            r.consumable.consume(o.viewItem, s.match);
          }
        };
      }
      function wp(t, e) {
        const n = typeof t == 'function' ? t(e) : t;
        if (typeof n == 'object' && !fp(n)) {
          return false;
        }
        return !n.classes && !n.attributes && !n.styles;
      }
      function _p(t, e, n, i) {
        let o = false;
        for (const r of Array.from(t.getItems({ shallow: n }))) {
          if (!i.schema.checkAttribute(r, e.key)) {
            continue;
          }
          o = true;
          if (r.hasAttribute(e.key)) {
            continue;
          }
          i.writer.setAttribute(e.key, e.value, r);
        }
        return o;
      }
      function vp(t) {
        return (e, n) => {
          const i = typeof t == 'string' ? t : t(e, n);
          return n.writer.createElement('$marker', {
            'data-name': i,
          });
        };
      }
      function Ap(t, e) {
        const n = (e, n) => {
          const i = e.getAttribute('name');
          const o = t.model(i, n);
          return n.writer.createElement('$marker', {
            'data-name': o,
          });
        };
        return { view: `${t.view}-${e}`, model: n };
      }
      class Cp extends W {
        constructor(t, e) {
          super();
          this.model = t;
          this.view = new Ag(e);
          this.mapper = new Ng();
          this.downcastDispatcher = new Vg({
            mapper: this.mapper,
            schema: t.schema,
          });
          const n = this.model.document;
          const i = n.selection;
          const o = this.model.markers;
          this.listenTo(
            this.model,
            '_beforeChanges',
            () => {
              this.view._disableRendering(true);
            },
            { priority: 'highest' }
          );
          this.listenTo(
            this.model,
            '_afterChanges',
            () => {
              this.view._disableRendering(false);
            },
            { priority: 'lowest' }
          );
          this.listenTo(
            n,
            'change',
            () => {
              this.view.change((t) => {
                this.downcastDispatcher.convertChanges(
                  n.differ,
                  o,
                  t
                );
                this.downcastDispatcher.convertSelection(i, o, t);
              });
            },
            { priority: 'low' }
          );
          this.listenTo(
            this.view.document,
            'selectionChange',
            sp(this.model, this.mapper)
          );
          this.downcastDispatcher.on('insert:$text', hm(), {
            priority: 'lowest',
          });
          this.downcastDispatcher.on('insert', um(), {
            priority: 'lowest',
          });
          this.downcastDispatcher.on('remove', fm(), {
            priority: 'low',
          });
          this.downcastDispatcher.on('selection', km(), {
            priority: 'high',
          });
          this.downcastDispatcher.on('selection', mm(), {
            priority: 'low',
          });
          this.downcastDispatcher.on('selection', pm(), {
            priority: 'low',
          });
          this.view.document.roots
            .bindTo(this.model.document.roots)
            .using((t) => {
              if (t.rootName == '$graveyard') {
                return null;
              }
              const e = new nd(this.view.document, t.name);
              e.rootName = t.rootName;
              this.mapper.bindElements(t, e);
              return e;
            });
        }
        destroy() {
          this.view.destroy();
          this.stopListening();
        }
        reconvertMarker(t) {
          const e = typeof t == 'string' ? t : t.name;
          const n = this.model.markers.get(e);
          if (!n) {
            throw new h(
              'editingcontroller-reconvertmarker-marker-not-exist',
              this,
              { markerName: e }
            );
          }
          this.model.change(() => {
            this.model.markers._refresh(n);
          });
        }
        reconvertItem(t) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(t);
          });
        }
      }
      class yp {
        constructor() {
          this._commands = new Map();
        }
        add(t, e) {
          this._commands.set(t, e);
        }
        get(t) {
          return this._commands.get(t);
        }
        execute(t, ...e) {
          const n = this.get(t);
          if (!n) {
            throw new h('commandcollection-command-not-found', this, {
              commandName: t,
            });
          }
          return n.execute(...e);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const t of this.commands()) {
            t.destroy();
          }
        }
      }
      class xp {
        constructor() {
          this._consumables = new Map();
        }
        add(t, e) {
          let n;
          if (t.is('$text') || t.is('documentFragment')) {
            this._consumables.set(t, true);
            return;
          }
          if (!this._consumables.has(t)) {
            n = new Dp(t);
            this._consumables.set(t, n);
          } else {
            n = this._consumables.get(t);
          }
          n.add(e);
        }
        test(t, e) {
          const n = this._consumables.get(t);
          if (n === undefined) {
            return null;
          }
          if (t.is('$text') || t.is('documentFragment')) {
            return n;
          }
          return n.test(e);
        }
        consume(t, e) {
          if (this.test(t, e)) {
            if (t.is('$text') || t.is('documentFragment')) {
              this._consumables.set(t, false);
            } else {
              this._consumables.get(t).consume(e);
            }
            return true;
          }
          return false;
        }
        revert(t, e) {
          const n = this._consumables.get(t);
          if (n !== undefined) {
            if (t.is('$text') || t.is('documentFragment')) {
              this._consumables.set(t, true);
            } else {
              n.revert(e);
            }
          }
        }
        static consumablesFromElement(t) {
          const e = {
            element: t,
            name: true,
            attributes: [],
            classes: [],
            styles: [],
          };
          const n = t.getAttributeKeys();
          for (const t of n) {
            if (t == 'style' || t == 'class') {
              continue;
            }
            e.attributes.push(t);
          }
          const i = t.getClassNames();
          for (const t of i) {
            e.classes.push(t);
          }
          const o = t.getStyleNames();
          for (const t of o) {
            e.styles.push(t);
          }
          return e;
        }
        static createFrom(t, e) {
          if (!e) {
            e = new xp();
          }
          if (t.is('$text')) {
            e.add(t);
            return e;
          }
          if (t.is('element')) {
            e.add(t, xp.consumablesFromElement(t));
          }
          if (t.is('documentFragment')) {
            e.add(t);
          }
          for (const n of t.getChildren()) {
            e = xp.createFrom(n, e);
          }
          return e;
        }
      }
      const Ep = ['attributes', 'classes', 'styles'];
      class Dp {
        constructor(t) {
          this.element = t;
          this._canConsumeName = null;
          this._consumables = {
            attributes: new Map(),
            styles: new Map(),
            classes: new Map(),
          };
        }
        add(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e of Ep) {
            if (e in t) {
              this._add(e, t[e]);
            }
          }
        }
        test(t) {
          if (t.name && !this._canConsumeName) {
            return this._canConsumeName;
          }
          for (const e of Ep) {
            if (e in t) {
              const n = this._test(e, t[e]);
              if (n !== true) {
                return n;
              }
            }
          }
          return true;
        }
        consume(t) {
          if (t.name) {
            this._canConsumeName = false;
          }
          for (const e of Ep) {
            if (e in t) {
              this._consume(e, t[e]);
            }
          }
        }
        revert(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e of Ep) {
            if (e in t) {
              this._revert(e, t[e]);
            }
          }
        }
        _add(t, e) {
          const n = ni(e) ? e : [e];
          const i = this._consumables[t];
          for (const e of n) {
            if (
              t === 'attributes' &&
              (e === 'class' || e === 'style')
            ) {
              throw new h('viewconsumable-invalid-attribute', this);
            }
            i.set(e, true);
            if (t === 'styles') {
              for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                e
              )) {
                i.set(t, true);
              }
            }
          }
        }
        _test(t, e) {
          const n = ni(e) ? e : [e];
          const i = this._consumables[t];
          for (const e of n) {
            if (
              t === 'attributes' &&
              (e === 'class' || e === 'style')
            ) {
              const t = e == 'class' ? 'classes' : 'styles';
              const n = this._test(t, [
                ...this._consumables[t].keys(),
              ]);
              if (n !== true) {
                return n;
              }
            } else {
              const t = i.get(e);
              if (t === undefined) {
                return null;
              }
              if (!t) {
                return false;
              }
            }
          }
          return true;
        }
        _consume(t, e) {
          const n = ni(e) ? e : [e];
          const i = this._consumables[t];
          for (const e of n) {
            if (
              t === 'attributes' &&
              (e === 'class' || e === 'style')
            ) {
              const t = e == 'class' ? 'classes' : 'styles';
              this._consume(t, [...this._consumables[t].keys()]);
            } else {
              i.set(e, false);
              if (t == 'styles') {
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                  e
                )) {
                  i.set(t, false);
                }
              }
            }
          }
        }
        _revert(t, e) {
          const n = ni(e) ? e : [e];
          const i = this._consumables[t];
          for (const e of n) {
            if (
              t === 'attributes' &&
              (e === 'class' || e === 'style')
            ) {
              const t = e == 'class' ? 'classes' : 'styles';
              this._revert(t, [...this._consumables[t].keys()]);
            } else {
              const t = i.get(e);
              if (t === false) {
                i.set(e, true);
              }
            }
          }
        }
      }
      class Sp extends W {
        constructor() {
          super();
          this._sourceDefinitions = {};
          this._attributeProperties = {};
          this.decorate('checkChild');
          this.decorate('checkAttribute');
          this.on(
            'checkAttribute',
            (t, e) => {
              e[0] = new Tp(e[0]);
            },
            { priority: 'highest' }
          );
          this.on(
            'checkChild',
            (t, e) => {
              e[0] = new Tp(e[0]);
              e[1] = this.getDefinition(e[1]);
            },
            { priority: 'highest' }
          );
        }
        register(t, e) {
          if (this._sourceDefinitions[t]) {
            throw new h('schema-cannot-register-item-twice', this, {
              itemName: t,
            });
          }
          this._sourceDefinitions[t] = [Object.assign({}, e)];
          this._clearCache();
        }
        extend(t, e) {
          if (!this._sourceDefinitions[t]) {
            throw new h('schema-cannot-extend-missing-item', this, {
              itemName: t,
            });
          }
          this._sourceDefinitions[t].push(Object.assign({}, e));
          this._clearCache();
        }
        getDefinitions() {
          if (!this._compiledDefinitions) {
            this._compile();
          }
          return this._compiledDefinitions;
        }
        getDefinition(t) {
          let e;
          if (typeof t == 'string') {
            e = t;
          } else if (
            'is' in t &&
            (t.is('$text') || t.is('$textProxy'))
          ) {
            e = '$text';
          } else {
            e = t.name;
          }
          return this.getDefinitions()[e];
        }
        isRegistered(t) {
          return !!this.getDefinition(t);
        }
        isBlock(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isBlock);
        }
        isLimit(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isLimit || e.isObject);
        }
        isObject(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(
            e.isObject ||
            (e.isLimit && e.isSelectable && e.isContent)
          );
        }
        isInline(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isInline);
        }
        isSelectable(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isSelectable || e.isObject);
        }
        isContent(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isContent || e.isObject);
        }
        checkChild(t, e) {
          if (!e) {
            return false;
          }
          return this._checkContextMatch(e, t);
        }
        checkAttribute(t, e) {
          const n = this.getDefinition(t.last);
          if (!n) {
            return false;
          }
          return n.allowAttributes.includes(e);
        }
        checkMerge(t, e) {
          if (t instanceof Ig) {
            const e = t.nodeBefore;
            const n = t.nodeAfter;
            if (!(e instanceof Sg)) {
              throw new h(
                'schema-check-merge-no-element-before',
                this
              );
            }
            if (!(n instanceof Sg)) {
              throw new h(
                'schema-check-merge-no-element-after',
                this
              );
            }
            return this.checkMerge(e, n);
          }
          for (const n of e.getChildren()) {
            if (!this.checkChild(t, n)) {
              return false;
            }
          }
          return true;
        }
        addChildCheck(t) {
          this.on(
            'checkChild',
            (e, [n, i]) => {
              if (!i) {
                return;
              }
              const o = t(n, i);
              if (typeof o == 'boolean') {
                e.stop();
                e.return = o;
              }
            },
            { priority: 'high' }
          );
        }
        addAttributeCheck(t) {
          this.on(
            'checkAttribute',
            (e, [n, i]) => {
              const o = t(n, i);
              if (typeof o == 'boolean') {
                e.stop();
                e.return = o;
              }
            },
            { priority: 'high' }
          );
        }
        setAttributeProperties(t, e) {
          this._attributeProperties[t] = Object.assign(
            this.getAttributeProperties(t),
            e
          );
        }
        getAttributeProperties(t) {
          return this._attributeProperties[t] || {};
        }
        getLimitElement(t) {
          let e;
          if (t instanceof Ig) {
            e = t.parent;
          } else {
            const n =
              t instanceof Fg ? [t] : Array.from(t.getRanges());
            e = n.reduce((t, e) => {
              const n = e.getCommonAncestor();
              if (!t) {
                return n;
              }
              return t.getCommonAncestor(n, { includeSelf: true });
            }, null);
          }
          while (!this.isLimit(e)) {
            if (e.parent) {
              e = e.parent;
            } else {
              break;
            }
          }
          return e;
        }
        checkAttributeInSelection(t, e) {
          if (t.isCollapsed) {
            const n = t.getFirstPosition();
            const i = [
              ...n.getAncestors(),
              new Eg('', t.getAttributes()),
            ];
            return this.checkAttribute(i, e);
          } else {
            const n = t.getRanges();
            for (const t of n) {
              for (const n of t) {
                if (this.checkAttribute(n.item, e)) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        *getValidRanges(t, e) {
          t = Gp(t);
          for (const n of t) {
            yield* this._getValidRangesForRange(n, e);
          }
        }
        getNearestSelectionRange(t, e = 'both') {
          if (this.checkChild(t, '$text')) {
            return new Fg(t);
          }
          let n, i;
          const o =
            t
              .getAncestors()
              .reverse()
              .find((t) => this.isLimit(t)) || t.root;
          if (e == 'both' || e == 'backward') {
            n = new Bg({
              boundaries: Fg._createIn(o),
              startPosition: t,
              direction: 'backward',
            });
          }
          if (e == 'both' || e == 'forward') {
            i = new Bg({
              boundaries: Fg._createIn(o),
              startPosition: t,
            });
          }
          for (const t of Up(n, i)) {
            const e = t.walker == n ? 'elementEnd' : 'elementStart';
            const i = t.value;
            if (i.type == e && this.isObject(i.item)) {
              return Fg._createOn(i.item);
            }
            if (this.checkChild(i.nextPosition, '$text')) {
              return new Fg(i.nextPosition);
            }
          }
          return null;
        }
        findAllowedParent(t, e) {
          let n = t.parent;
          while (n) {
            if (this.checkChild(n, e)) {
              return n;
            }
            if (this.isLimit(n)) {
              return null;
            }
            n = n.parent;
          }
          return null;
        }
        setAllowedAttributes(t, e, n) {
          const i = n.model;
          for (const [o, r] of Object.entries(e)) {
            if (i.schema.checkAttribute(t, o)) {
              n.setAttribute(o, r, t);
            }
          }
        }
        removeDisallowedAttributes(t, e) {
          for (const n of t) {
            if (n.is('$text')) {
              $p(this, n, e);
            } else {
              const t = Fg._createIn(n);
              const i = t.getPositions();
              for (const t of i) {
                const n = t.nodeBefore || t.parent;
                $p(this, n, e);
              }
            }
          }
        }
        getAttributesWithProperty(t, e, n) {
          const i = {};
          for (const [o, r] of t.getAttributes()) {
            const t = this.getAttributeProperties(o);
            if (t[e] === undefined) {
              continue;
            }
            if (n === undefined || n === t[e]) {
              i[o] = r;
            }
          }
          return i;
        }
        createContext(t) {
          return new Tp(t);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const t = {};
          const e = this._sourceDefinitions;
          const n = Object.keys(e);
          for (const i of n) {
            t[i] = Bp(e[i], i);
          }
          for (const e of n) {
            Pp(t, e);
          }
          for (const e of n) {
            Ip(t, e);
          }
          for (const e of n) {
            Rp(t, e);
          }
          for (const e of n) {
            zp(t, e);
            Op(t, e);
          }
          for (const e of n) {
            Fp(t, e);
            Np(t, e);
            Mp(t, e);
          }
          this._compiledDefinitions = t;
        }
        _checkContextMatch(t, e, n = e.length - 1) {
          const i = e.getItem(n);
          if (t.allowIn.includes(i.name)) {
            if (n == 0) {
              return true;
            } else {
              const t = this.getDefinition(i);
              return this._checkContextMatch(t, e, n - 1);
            }
          } else {
            return false;
          }
        }
        *_getValidRangesForRange(t, e) {
          let n = t.start;
          let i = t.start;
          for (const o of t.getItems({ shallow: true })) {
            if (o.is('element')) {
              yield* this._getValidRangesForRange(Fg._createIn(o), e);
            }
            if (!this.checkAttribute(o, e)) {
              if (!n.isEqual(i)) {
                yield new Fg(n, i);
              }
              n = Ig._createAfter(o);
            }
            i = Ig._createAfter(o);
          }
          if (!n.isEqual(i)) {
            yield new Fg(n, i);
          }
        }
      }
      class Tp {
        constructor(t) {
          if (t instanceof Tp) {
            return t;
          }
          let e;
          if (typeof t == 'string') {
            e = [t];
          } else if (!Array.isArray(t)) {
            e = t.getAncestors({ includeSelf: true });
          } else {
            e = t;
          }
          this._items = e.map(Wp);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(t) {
          const e = new Tp([t]);
          e._items = [...this._items, ...e._items];
          return e;
        }
        getItem(t) {
          return this._items[t];
        }
        *getNames() {
          yield* this._items.map((t) => t.name);
        }
        endsWith(t) {
          return Array.from(this.getNames()).join(' ').endsWith(t);
        }
        startsWith(t) {
          return Array.from(this.getNames()).join(' ').startsWith(t);
        }
      }
      function Bp(t, e) {
        const n = {
          name: e,
          allowIn: [],
          allowContentOf: [],
          allowWhere: [],
          allowAttributes: [],
          allowAttributesOf: [],
          allowChildren: [],
          inheritTypesFrom: [],
        };
        Lp(t, n);
        Vp(t, n, 'allowIn');
        Vp(t, n, 'allowContentOf');
        Vp(t, n, 'allowWhere');
        Vp(t, n, 'allowAttributes');
        Vp(t, n, 'allowAttributesOf');
        Vp(t, n, 'allowChildren');
        Vp(t, n, 'inheritTypesFrom');
        Hp(t, n);
        return n;
      }
      function Pp(t, e) {
        const n = t[e];
        for (const i of n.allowChildren) {
          const n = t[i];
          if (!n) {
            continue;
          }
          n.allowIn.push(e);
        }
        n.allowChildren.length = 0;
      }
      function Ip(t, e) {
        for (const n of t[e].allowContentOf) {
          if (t[n]) {
            const i = jp(t, n);
            i.forEach((t) => {
              t.allowIn.push(e);
            });
          }
        }
        delete t[e].allowContentOf;
      }
      function Rp(t, e) {
        for (const n of t[e].allowWhere) {
          const i = t[n];
          if (i) {
            const n = i.allowIn;
            t[e].allowIn.push(...n);
          }
        }
        delete t[e].allowWhere;
      }
      function zp(t, e) {
        for (const n of t[e].allowAttributesOf) {
          const i = t[n];
          if (i) {
            const n = i.allowAttributes;
            t[e].allowAttributes.push(...n);
          }
        }
        delete t[e].allowAttributesOf;
      }
      function Op(t, e) {
        const n = t[e];
        for (const e of n.inheritTypesFrom) {
          const i = t[e];
          if (i) {
            const t = Object.keys(i).filter((t) =>
              t.startsWith('is')
            );
            for (const e of t) {
              if (!(e in n)) {
                n[e] = i[e];
              }
            }
          }
        }
        delete n.inheritTypesFrom;
      }
      function Fp(t, e) {
        const n = t[e];
        const i = n.allowIn.filter((e) => t[e]);
        n.allowIn = Array.from(new Set(i));
      }
      function Np(t, e) {
        const n = t[e];
        for (const i of n.allowIn) {
          const n = t[i];
          n.allowChildren.push(e);
        }
      }
      function Mp(t, e) {
        const n = t[e];
        n.allowAttributes = Array.from(new Set(n.allowAttributes));
      }
      function Lp(t, e) {
        for (const n of t) {
          const t = Object.keys(n).filter((t) => t.startsWith('is'));
          for (const i of t) {
            e[i] = !!n[i];
          }
        }
      }
      function Vp(t, e, n) {
        for (const i of t) {
          const t = i[n];
          if (typeof t == 'string') {
            e[n].push(t);
          } else if (Array.isArray(t)) {
            e[n].push(...t);
          }
        }
      }
      function Hp(t, e) {
        for (const n of t) {
          const t = n.inheritAllFrom;
          if (t) {
            e.allowContentOf.push(t);
            e.allowWhere.push(t);
            e.allowAttributesOf.push(t);
            e.inheritTypesFrom.push(t);
          }
        }
      }
      function jp(t, e) {
        const n = t[e];
        return qp(t).filter((t) => t.allowIn.includes(n.name));
      }
      function qp(t) {
        return Object.keys(t).map((e) => t[e]);
      }
      function Wp(t) {
        if (typeof t == 'string' || t.is('documentFragment')) {
          return {
            name: typeof t == 'string' ? t : '$documentFragment',
            *getAttributeKeys() {},
            getAttribute() {},
          };
        } else {
          return {
            name: t.is('element') ? t.name : '$text',
            *getAttributeKeys() {
              yield* t.getAttributeKeys();
            },
            getAttribute(e) {
              return t.getAttribute(e);
            },
          };
        }
      }
      function* Up(t, e) {
        let n = false;
        while (!n) {
          n = true;
          if (t) {
            const e = t.next();
            if (!e.done) {
              n = false;
              yield { walker: t, value: e.value };
            }
          }
          if (e) {
            const t = e.next();
            if (!t.done) {
              n = false;
              yield { walker: e, value: t.value };
            }
          }
        }
      }
      function* Gp(t) {
        for (const e of t) {
          yield* e.getMinimalFlatRanges();
        }
      }
      function $p(t, e, n) {
        for (const i of e.getAttributeKeys()) {
          if (!t.checkAttribute(e, i)) {
            n.removeAttribute(i, e);
          }
        }
      }
      class Kp extends y {
        constructor(t) {
          super();
          this._splitParts = new Map();
          this._cursorParents = new Map();
          this._modelCursor = null;
          this._emptyElementsToKeep = new Set();
          this.conversionApi = {
            ...t,
            consumable: null,
            writer: null,
            store: null,
            convertItem: (t, e) => this._convertItem(t, e),
            convertChildren: (t, e) => this._convertChildren(t, e),
            safeInsert: (t, e) => this._safeInsert(t, e),
            updateConversionResult: (t, e) =>
              this._updateConversionResult(t, e),
            splitToAllowedParent: (t, e) =>
              this._splitToAllowedParent(t, e),
            getSplitParts: (t) => this._getSplitParts(t),
            keepEmptyElement: (t) => this._keepEmptyElement(t),
          };
        }
        convert(t, e, n = ['$root']) {
          this.fire('viewCleanup', t);
          this._modelCursor = Jp(n, e);
          this.conversionApi.writer = e;
          this.conversionApi.consumable = xp.createFrom(t);
          this.conversionApi.store = {};
          const { modelRange: i } = this._convertItem(
            t,
            this._modelCursor
          );
          const o = e.createDocumentFragment();
          if (i) {
            this._removeEmptyElements();
            for (const t of Array.from(
              this._modelCursor.parent.getChildren()
            )) {
              e.append(t, o);
            }
            o.markers = Zp(o, e);
          }
          this._modelCursor = null;
          this._splitParts.clear();
          this._cursorParents.clear();
          this._emptyElementsToKeep.clear();
          this.conversionApi.writer = null;
          this.conversionApi.store = null;
          return o;
        }
        _convertItem(t, e) {
          const n = { viewItem: t, modelCursor: e, modelRange: null };
          if (t.is('element')) {
            this.fire(`element:${t.name}`, n, this.conversionApi);
          } else if (t.is('$text')) {
            this.fire('text', n, this.conversionApi);
          } else {
            this.fire('documentFragment', n, this.conversionApi);
          }
          if (n.modelRange && !(n.modelRange instanceof Fg)) {
            throw new h(
              'view-conversion-dispatcher-incorrect-result',
              this
            );
          }
          return {
            modelRange: n.modelRange,
            modelCursor: n.modelCursor,
          };
        }
        _convertChildren(t, e) {
          let n = e.is('position') ? e : Ig._createAt(e, 0);
          const i = new Fg(n);
          for (const e of Array.from(t.getChildren())) {
            const t = this._convertItem(e, n);
            if (t.modelRange instanceof Fg) {
              i.end = t.modelRange.end;
              n = t.modelCursor;
            }
          }
          return { modelRange: i, modelCursor: n };
        }
        _safeInsert(t, e) {
          const n = this._splitToAllowedParent(t, e);
          if (!n) {
            return false;
          }
          this.conversionApi.writer.insert(t, n.position);
          return true;
        }
        _updateConversionResult(t, e) {
          const n = this._getSplitParts(t);
          const i = this.conversionApi.writer;
          if (!e.modelRange) {
            e.modelRange = i.createRange(
              i.createPositionBefore(t),
              i.createPositionAfter(n[n.length - 1])
            );
          }
          const o = this._cursorParents.get(t);
          if (o) {
            e.modelCursor = i.createPositionAt(o, 0);
          } else {
            e.modelCursor = e.modelRange.end;
          }
        }
        _splitToAllowedParent(t, e) {
          const { schema: n, writer: i } = this.conversionApi;
          let o = n.findAllowedParent(e, t);
          if (o) {
            if (o === e.parent) {
              return { position: e };
            }
            if (this._modelCursor.parent.getAncestors().includes(o)) {
              o = null;
            }
          }
          if (!o) {
            if (!ep(e, t, n)) {
              return null;
            }
            return { position: np(e, i) };
          }
          const r = this.conversionApi.writer.split(e, o);
          const s = [];
          for (const t of r.range.getWalker()) {
            if (t.type == 'elementEnd') {
              s.push(t.item);
            } else {
              const e = s.pop();
              const n = t.item;
              this._registerSplitPair(e, n);
            }
          }
          const a = r.range.end.parent;
          this._cursorParents.set(t, a);
          return { position: r.position, cursorParent: a };
        }
        _registerSplitPair(t, e) {
          if (!this._splitParts.has(t)) {
            this._splitParts.set(t, [t]);
          }
          const n = this._splitParts.get(t);
          this._splitParts.set(e, n);
          n.push(e);
        }
        _getSplitParts(t) {
          let e;
          if (!this._splitParts.has(t)) {
            e = [t];
          } else {
            e = this._splitParts.get(t);
          }
          return e;
        }
        _keepEmptyElement(t) {
          this._emptyElementsToKeep.add(t);
        }
        _removeEmptyElements() {
          let t = false;
          for (const e of this._splitParts.keys()) {
            if (e.isEmpty && !this._emptyElementsToKeep.has(e)) {
              this.conversionApi.writer.remove(e);
              this._splitParts.delete(e);
              t = true;
            }
          }
          if (t) {
            this._removeEmptyElements();
          }
        }
      }
      function Zp(t, e) {
        const n = new Set();
        const i = new Map();
        const o = Fg._createIn(t).getItems();
        for (const t of o) {
          if (t.is('element', '$marker')) {
            n.add(t);
          }
        }
        for (const t of n) {
          const n = t.getAttribute('data-name');
          const o = e.createPositionBefore(t);
          if (!i.has(n)) {
            i.set(n, new Fg(o.clone()));
          } else {
            i.get(n).end = o.clone();
          }
          e.remove(t);
        }
        return i;
      }
      function Jp(t, e) {
        let n;
        for (const i of new Tp(t)) {
          const t = {};
          for (const e of i.getAttributeKeys()) {
            t[e] = i.getAttribute(e);
          }
          const o = e.createElement(i.name, t);
          if (n) {
            e.insert(o, n);
          }
          n = Ig._createAt(o, 0);
        }
        return n;
      }
      class Yp {
        getHtml(t) {
          const e = document.implementation.createHTMLDocument('');
          const n = e.createElement('div');
          n.appendChild(t);
          return n.innerHTML;
        }
      }
      class Qp {
        constructor(t) {
          this.domParser = new DOMParser();
          this.domConverter = new ru(t, { renderingMode: 'data' });
          this.htmlWriter = new Yp();
        }
        toData(t) {
          const e = this.domConverter.viewToDom(t);
          return this.htmlWriter.getHtml(e);
        }
        toView(t) {
          const e = this._toDom(t);
          return this.domConverter.domToView(e);
        }
        registerRawContentMatcher(t) {
          this.domConverter.registerRawContentMatcher(t);
        }
        useFillerType(t) {
          this.domConverter.blockFillerMode =
            t == 'marked' ? 'markedNbsp' : 'nbsp';
        }
        _toDom(t) {
          if (!t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
            t = `<body>${t}</body>`;
          }
          const e = this.domParser.parseFromString(t, 'text/html');
          const n = e.createDocumentFragment();
          const i = e.body.childNodes;
          while (i.length > 0) {
            n.appendChild(i[0]);
          }
          return n;
        }
      }
      class Xp extends y {
        constructor(t, e) {
          super();
          this.model = t;
          this.mapper = new Ng();
          this.downcastDispatcher = new Vg({
            mapper: this.mapper,
            schema: t.schema,
          });
          this.downcastDispatcher.on('insert:$text', hm(), {
            priority: 'lowest',
          });
          this.downcastDispatcher.on('insert', um(), {
            priority: 'lowest',
          });
          this.upcastDispatcher = new Kp({ schema: t.schema });
          this.viewDocument = new bd(e);
          this.stylesProcessor = e;
          this.htmlProcessor = new Qp(this.viewDocument);
          this.processor = this.htmlProcessor;
          this._viewWriter = new oh(this.viewDocument);
          this.upcastDispatcher.on('text', rp(), {
            priority: 'lowest',
          });
          this.upcastDispatcher.on('element', op(), {
            priority: 'lowest',
          });
          this.upcastDispatcher.on('documentFragment', op(), {
            priority: 'lowest',
          });
          W.prototype.decorate.call(this, 'init');
          W.prototype.decorate.call(this, 'set');
          W.prototype.decorate.call(this, 'get');
          this.on(
            'init',
            () => {
              this.fire('ready');
            },
            { priority: 'lowest' }
          );
          this.on(
            'ready',
            () => {
              this.model.enqueueChange({ isUndoable: false }, tp);
            },
            { priority: 'lowest' }
          );
        }
        get(t = {}) {
          const { rootName: e = 'main', trim: n = 'empty' } = t;
          if (!this._checkIfRootsExists([e])) {
            throw new h('datacontroller-get-non-existent-root', this);
          }
          const i = this.model.document.getRoot(e);
          if (
            n === 'empty' &&
            !this.model.hasContent(i, { ignoreWhitespaces: true })
          ) {
            return '';
          }
          return this.stringify(i, t);
        }
        stringify(t, e = {}) {
          const n = this.toView(t, e);
          return this.processor.toData(n);
        }
        toView(t, e = {}) {
          const n = this.viewDocument;
          const i = this._viewWriter;
          this.mapper.clearBindings();
          const o = Fg._createIn(t);
          const r = new nh(n);
          this.mapper.bindElements(t, r);
          const s = t.is('documentFragment') ? t.markers : tk(t);
          this.downcastDispatcher.convert(o, s, i, e);
          return r;
        }
        init(t) {
          if (this.model.document.version) {
            throw new h(
              'datacontroller-init-document-not-empty',
              this
            );
          }
          let e = {};
          if (typeof t === 'string') {
            e.main = t;
          } else {
            e = t;
          }
          if (!this._checkIfRootsExists(Object.keys(e))) {
            throw new h(
              'datacontroller-init-non-existent-root',
              this
            );
          }
          this.model.enqueueChange({ isUndoable: false }, (t) => {
            for (const n of Object.keys(e)) {
              const i = this.model.document.getRoot(n);
              t.insert(this.parse(e[n], i), i, 0);
            }
          });
          return Promise.resolve();
        }
        set(t, e = {}) {
          let n = {};
          if (typeof t === 'string') {
            n.main = t;
          } else {
            n = t;
          }
          if (!this._checkIfRootsExists(Object.keys(n))) {
            throw new h('datacontroller-set-non-existent-root', this);
          }
          this.model.enqueueChange(e.batchType || {}, (t) => {
            t.setSelection(null);
            t.removeSelectionAttribute(
              this.model.document.selection.getAttributeKeys()
            );
            for (const e of Object.keys(n)) {
              const i = this.model.document.getRoot(e);
              t.remove(t.createRangeIn(i));
              t.insert(this.parse(n[e], i), i, 0);
            }
          });
        }
        parse(t, e = '$root') {
          const n = this.processor.toView(t);
          return this.toModel(n, e);
        }
        toModel(t, e = '$root') {
          return this.model.change((n) =>
            this.upcastDispatcher.convert(t, n, e)
          );
        }
        addStyleProcessorRules(t) {
          t(this.stylesProcessor);
        }
        registerRawContentMatcher(t) {
          if (
            this.processor &&
            this.processor !== this.htmlProcessor
          ) {
            this.processor.registerRawContentMatcher(t);
          }
          this.htmlProcessor.registerRawContentMatcher(t);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(t) {
          for (const e of t) {
            if (!this.model.document.getRootNames().includes(e)) {
              return false;
            }
          }
          return true;
        }
      }
      function tk(t) {
        const e = [];
        const n = t.root.document;
        if (!n) {
          return new Map();
        }
        const i = Fg._createIn(t);
        for (const t of n.model.markers) {
          const n = t.getRange();
          const o = n.isCollapsed;
          const r = n.start.isEqual(i.start) || n.end.isEqual(i.end);
          if (o && r) {
            e.push([t.name, n]);
          } else {
            const o = i.getIntersection(n);
            if (o) {
              e.push([t.name, o]);
            }
          }
        }
        e.sort(([t, e], [n, i]) => {
          if (e.end.compareWith(i.start) !== 'after') {
            return 1;
          } else if (e.start.compareWith(i.end) !== 'before') {
            return -1;
          } else {
            switch (e.start.compareWith(i.start)) {
              case 'before':
                return 1;
              case 'after':
                return -1;
              default:
                switch (e.end.compareWith(i.end)) {
                  case 'before':
                    return 1;
                  case 'after':
                    return -1;
                  default:
                    return n.localeCompare(t);
                }
            }
          }
        });
        return new Map(e);
      }
      class ek {
        constructor(t, e) {
          this._helpers = new Map();
          this._downcast = Ea(t);
          this._createConversionHelpers({
            name: 'downcast',
            dispatchers: this._downcast,
            isDowncast: true,
          });
          this._upcast = Ea(e);
          this._createConversionHelpers({
            name: 'upcast',
            dispatchers: this._upcast,
            isDowncast: false,
          });
        }
        addAlias(t, e) {
          const n = this._downcast.includes(e);
          const i = this._upcast.includes(e);
          if (!i && !n) {
            throw new h(
              'conversion-add-alias-dispatcher-not-registered',
              this
            );
          }
          this._createConversionHelpers({
            name: t,
            dispatchers: [e],
            isDowncast: n,
          });
        }
        for(t) {
          if (!this._helpers.has(t)) {
            throw new h('conversion-for-unknown-group', this);
          }
          return this._helpers.get(t);
        }
        elementToElement(t) {
          this.for('downcast').elementToElement(t);
          for (const { model: e, view: n } of nk(t)) {
            this.for('upcast').elementToElement({
              model: e,
              view: n,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToElement(t) {
          this.for('downcast').attributeToElement(t);
          for (const { model: e, view: n } of nk(t)) {
            this.for('upcast').elementToAttribute({
              view: n,
              model: e,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToAttribute(t) {
          this.for('downcast').attributeToAttribute(t);
          for (const { model: e, view: n } of nk(t)) {
            this.for('upcast').attributeToAttribute({
              view: n,
              model: e,
            });
          }
        }
        _createConversionHelpers({
          name: t,
          dispatchers: e,
          isDowncast: n,
        }) {
          if (this._helpers.has(t)) {
            throw new h('conversion-group-exists', this);
          }
          const i = n ? new dm(e) : new ip(e);
          this._helpers.set(t, i);
        }
      }
      function* nk(t) {
        if (t.model.values) {
          for (const e of t.model.values) {
            const n = { key: t.model.key, value: e };
            const i = t.view[e];
            const o = t.upcastAlso ? t.upcastAlso[e] : undefined;
            yield* ik(n, i, o);
          }
        } else {
          yield* ik(t.model, t.view, t.upcastAlso);
        }
      }
      function* ik(t, e, n) {
        yield { model: t, view: e };
        if (n) {
          for (const e of Ea(n)) {
            yield { model: t, view: e };
          }
        }
      }
      class ok {
        constructor(t = {}) {
          if (typeof t === 'string') {
            t = t === 'transparent' ? { isUndoable: false } : {};
            u('batch-constructor-deprecated-string-type');
          }
          const {
            isUndoable: e = true,
            isLocal: n = true,
            isUndo: i = false,
            isTyping: o = false,
          } = t;
          this.operations = [];
          this.isUndoable = e;
          this.isLocal = n;
          this.isUndo = i;
          this.isTyping = o;
        }
        get type() {
          u('batch-type-deprecated');
          return 'default';
        }
        get baseVersion() {
          for (const t of this.operations) {
            if (t.baseVersion !== null) {
              return t.baseVersion;
            }
          }
          return null;
        }
        addOperation(t) {
          t.batch = this;
          this.operations.push(t);
          return t;
        }
      }
      class rk {
        constructor(t) {
          this._markerCollection = t;
          this._changesInElement = new Map();
          this._elementSnapshots = new Map();
          this._changedMarkers = new Map();
          this._changeCount = 0;
          this._cachedChanges = null;
          this._cachedChangesWithGraveyard = null;
          this._refreshedItems = new Set();
        }
        get isEmpty() {
          return (
            this._changesInElement.size == 0 &&
            this._changedMarkers.size == 0
          );
        }
        bufferOperation(t) {
          const e = t;
          switch (e.type) {
            case 'insert': {
              if (this._isInInsertedElement(e.position.parent)) {
                return;
              }
              this._markInsert(
                e.position.parent,
                e.position.offset,
                e.nodes.maxOffset
              );
              break;
            }
            case 'addAttribute':
            case 'removeAttribute':
            case 'changeAttribute': {
              for (const t of e.range.getItems({ shallow: true })) {
                if (this._isInInsertedElement(t.parent)) {
                  continue;
                }
                this._markAttribute(t);
              }
              break;
            }
            case 'remove':
            case 'move':
            case 'reinsert': {
              if (
                e.sourcePosition.isEqual(e.targetPosition) ||
                e.sourcePosition
                  .getShiftedBy(e.howMany)
                  .isEqual(e.targetPosition)
              ) {
                return;
              }
              const t = this._isInInsertedElement(
                e.sourcePosition.parent
              );
              const n = this._isInInsertedElement(
                e.targetPosition.parent
              );
              if (!t) {
                this._markRemove(
                  e.sourcePosition.parent,
                  e.sourcePosition.offset,
                  e.howMany
                );
              }
              if (!n) {
                this._markInsert(
                  e.targetPosition.parent,
                  e.getMovedRangeStart().offset,
                  e.howMany
                );
              }
              break;
            }
            case 'rename': {
              if (this._isInInsertedElement(e.position.parent)) {
                return;
              }
              this._markRemove(
                e.position.parent,
                e.position.offset,
                1
              );
              this._markInsert(
                e.position.parent,
                e.position.offset,
                1
              );
              const t = Fg._createFromPositionAndShift(e.position, 1);
              for (const e of this._markerCollection.getMarkersIntersectingRange(
                t
              )) {
                const t = e.getData();
                this.bufferMarkerChange(e.name, t, t);
              }
              break;
            }
            case 'split': {
              const t = e.splitPosition.parent;
              if (!this._isInInsertedElement(t)) {
                this._markRemove(
                  t,
                  e.splitPosition.offset,
                  e.howMany
                );
              }
              if (
                !this._isInInsertedElement(e.insertionPosition.parent)
              ) {
                this._markInsert(
                  e.insertionPosition.parent,
                  e.insertionPosition.offset,
                  1
                );
              }
              if (e.graveyardPosition) {
                this._markRemove(
                  e.graveyardPosition.parent,
                  e.graveyardPosition.offset,
                  1
                );
              }
              break;
            }
            case 'merge': {
              const t = e.sourcePosition.parent;
              if (!this._isInInsertedElement(t.parent)) {
                this._markRemove(t.parent, t.startOffset, 1);
              }
              const n = e.graveyardPosition.parent;
              this._markInsert(n, e.graveyardPosition.offset, 1);
              const i = e.targetPosition.parent;
              if (!this._isInInsertedElement(i)) {
                this._markInsert(
                  i,
                  e.targetPosition.offset,
                  t.maxOffset
                );
              }
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(t, e, n) {
          const i = this._changedMarkers.get(t);
          if (!i) {
            this._changedMarkers.set(t, {
              newMarkerData: n,
              oldMarkerData: e,
            });
          } else {
            i.newMarkerData = n;
            if (i.oldMarkerData.range == null && n.range == null) {
              this._changedMarkers.delete(t);
            }
          }
        }
        getMarkersToRemove() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.oldMarkerData.range != null) {
              t.push({ name: e, range: n.oldMarkerData.range });
            }
          }
          return t;
        }
        getMarkersToAdd() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.newMarkerData.range != null) {
              t.push({ name: e, range: n.newMarkerData.range });
            }
          }
          return t;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([t, e]) => ({
            name: t,
            data: {
              oldRange: e.oldMarkerData.range,
              newRange: e.newMarkerData.range,
            },
          }));
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0) {
            return true;
          }
          for (const {
            newMarkerData: t,
            oldMarkerData: e,
          } of this._changedMarkers.values()) {
            if (t.affectsData !== e.affectsData) {
              return true;
            }
            if (t.affectsData) {
              const n = t.range && !e.range;
              const i = !t.range && e.range;
              const o =
                t.range && e.range && !t.range.isEqual(e.range);
              if (n || i || o) {
                return true;
              }
            }
          }
          return false;
        }
        getChanges(t = {}) {
          if (this._cachedChanges) {
            if (t.includeChangesInGraveyard) {
              return this._cachedChangesWithGraveyard.slice();
            } else {
              return this._cachedChanges.slice();
            }
          }
          let e = [];
          for (const t of this._changesInElement.keys()) {
            const n = this._changesInElement.get(t).sort((t, e) => {
              if (t.offset === e.offset) {
                if (t.type != e.type) {
                  return t.type == 'remove' ? -1 : 1;
                }
                return 0;
              }
              return t.offset < e.offset ? -1 : 1;
            });
            const i = this._elementSnapshots.get(t);
            const o = sk(t.getChildren());
            const r = ak(i.length, n);
            let s = 0;
            let a = 0;
            for (const n of r) {
              if (n === 'i') {
                e.push(this._getInsertDiff(t, s, o[s]));
                s++;
              } else if (n === 'r') {
                e.push(this._getRemoveDiff(t, s, i[a]));
                a++;
              } else if (n === 'a') {
                const n = o[s].attributes;
                const r = i[a].attributes;
                let c;
                if (o[s].name == '$text') {
                  c = new Fg(
                    Ig._createAt(t, s),
                    Ig._createAt(t, s + 1)
                  );
                } else {
                  const e = t.offsetToIndex(s);
                  c = new Fg(
                    Ig._createAt(t, s),
                    Ig._createAt(t.getChild(e), 0)
                  );
                }
                e.push(...this._getAttributesDiff(c, r, n));
                s++;
                a++;
              } else {
                s++;
                a++;
              }
            }
          }
          e.sort((t, e) => {
            if (t.position.root != e.position.root) {
              return t.position.root.rootName <
                e.position.root.rootName
                ? -1
                : 1;
            }
            if (t.position.isEqual(e.position)) {
              return t.changeCount - e.changeCount;
            }
            return t.position.isBefore(e.position) ? -1 : 1;
          });
          for (let t = 1, n = 0; t < e.length; t++) {
            const i = e[n];
            const o = e[t];
            const r =
              i.type == 'remove' &&
              o.type == 'remove' &&
              i.name == '$text' &&
              o.name == '$text' &&
              i.position.isEqual(o.position);
            const s =
              i.type == 'insert' &&
              o.type == 'insert' &&
              i.name == '$text' &&
              o.name == '$text' &&
              i.position.parent == o.position.parent &&
              i.position.offset + i.length == o.position.offset;
            const a =
              i.type == 'attribute' &&
              o.type == 'attribute' &&
              i.position.parent == o.position.parent &&
              i.range.isFlat &&
              o.range.isFlat &&
              i.position.offset + i.length == o.position.offset &&
              i.attributeKey == o.attributeKey &&
              i.attributeOldValue == o.attributeOldValue &&
              i.attributeNewValue == o.attributeNewValue;
            if (r || s || a) {
              i.length++;
              if (a) {
                i.range.end = i.range.end.getShiftedBy(1);
              }
              e[t] = null;
            } else {
              n = t;
            }
          }
          e = e.filter((t) => t);
          for (const t of e) {
            delete t.changeCount;
            if (t.type == 'attribute') {
              delete t.position;
              delete t.length;
            }
          }
          this._changeCount = 0;
          this._cachedChangesWithGraveyard = e;
          this._cachedChanges = e.filter(ck);
          if (t.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard.slice();
          } else {
            return this._cachedChanges.slice();
          }
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems);
        }
        reset() {
          this._changesInElement.clear();
          this._elementSnapshots.clear();
          this._changedMarkers.clear();
          this._refreshedItems = new Set();
          this._cachedChanges = null;
        }
        _refreshItem(t) {
          if (this._isInInsertedElement(t.parent)) {
            return;
          }
          this._markRemove(t.parent, t.startOffset, t.offsetSize);
          this._markInsert(t.parent, t.startOffset, t.offsetSize);
          this._refreshedItems.add(t);
          const e = Fg._createOn(t);
          for (const t of this._markerCollection.getMarkersIntersectingRange(
            e
          )) {
            const e = t.getData();
            this.bufferMarkerChange(t.name, e, e);
          }
          this._cachedChanges = null;
        }
        _markInsert(t, e, n) {
          const i = {
            type: 'insert',
            offset: e,
            howMany: n,
            count: this._changeCount++,
          };
          this._markChange(t, i);
        }
        _markRemove(t, e, n) {
          const i = {
            type: 'remove',
            offset: e,
            howMany: n,
            count: this._changeCount++,
          };
          this._markChange(t, i);
          this._removeAllNestedChanges(t, e, n);
        }
        _markAttribute(t) {
          const e = {
            type: 'attribute',
            offset: t.startOffset,
            howMany: t.offsetSize,
            count: this._changeCount++,
          };
          this._markChange(t.parent, e);
        }
        _markChange(t, e) {
          this._makeSnapshot(t);
          const n = this._getChangesForElement(t);
          this._handleChange(e, n);
          n.push(e);
          for (let t = 0; t < n.length; t++) {
            if (n[t].howMany < 1) {
              n.splice(t, 1);
              t--;
            }
          }
        }
        _getChangesForElement(t) {
          let e;
          if (this._changesInElement.has(t)) {
            e = this._changesInElement.get(t);
          } else {
            e = [];
            this._changesInElement.set(t, e);
          }
          return e;
        }
        _makeSnapshot(t) {
          if (!this._elementSnapshots.has(t)) {
            this._elementSnapshots.set(t, sk(t.getChildren()));
          }
        }
        _handleChange(t, e) {
          t.nodesToHandle = t.howMany;
          for (const n of e) {
            const i = t.offset + t.howMany;
            const o = n.offset + n.howMany;
            if (t.type == 'insert') {
              if (n.type == 'insert') {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < o) {
                  n.howMany += t.nodesToHandle;
                  t.nodesToHandle = 0;
                }
              }
              if (n.type == 'remove') {
                if (t.offset < n.offset) {
                  n.offset += t.howMany;
                }
              }
              if (n.type == 'attribute') {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < o) {
                  const o = n.howMany;
                  n.howMany = t.offset - n.offset;
                  e.unshift({
                    type: 'attribute',
                    offset: i,
                    howMany: o - n.howMany,
                    count: this._changeCount++,
                  });
                }
              }
            }
            if (t.type == 'remove') {
              if (n.type == 'insert') {
                if (i <= n.offset) {
                  n.offset -= t.howMany;
                } else if (i <= o) {
                  if (t.offset < n.offset) {
                    const e = i - n.offset;
                    n.offset = t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  } else {
                    n.howMany -= t.nodesToHandle;
                    t.nodesToHandle = 0;
                  }
                } else {
                  if (t.offset <= n.offset) {
                    t.nodesToHandle -= n.howMany;
                    n.howMany = 0;
                  } else if (t.offset < o) {
                    const e = o - t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  }
                }
              }
              if (n.type == 'remove') {
                if (i <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  t.nodesToHandle += n.howMany;
                  n.howMany = 0;
                }
              }
              if (n.type == 'attribute') {
                if (i <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  const e = i - n.offset;
                  n.offset = t.offset;
                  n.howMany -= e;
                } else if (t.offset < o) {
                  if (i <= o) {
                    const i = n.howMany;
                    n.howMany = t.offset - n.offset;
                    const o = i - n.howMany - t.nodesToHandle;
                    e.unshift({
                      type: 'attribute',
                      offset: t.offset,
                      howMany: o,
                      count: this._changeCount++,
                    });
                  } else {
                    n.howMany -= o - t.offset;
                  }
                }
              }
            }
            if (t.type == 'attribute') {
              if (n.type == 'insert') {
                if (t.offset < n.offset && i > n.offset) {
                  if (i > o) {
                    const t = {
                      type: 'attribute',
                      offset: o,
                      howMany: i - o,
                      count: this._changeCount++,
                    };
                    this._handleChange(t, e);
                    e.push(t);
                  }
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                } else if (t.offset >= n.offset && t.offset < o) {
                  if (i > o) {
                    t.nodesToHandle = i - o;
                    t.offset = o;
                  } else {
                    t.nodesToHandle = 0;
                  }
                }
              }
              if (n.type == 'remove') {
                if (t.offset < n.offset && i > n.offset) {
                  const o = {
                    type: 'attribute',
                    offset: n.offset,
                    howMany: i - n.offset,
                    count: this._changeCount++,
                  };
                  this._handleChange(o, e);
                  e.push(o);
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                }
              }
              if (n.type == 'attribute') {
                if (t.offset >= n.offset && i <= o) {
                  t.nodesToHandle = 0;
                  t.howMany = 0;
                  t.offset = 0;
                } else if (t.offset <= n.offset && i >= o) {
                  n.howMany = 0;
                }
              }
            }
          }
          t.howMany = t.nodesToHandle;
          delete t.nodesToHandle;
        }
        _getInsertDiff(t, e, n) {
          return {
            type: 'insert',
            position: Ig._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getRemoveDiff(t, e, n) {
          return {
            type: 'remove',
            position: Ig._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getAttributesDiff(t, e, n) {
          const i = [];
          n = new Map(n);
          for (const [o, r] of e) {
            const e = n.has(o) ? n.get(o) : null;
            if (e !== r) {
              i.push({
                type: 'attribute',
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: o,
                attributeOldValue: r,
                attributeNewValue: e,
                changeCount: this._changeCount++,
              });
            }
            n.delete(o);
          }
          for (const [e, o] of n) {
            i.push({
              type: 'attribute',
              position: t.start,
              range: t.clone(),
              length: 1,
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: o,
              changeCount: this._changeCount++,
            });
          }
          return i;
        }
        _isInInsertedElement(t) {
          const e = t.parent;
          if (!e) {
            return false;
          }
          const n = this._changesInElement.get(e);
          const i = t.startOffset;
          if (n) {
            for (const t of n) {
              if (
                t.type == 'insert' &&
                i >= t.offset &&
                i < t.offset + t.howMany
              ) {
                return true;
              }
            }
          }
          return this._isInInsertedElement(e);
        }
        _removeAllNestedChanges(t, e, n) {
          const i = new Fg(
            Ig._createAt(t, e),
            Ig._createAt(t, e + n)
          );
          for (const t of i.getItems({ shallow: true })) {
            if (t.is('element')) {
              this._elementSnapshots.delete(t);
              this._changesInElement.delete(t);
              this._removeAllNestedChanges(t, 0, t.maxOffset);
            }
          }
        }
      }
      function sk(t) {
        const e = [];
        for (const n of t) {
          if (n.is('$text')) {
            for (let t = 0; t < n.data.length; t++) {
              e.push({
                name: '$text',
                attributes: new Map(n.getAttributes()),
              });
            }
          } else {
            e.push({
              name: n.name,
              attributes: new Map(n.getAttributes()),
            });
          }
        }
        return e;
      }
      function ak(t, e) {
        const n = [];
        let i = 0;
        let o = 0;
        for (const t of e) {
          if (t.offset > i) {
            for (let e = 0; e < t.offset - i; e++) {
              n.push('e');
            }
            o += t.offset - i;
          }
          if (t.type == 'insert') {
            for (let e = 0; e < t.howMany; e++) {
              n.push('i');
            }
            i = t.offset + t.howMany;
          } else if (t.type == 'remove') {
            for (let e = 0; e < t.howMany; e++) {
              n.push('r');
            }
            i = t.offset;
            o += t.howMany;
          } else {
            n.push(...'a'.repeat(t.howMany).split(''));
            i = t.offset + t.howMany;
            o += t.howMany;
          }
        }
        if (o < t) {
          for (let e = 0; e < t - o - i; e++) {
            n.push('e');
          }
        }
        return n;
      }
      function ck(t) {
        const e =
          'position' in t && t.position.root.rootName == '$graveyard';
        const n =
          'range' in t && t.range.root.rootName == '$graveyard';
        return !e && !n;
      }
      class lk {
        constructor() {
          this._operations = [];
          this._undoPairs = new Map();
          this._undoneOperations = new Set();
          this._baseVersionToOperationIndex = new Map();
          this._version = 0;
          this._gaps = new Map();
        }
        get version() {
          return this._version;
        }
        set version(t) {
          if (this._operations.length && t > this._version + 1) {
            this._gaps.set(this._version, t);
          }
          this._version = t;
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1];
        }
        addOperation(t) {
          if (t.baseVersion !== this.version) {
            throw new h(
              'model-document-history-addoperation-incorrect-version',
              this,
              { operation: t, historyVersion: this.version }
            );
          }
          this._operations.push(t);
          this._version++;
          this._baseVersionToOperationIndex.set(
            t.baseVersion,
            this._operations.length - 1
          );
        }
        getOperations(t, e = this.version) {
          if (!this._operations.length) {
            return [];
          }
          const n = this._operations[0];
          if (t === undefined) {
            t = n.baseVersion;
          }
          let i = e - 1;
          for (const [e, n] of this._gaps) {
            if (t > e && t < n) {
              t = n;
            }
            if (i > e && i < n) {
              i = e - 1;
            }
          }
          if (
            i < n.baseVersion ||
            t > this.lastOperation.baseVersion
          ) {
            return [];
          }
          let o = this._baseVersionToOperationIndex.get(t);
          if (o === undefined) {
            o = 0;
          }
          let r = this._baseVersionToOperationIndex.get(i);
          if (r === undefined) {
            r = this._operations.length - 1;
          }
          return this._operations.slice(o, r + 1);
        }
        getOperation(t) {
          const e = this._baseVersionToOperationIndex.get(t);
          if (e === undefined) {
            return;
          }
          return this._operations[e];
        }
        setOperationAsUndone(t, e) {
          this._undoPairs.set(e, t);
          this._undoneOperations.add(t);
        }
        isUndoingOperation(t) {
          return this._undoPairs.has(t);
        }
        isUndoneOperation(t) {
          return this._undoneOperations.has(t);
        }
        getUndoneOperation(t) {
          return this._undoPairs.get(t);
        }
        reset() {
          this._version = 0;
          this._undoPairs = new Map();
          this._operations = [];
          this._undoneOperations = new Set();
          this._gaps = new Map();
          this._baseVersionToOperationIndex = new Map();
        }
      }
      class dk extends Sg {
        constructor(t, e, n = 'main') {
          super(e);
          this._document = t;
          this.rootName = n;
        }
        get document() {
          return this._document;
        }
        toJSON() {
          return this.rootName;
        }
      }
      dk.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rootElement' ||
            t === 'model:rootElement' ||
            t === 'element' ||
            t === 'model:element' ||
            t === 'node' ||
            t === 'model:node'
          );
        }
        return (
          e === this.name &&
          (t === 'rootElement' ||
            t === 'model:rootElement' ||
            t === 'element' ||
            t === 'model:element')
        );
      };
      function hk(t) {
        return (
          !!t &&
          t.length == 1 &&
          /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(
            t
          )
        );
      }
      function uk(t) {
        return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t);
      }
      function fk(t) {
        return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t);
      }
      function gk(t, e) {
        return uk(t.charAt(e - 1)) && fk(t.charAt(e));
      }
      function mk(t, e) {
        return hk(t.charAt(e));
      }
      const pk = bk();
      function kk(t, e) {
        const n = String(t).matchAll(pk);
        return Array.from(n).some(
          (t) => t.index < e && e < t.index + t[0].length
        );
      }
      function bk() {
        const t = [
          /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
          /\p{Emoji}\u{FE0F}?\u{20E3}/u,
          /\p{Emoji}\u{FE0F}/u,
          /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u,
        ];
        const e = /\p{Regional_Indicator}{2}/u.source;
        const n = '(?:' + t.map((t) => t.source).join('|') + ')';
        const i = `${e}|${n}(?:‍${n})*`;
        return new RegExp(i, 'ug');
      }
      const wk = '$graveyard';
      class _k extends y {
        constructor(t) {
          super();
          this.model = t;
          this.history = new lk();
          this.selection = new em(this);
          this.roots = new ya({ idProperty: 'rootName' });
          this.differ = new rk(t.markers);
          this._postFixers = new Set();
          this._hasSelectionChangedFromTheLastChangeBlock = false;
          this.createRoot('$root', wk);
          this.listenTo(
            t,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.differ.bufferOperation(n);
              }
            },
            { priority: 'high' }
          );
          this.listenTo(
            t,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.history.addOperation(n);
              }
            },
            { priority: 'low' }
          );
          this.listenTo(this.selection, 'change', () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true;
          });
          this.listenTo(t.markers, 'update', (t, e, n, i, o) => {
            const r = { ...e.getData(), range: i };
            this.differ.bufferMarkerChange(e.name, o, r);
            if (n === null) {
              e.on('change', (t, n) => {
                const i = e.getData();
                this.differ.bufferMarkerChange(
                  e.name,
                  { ...i, range: n },
                  i
                );
              });
            }
          });
        }
        get version() {
          return this.history.version;
        }
        set version(t) {
          this.history.version = t;
        }
        get graveyard() {
          return this.getRoot(wk);
        }
        createRoot(t = '$root', e = 'main') {
          if (this.roots.get(e)) {
            throw new h(
              'model-document-createroot-name-exists',
              this,
              { name: e }
            );
          }
          const n = new dk(this, t, e);
          this.roots.add(n);
          return n;
        }
        destroy() {
          this.selection.destroy();
          this.stopListening();
        }
        getRoot(t = 'main') {
          return this.roots.get(t);
        }
        getRootNames() {
          return Array.from(this.roots, (t) => t.rootName).filter(
            (t) => t != wk
          );
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        toJSON() {
          const t = Wa(this);
          t.selection = '[engine.model.DocumentSelection]';
          t.model = '[engine.model.Model]';
          return t;
        }
        _handleChangeBlock(t) {
          if (this._hasDocumentChangedFromTheLastChangeBlock()) {
            this._callPostFixers(t);
            this.selection.refresh();
            if (this.differ.hasDataChanges()) {
              this.fire('change:data', t.batch);
            } else {
              this.fire('change', t.batch);
            }
            this.selection.refresh();
            this.differ.reset();
          }
          this._hasSelectionChangedFromTheLastChangeBlock = false;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return (
            !this.differ.isEmpty ||
            this._hasSelectionChangedFromTheLastChangeBlock
          );
        }
        _getDefaultRoot() {
          for (const t of this.roots) {
            if (t !== this.graveyard) {
              return t;
            }
          }
          return this.graveyard;
        }
        _getDefaultRange() {
          const t = this._getDefaultRoot();
          const e = this.model;
          const n = e.schema;
          const i = e.createPositionFromPath(t, [0]);
          const o = n.getNearestSelectionRange(i);
          return o || e.createRange(i);
        }
        _validateSelectionRange(t) {
          return vk(t.start) && vk(t.end);
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              this.selection.refresh();
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      function vk(t) {
        const e = t.textNode;
        if (e) {
          const n = e.data;
          const i = t.offset - e.startOffset;
          return !gk(n, i) && !mk(n, i);
        }
        return true;
      }
      class Ak extends y {
        constructor() {
          super();
          this._markers = new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(t) {
          const e = t instanceof Ck ? t.name : t;
          return this._markers.has(e);
        }
        get(t) {
          return this._markers.get(t) || null;
        }
        _set(t, e, n = false, i = false) {
          const o = t instanceof Ck ? t.name : t;
          if (o.includes(',')) {
            throw new h(
              'markercollection-incorrect-marker-name',
              this
            );
          }
          const r = this._markers.get(o);
          if (r) {
            const t = r.getData();
            const s = r.getRange();
            let a = false;
            if (!s.isEqual(e)) {
              r._attachLiveRange(Jg.fromRange(e));
              a = true;
            }
            if (n != r.managedUsingOperations) {
              r._managedUsingOperations = n;
              a = true;
            }
            if (typeof i === 'boolean' && i != r.affectsData) {
              r._affectsData = i;
              a = true;
            }
            if (a) {
              this.fire(`update:${o}`, r, s, e, t);
            }
            return r;
          }
          const s = Jg.fromRange(e);
          const a = new Ck(o, s, n, i);
          this._markers.set(o, a);
          this.fire(`update:${o}`, a, null, e, {
            ...a.getData(),
            range: null,
          });
          return a;
        }
        _remove(t) {
          const e = t instanceof Ck ? t.name : t;
          const n = this._markers.get(e);
          if (n) {
            this._markers.delete(e);
            this.fire(
              `update:${e}`,
              n,
              n.getRange(),
              null,
              n.getData()
            );
            this._destroyMarker(n);
            return true;
          }
          return false;
        }
        _refresh(t) {
          const e = t instanceof Ck ? t.name : t;
          const n = this._markers.get(e);
          if (!n) {
            throw new h(
              'markercollection-refresh-marker-not-exists',
              this
            );
          }
          const i = n.getRange();
          this.fire(`update:${e}`, n, i, i, n.getData());
        }
        *getMarkersAtPosition(t) {
          for (const e of this) {
            if (e.getRange().containsPosition(t)) {
              yield e;
            }
          }
        }
        *getMarkersIntersectingRange(t) {
          for (const e of this) {
            if (e.getRange().getIntersection(t) !== null) {
              yield e;
            }
          }
        }
        destroy() {
          for (const t of this._markers.values()) {
            this._destroyMarker(t);
          }
          this._markers = null;
          this.stopListening();
        }
        *getMarkersGroup(t) {
          for (const e of this._markers.values()) {
            if (e.name.startsWith(t + ':')) {
              yield e;
            }
          }
        }
        _destroyMarker(t) {
          t.stopListening();
          t._detachLiveRange();
        }
      }
      class Ck extends C(Cg) {
        constructor(t, e, n, i) {
          super();
          this.name = t;
          this._liveRange = this._attachLiveRange(e);
          this._managedUsingOperations = n;
          this._affectsData = i;
        }
        get managedUsingOperations() {
          if (!this._liveRange) {
            throw new h('marker-destroyed', this);
          }
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange) {
            throw new h('marker-destroyed', this);
          }
          return this._affectsData;
        }
        getData() {
          return {
            range: this.getRange(),
            affectsData: this.affectsData,
            managedUsingOperations: this.managedUsingOperations,
          };
        }
        getStart() {
          if (!this._liveRange) {
            throw new h('marker-destroyed', this);
          }
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange) {
            throw new h('marker-destroyed', this);
          }
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange) {
            throw new h('marker-destroyed', this);
          }
          return this._liveRange.toRange();
        }
        _attachLiveRange(t) {
          if (this._liveRange) {
            this._detachLiveRange();
          }
          t.delegate('change:range').to(this);
          t.delegate('change:content').to(this);
          this._liveRange = t;
          return t;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating('change:range', this);
          this._liveRange.stopDelegating('change:content', this);
          this._liveRange.detach();
          this._liveRange = null;
        }
      }
      Ck.prototype.is = function (t) {
        return t === 'marker' || t === 'model:marker';
      };
      class yk {
        constructor(t) {
          this.baseVersion = t;
          this.isDocumentOperation = this.baseVersion !== null;
          this.batch = null;
        }
        _validate() {}
        toJSON() {
          const t = Object.assign({}, this);
          t.__className = this.constructor.className;
          delete t.batch;
          delete t.isDocumentOperation;
          return t;
        }
        static get className() {
          return 'Operation';
        }
        static fromJSON(t, e) {
          return new this(t.baseVersion);
        }
      }
      function xk(t, e) {
        const n = Tk(e);
        const i = n.reduce((t, e) => t + e.offsetSize, 0);
        const o = t.parent;
        Pk(t);
        const r = t.index;
        o._insertChild(r, n);
        Bk(o, r + n.length);
        Bk(o, r);
        return new Fg(t, t.getShiftedBy(i));
      }
      function Ek(t) {
        if (!t.isFlat) {
          throw new h('operation-utils-remove-range-not-flat', this);
        }
        const e = t.start.parent;
        Pk(t.start);
        Pk(t.end);
        const n = e._removeChildren(
          t.start.index,
          t.end.index - t.start.index
        );
        Bk(e, t.start.index);
        return n;
      }
      function Dk(t, e) {
        if (!t.isFlat) {
          throw new h('operation-utils-move-range-not-flat', this);
        }
        const n = Ek(t);
        e = e._getTransformedByDeletion(
          t.start,
          t.end.offset - t.start.offset
        );
        return xk(e, n);
      }
      function Sk(t, e, n) {
        Pk(t.start);
        Pk(t.end);
        for (const i of t.getItems({ shallow: true })) {
          const t = i.is('$textProxy') ? i.textNode : i;
          if (n !== null) {
            t._setAttribute(e, n);
          } else {
            t._removeAttribute(e);
          }
          Bk(t.parent, t.index);
        }
        Bk(t.end.parent, t.end.index);
      }
      function Tk(t) {
        const e = [];
        function n(t) {
          if (typeof t == 'string') {
            e.push(new Eg(t));
          } else if (t instanceof Dg) {
            e.push(new Eg(t.data, t.getAttributes()));
          } else if (t instanceof yg) {
            e.push(t);
          } else if (Ca(t)) {
            for (const e of t) {
              n(e);
            }
          }
        }
        n(t);
        for (let t = 1; t < e.length; t++) {
          const n = e[t];
          const i = e[t - 1];
          if (n instanceof Eg && i instanceof Eg && Ik(n, i)) {
            e.splice(
              t - 1,
              2,
              new Eg(i.data + n.data, i.getAttributes())
            );
            t--;
          }
        }
        return e;
      }
      function Bk(t, e) {
        const n = t.getChild(e - 1);
        const i = t.getChild(e);
        if (n && i && n.is('$text') && i.is('$text') && Ik(n, i)) {
          const o = new Eg(n.data + i.data, n.getAttributes());
          t._removeChildren(e - 1, 2);
          t._insertChild(e - 1, o);
        }
      }
      function Pk(t) {
        const e = t.textNode;
        const n = t.parent;
        if (e) {
          const i = t.offset - e.startOffset;
          const o = e.index;
          n._removeChildren(o, 1);
          const r = new Eg(e.data.substr(0, i), e.getAttributes());
          const s = new Eg(e.data.substr(i), e.getAttributes());
          n._insertChild(o, [r, s]);
        }
      }
      function Ik(t, e) {
        const n = t.getAttributes();
        const i = e.getAttributes();
        for (const t of n) {
          if (t[1] !== e.getAttribute(t[0])) {
            return false;
          }
          i.next();
        }
        return i.next().done;
      }
      function Rk(t, e) {
        return mf(t, e);
      }
      const zk = Rk;
      class Ok extends yk {
        constructor(t, e, n, i, o) {
          super(o);
          this.range = t.clone();
          this.key = e;
          this.oldValue = n === undefined ? null : n;
          this.newValue = i === undefined ? null : i;
        }
        get type() {
          if (this.oldValue === null) {
            return 'addAttribute';
          } else if (this.newValue === null) {
            return 'removeAttribute';
          } else {
            return 'changeAttribute';
          }
        }
        clone() {
          return new Ok(
            this.range,
            this.key,
            this.oldValue,
            this.newValue,
            this.baseVersion
          );
        }
        getReversed() {
          return new Ok(
            this.range,
            this.key,
            this.newValue,
            this.oldValue,
            this.baseVersion + 1
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.range = this.range.toJSON();
          return t;
        }
        _validate() {
          if (!this.range.isFlat) {
            throw new h('attribute-operation-range-not-flat', this);
          }
          for (const t of this.range.getItems({ shallow: true })) {
            if (
              this.oldValue !== null &&
              !zk(t.getAttribute(this.key), this.oldValue)
            ) {
              throw new h(
                'attribute-operation-wrong-old-value',
                this,
                { item: t, key: this.key, value: this.oldValue }
              );
            }
            if (
              this.oldValue === null &&
              this.newValue !== null &&
              t.hasAttribute(this.key)
            ) {
              throw new h(
                'attribute-operation-attribute-exists',
                this,
                { node: t, key: this.key }
              );
            }
          }
        }
        _execute() {
          if (!zk(this.oldValue, this.newValue)) {
            Sk(this.range, this.key, this.newValue);
          }
        }
        static get className() {
          return 'AttributeOperation';
        }
        static fromJSON(t, e) {
          return new Ok(
            Fg.fromJSON(t.range, e),
            t.key,
            t.oldValue,
            t.newValue,
            t.baseVersion
          );
        }
      }
      class Fk extends yk {
        constructor(t, e, n, i) {
          super(i);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = 'toNext';
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = 'toNone';
        }
        get type() {
          if (this.targetPosition.root.rootName == '$graveyard') {
            return 'remove';
          } else if (
            this.sourcePosition.root.rootName == '$graveyard'
          ) {
            return 'reinsert';
          }
          return 'move';
        }
        clone() {
          return new Fk(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.baseVersion
          );
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(
            this.sourcePosition,
            this.howMany
          );
        }
        getReversed() {
          const t = this.sourcePosition._getTransformedByInsertion(
            this.targetPosition,
            this.howMany
          );
          return new Fk(
            this.getMovedRangeStart(),
            this.howMany,
            t,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          const n = this.sourcePosition.offset;
          const i = this.targetPosition.offset;
          if (n + this.howMany > t.maxOffset) {
            throw new h('move-operation-nodes-do-not-exist', this);
          } else if (t === e && n < i && i < n + this.howMany) {
            throw new h('move-operation-range-into-itself', this);
          } else if (
            this.sourcePosition.root == this.targetPosition.root
          ) {
            if (
              Ha(
                this.sourcePosition.getParentPath(),
                this.targetPosition.getParentPath()
              ) == 'prefix'
            ) {
              const t = this.sourcePosition.path.length - 1;
              if (
                this.targetPosition.path[t] >= n &&
                this.targetPosition.path[t] < n + this.howMany
              ) {
                throw new h('move-operation-node-into-itself', this);
              }
            }
          }
        }
        _execute() {
          Dk(
            Fg._createFromPositionAndShift(
              this.sourcePosition,
              this.howMany
            ),
            this.targetPosition
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          t.targetPosition = this.targetPosition.toJSON();
          return t;
        }
        static get className() {
          return 'MoveOperation';
        }
        static fromJSON(t, e) {
          const n = Ig.fromJSON(t.sourcePosition, e);
          const i = Ig.fromJSON(t.targetPosition, e);
          return new this(n, t.howMany, i, t.baseVersion);
        }
      }
      class Nk extends yk {
        constructor(t, e, n) {
          super(n);
          this.position = t.clone();
          this.position.stickiness = 'toNone';
          this.nodes = new xg(Tk(e));
          this.shouldReceiveAttributes = false;
        }
        get type() {
          return 'insert';
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        clone() {
          const t = new xg(
            [...this.nodes].map((t) => t._clone(true))
          );
          const e = new Nk(this.position, t, this.baseVersion);
          e.shouldReceiveAttributes = this.shouldReceiveAttributes;
          return e;
        }
        getReversed() {
          const t = this.position.root.document.graveyard;
          const e = new Ig(t, [0]);
          return new Fk(
            this.position,
            this.nodes.maxOffset,
            e,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.position.parent;
          if (!t || t.maxOffset < this.position.offset) {
            throw new h('insert-operation-position-invalid', this);
          }
        }
        _execute() {
          const t = this.nodes;
          this.nodes = new xg([...t].map((t) => t._clone(true)));
          xk(this.position, t);
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          t.nodes = this.nodes.toJSON();
          return t;
        }
        static get className() {
          return 'InsertOperation';
        }
        static fromJSON(t, e) {
          const n = [];
          for (const e of t.nodes) {
            if (e.name) {
              n.push(Sg.fromJSON(e));
            } else {
              n.push(Eg.fromJSON(e));
            }
          }
          const i = new Nk(
            Ig.fromJSON(t.position, e),
            n,
            t.baseVersion
          );
          i.shouldReceiveAttributes = t.shouldReceiveAttributes;
          return i;
        }
      }
      class Mk extends yk {
        constructor(t, e, n, i, o, r) {
          super(r);
          this.name = t;
          this.oldRange = e ? e.clone() : null;
          this.newRange = n ? n.clone() : null;
          this.affectsData = o;
          this._markers = i;
        }
        get type() {
          return 'marker';
        }
        clone() {
          return new Mk(
            this.name,
            this.oldRange,
            this.newRange,
            this._markers,
            this.affectsData,
            this.baseVersion
          );
        }
        getReversed() {
          return new Mk(
            this.name,
            this.newRange,
            this.oldRange,
            this._markers,
            this.affectsData,
            this.baseVersion + 1
          );
        }
        _execute() {
          if (this.newRange) {
            this._markers._set(
              this.name,
              this.newRange,
              true,
              this.affectsData
            );
          } else {
            this._markers._remove(this.name);
          }
        }
        toJSON() {
          const t = super.toJSON();
          if (this.oldRange) {
            t.oldRange = this.oldRange.toJSON();
          }
          if (this.newRange) {
            t.newRange = this.newRange.toJSON();
          }
          delete t._markers;
          return t;
        }
        static get className() {
          return 'MarkerOperation';
        }
        static fromJSON(t, e) {
          return new Mk(
            t.name,
            t.oldRange ? Fg.fromJSON(t.oldRange, e) : null,
            t.newRange ? Fg.fromJSON(t.newRange, e) : null,
            e.model.markers,
            t.affectsData,
            t.baseVersion
          );
        }
      }
      class Lk extends yk {
        get type() {
          return 'noop';
        }
        clone() {
          return new Lk(this.baseVersion);
        }
        getReversed() {
          return new Lk(this.baseVersion + 1);
        }
        _execute() {}
        static get className() {
          return 'NoOperation';
        }
      }
      class Vk extends yk {
        constructor(t, e, n, i) {
          super(i);
          this.position = t;
          this.position.stickiness = 'toNext';
          this.oldName = e;
          this.newName = n;
        }
        get type() {
          return 'rename';
        }
        clone() {
          return new Vk(
            this.position.clone(),
            this.oldName,
            this.newName,
            this.baseVersion
          );
        }
        getReversed() {
          return new Vk(
            this.position.clone(),
            this.newName,
            this.oldName,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.position.nodeAfter;
          if (!(t instanceof Sg)) {
            throw new h('rename-operation-wrong-position', this);
          } else if (t.name !== this.oldName) {
            throw new h('rename-operation-wrong-name', this);
          }
        }
        _execute() {
          const t = this.position.nodeAfter;
          t.name = this.newName;
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          return t;
        }
        static get className() {
          return 'RenameOperation';
        }
        static fromJSON(t, e) {
          return new Vk(
            Ig.fromJSON(t.position, e),
            t.oldName,
            t.newName,
            t.baseVersion
          );
        }
      }
      class Hk extends yk {
        constructor(t, e, n, i, o) {
          super(o);
          this.root = t;
          this.key = e;
          this.oldValue = n;
          this.newValue = i;
        }
        get type() {
          if (this.oldValue === null) {
            return 'addRootAttribute';
          } else if (this.newValue === null) {
            return 'removeRootAttribute';
          } else {
            return 'changeRootAttribute';
          }
        }
        clone() {
          return new Hk(
            this.root,
            this.key,
            this.oldValue,
            this.newValue,
            this.baseVersion
          );
        }
        getReversed() {
          return new Hk(
            this.root,
            this.key,
            this.newValue,
            this.oldValue,
            this.baseVersion + 1
          );
        }
        _validate() {
          if (
            this.root != this.root.root ||
            this.root.is('documentFragment')
          ) {
            throw new h('rootattribute-operation-not-a-root', this, {
              root: this.root,
              key: this.key,
            });
          }
          if (
            this.oldValue !== null &&
            this.root.getAttribute(this.key) !== this.oldValue
          ) {
            throw new h(
              'rootattribute-operation-wrong-old-value',
              this,
              { root: this.root, key: this.key }
            );
          }
          if (
            this.oldValue === null &&
            this.newValue !== null &&
            this.root.hasAttribute(this.key)
          ) {
            throw new h(
              'rootattribute-operation-attribute-exists',
              this,
              { root: this.root, key: this.key }
            );
          }
        }
        _execute() {
          if (this.newValue !== null) {
            this.root._setAttribute(this.key, this.newValue);
          } else {
            this.root._removeAttribute(this.key);
          }
        }
        toJSON() {
          const t = super.toJSON();
          t.root = this.root.toJSON();
          return t;
        }
        static get className() {
          return 'RootAttributeOperation';
        }
        static fromJSON(t, e) {
          if (!e.getRoot(t.root)) {
            throw new h(
              'rootattribute-operation-fromjson-no-root',
              this,
              { rootName: t.root }
            );
          }
          return new Hk(
            e.getRoot(t.root),
            t.key,
            t.oldValue,
            t.newValue,
            t.baseVersion
          );
        }
      }
      class jk extends yk {
        constructor(t, e, n, i, o) {
          super(o);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = 'toPrevious';
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = 'toNext';
          this.graveyardPosition = i.clone();
        }
        get type() {
          return 'merge';
        }
        get deletionPosition() {
          return new Ig(
            this.sourcePosition.root,
            this.sourcePosition.path.slice(0, -1)
          );
        }
        get movedRange() {
          const t = this.sourcePosition.getShiftedBy(
            Number.POSITIVE_INFINITY
          );
          return new Fg(this.sourcePosition, t);
        }
        clone() {
          return new jk(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.graveyardPosition,
            this.baseVersion
          );
        }
        getReversed() {
          const t =
            this.targetPosition._getTransformedByMergeOperation(this);
          const e = this.sourcePosition.path.slice(0, -1);
          const n = new Ig(
            this.sourcePosition.root,
            e
          )._getTransformedByMergeOperation(this);
          return new qk(
            t,
            this.howMany,
            n,
            this.graveyardPosition,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          if (!t.parent) {
            throw new h(
              'merge-operation-source-position-invalid',
              this
            );
          } else if (!e.parent) {
            throw new h(
              'merge-operation-target-position-invalid',
              this
            );
          } else if (this.howMany != t.maxOffset) {
            throw new h('merge-operation-how-many-invalid', this);
          }
        }
        _execute() {
          const t = this.sourcePosition.parent;
          const e = Fg._createIn(t);
          Dk(e, this.targetPosition);
          Dk(Fg._createOn(t), this.graveyardPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = t.sourcePosition.toJSON();
          t.targetPosition = t.targetPosition.toJSON();
          t.graveyardPosition = t.graveyardPosition.toJSON();
          return t;
        }
        static get className() {
          return 'MergeOperation';
        }
        static fromJSON(t, e) {
          const n = Ig.fromJSON(t.sourcePosition, e);
          const i = Ig.fromJSON(t.targetPosition, e);
          const o = Ig.fromJSON(t.graveyardPosition, e);
          return new this(n, t.howMany, i, o, t.baseVersion);
        }
      }
      class qk extends yk {
        constructor(t, e, n, i, o) {
          super(o);
          this.splitPosition = t.clone();
          this.splitPosition.stickiness = 'toNext';
          this.howMany = e;
          this.insertionPosition = n;
          this.graveyardPosition = i ? i.clone() : null;
          if (this.graveyardPosition) {
            this.graveyardPosition.stickiness = 'toNext';
          }
        }
        get type() {
          return 'split';
        }
        get moveTargetPosition() {
          const t = this.insertionPosition.path.slice();
          t.push(0);
          return new Ig(this.insertionPosition.root, t);
        }
        get movedRange() {
          const t = this.splitPosition.getShiftedBy(
            Number.POSITIVE_INFINITY
          );
          return new Fg(this.splitPosition, t);
        }
        clone() {
          return new qk(
            this.splitPosition,
            this.howMany,
            this.insertionPosition,
            this.graveyardPosition,
            this.baseVersion
          );
        }
        getReversed() {
          const t = this.splitPosition.root.document.graveyard;
          const e = new Ig(t, [0]);
          return new jk(
            this.moveTargetPosition,
            this.howMany,
            this.splitPosition,
            e,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.splitPosition.parent;
          const e = this.splitPosition.offset;
          if (!t || t.maxOffset < e) {
            throw new h('split-operation-position-invalid', this);
          } else if (!t.parent) {
            throw new h('split-operation-split-in-root', this);
          } else if (
            this.howMany !=
            t.maxOffset - this.splitPosition.offset
          ) {
            throw new h('split-operation-how-many-invalid', this);
          } else if (
            this.graveyardPosition &&
            !this.graveyardPosition.nodeAfter
          ) {
            throw new h(
              'split-operation-graveyard-position-invalid',
              this
            );
          }
        }
        _execute() {
          const t = this.splitPosition.parent;
          if (this.graveyardPosition) {
            Dk(
              Fg._createFromPositionAndShift(
                this.graveyardPosition,
                1
              ),
              this.insertionPosition
            );
          } else {
            const e = t._clone();
            xk(this.insertionPosition, e);
          }
          const e = new Fg(
            Ig._createAt(t, this.splitPosition.offset),
            Ig._createAt(t, t.maxOffset)
          );
          Dk(e, this.moveTargetPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.splitPosition = this.splitPosition.toJSON();
          t.insertionPosition = this.insertionPosition.toJSON();
          if (this.graveyardPosition) {
            t.graveyardPosition = this.graveyardPosition.toJSON();
          }
          return t;
        }
        static get className() {
          return 'SplitOperation';
        }
        static getInsertionPosition(t) {
          const e = t.path.slice(0, -1);
          e[e.length - 1]++;
          return new Ig(t.root, e, 'toPrevious');
        }
        static fromJSON(t, e) {
          const n = Ig.fromJSON(t.splitPosition, e);
          const i = Ig.fromJSON(t.insertionPosition, e);
          const o = t.graveyardPosition
            ? Ig.fromJSON(t.graveyardPosition, e)
            : null;
          return new this(n, t.howMany, i, o, t.baseVersion);
        }
      }
      const Wk = {};
      Wk[Ok.className] = Ok;
      Wk[Nk.className] = Nk;
      Wk[Mk.className] = Mk;
      Wk[Fk.className] = Fk;
      Wk[Lk.className] = Lk;
      Wk[yk.className] = yk;
      Wk[Vk.className] = Vk;
      Wk[Hk.className] = Hk;
      Wk[qk.className] = qk;
      Wk[jk.className] = jk;
      class Uk {
        static fromJSON(t, e) {
          return Wk[t.__className].fromJSON(t, e);
        }
      }
      class Gk extends yk {
        constructor(t, e) {
          super(null);
          this.sourcePosition = t.clone();
          this.howMany = e;
        }
        get type() {
          return 'detach';
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          return t;
        }
        _validate() {
          if (this.sourcePosition.root.document) {
            throw new h('detach-operation-on-document-node', this);
          }
        }
        _execute() {
          Ek(
            Fg._createFromPositionAndShift(
              this.sourcePosition,
              this.howMany
            )
          );
        }
        static get className() {
          return 'DetachOperation';
        }
      }
      class $k extends Cg {
        constructor(t) {
          super();
          this.markers = new Map();
          this._children = new xg();
          if (t) {
            this._insertChild(0, t);
          }
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get nextSibling() {
          return null;
        }
        get previousSibling() {
          return null;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get document() {
          return null;
        }
        getAncestors() {
          return [];
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        getPath() {
          return [];
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        toJSON() {
          const t = [];
          for (const e of this._children) {
            t.push(e.toJSON());
          }
          return t;
        }
        static fromJSON(t) {
          const e = [];
          for (const n of t) {
            if (n.name) {
              e.push(Sg.fromJSON(n));
            } else {
              e.push(Eg.fromJSON(n));
            }
          }
          return new $k(e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = Kk(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
      }
      $k.prototype.is = function (t) {
        return (
          t === 'documentFragment' || t === 'model:documentFragment'
        );
      };
      function Kk(t) {
        if (typeof t == 'string') {
          return [new Eg(t)];
        }
        if (!Ca(t)) {
          t = [t];
        }
        return Array.from(t).map((t) => {
          if (typeof t == 'string') {
            return new Eg(t);
          }
          if (t instanceof Dg) {
            return new Eg(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class Zk {
        constructor(t, e) {
          this.model = t;
          this.batch = e;
        }
        createText(t, e) {
          return new Eg(t, e);
        }
        createElement(t, e) {
          return new Sg(t, e);
        }
        createDocumentFragment() {
          return new $k();
        }
        cloneElement(t, e = true) {
          return t._clone(e);
        }
        insert(t, e, n = 0) {
          this._assertWriterUsedCorrectly();
          if (t instanceof Eg && t.data == '') {
            return;
          }
          const i = Ig._createAt(e, n);
          if (t.parent) {
            if (tb(t.root, i.root)) {
              this.move(Fg._createOn(t), i);
              return;
            } else {
              if (t.root.document) {
                throw new h(
                  'model-writer-insert-forbidden-move',
                  this
                );
              } else {
                this.remove(t);
              }
            }
          }
          const o = i.root.document ? i.root.document.version : null;
          const r = new Nk(i, t, o);
          if (t instanceof Eg) {
            r.shouldReceiveAttributes = true;
          }
          this.batch.addOperation(r);
          this.model.applyOperation(r);
          if (t instanceof $k) {
            for (const [e, n] of t.markers) {
              const t = Ig._createAt(n.root, 0);
              const o = new Fg(
                n.start._getCombined(t, i),
                n.end._getCombined(t, i)
              );
              const r = {
                range: o,
                usingOperation: true,
                affectsData: true,
              };
              if (this.model.markers.has(e)) {
                this.updateMarker(e, r);
              } else {
                this.addMarker(e, r);
              }
            }
          }
        }
        insertText(t, e, n, i) {
          if (e instanceof $k || e instanceof Sg || e instanceof Ig) {
            this.insert(this.createText(t), e, n);
          } else {
            this.insert(this.createText(t, e), n, i);
          }
        }
        insertElement(t, e, n, i) {
          if (e instanceof $k || e instanceof Sg || e instanceof Ig) {
            this.insert(this.createElement(t), e, n);
          } else {
            this.insert(this.createElement(t, e), n, i);
          }
        }
        append(t, e) {
          this.insert(t, e, 'end');
        }
        appendText(t, e, n) {
          if (e instanceof $k || e instanceof Sg) {
            this.insert(this.createText(t), e, 'end');
          } else {
            this.insert(this.createText(t, e), n, 'end');
          }
        }
        appendElement(t, e, n) {
          if (e instanceof $k || e instanceof Sg) {
            this.insert(this.createElement(t), e, 'end');
          } else {
            this.insert(this.createElement(t, e), n, 'end');
          }
        }
        setAttribute(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (n instanceof Fg) {
            const i = n.getMinimalFlatRanges();
            for (const n of i) {
              Jk(this, t, e, n);
            }
          } else {
            Yk(this, t, e, n);
          }
        }
        setAttributes(t, e) {
          for (const [n, i] of Za(t)) {
            this.setAttribute(n, i, e);
          }
        }
        removeAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (e instanceof Fg) {
            const n = e.getMinimalFlatRanges();
            for (const e of n) {
              Jk(this, t, null, e);
            }
          } else {
            Yk(this, t, null, e);
          }
        }
        clearAttributes(t) {
          this._assertWriterUsedCorrectly();
          const e = (t) => {
            for (const e of t.getAttributeKeys()) {
              this.removeAttribute(e, t);
            }
          };
          if (!(t instanceof Fg)) {
            e(t);
          } else {
            for (const n of t.getItems()) {
              e(n);
            }
          }
        }
        move(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof Fg)) {
            throw new h('writer-move-invalid-range', this);
          }
          if (!t.isFlat) {
            throw new h('writer-move-range-not-flat', this);
          }
          const i = Ig._createAt(e, n);
          if (i.isEqual(t.start)) {
            return;
          }
          this._addOperationForAffectedMarkers('move', t);
          if (!tb(t.root, i.root)) {
            throw new h('writer-move-different-document', this);
          }
          const o = t.root.document ? t.root.document.version : null;
          const r = new Fk(
            t.start,
            t.end.offset - t.start.offset,
            i,
            o
          );
          this.batch.addOperation(r);
          this.model.applyOperation(r);
        }
        remove(t) {
          this._assertWriterUsedCorrectly();
          const e = t instanceof Fg ? t : Fg._createOn(t);
          const n = e.getMinimalFlatRanges().reverse();
          for (const t of n) {
            this._addOperationForAffectedMarkers('move', t);
            Xk(
              t.start,
              t.end.offset - t.start.offset,
              this.batch,
              this.model
            );
          }
        }
        merge(t) {
          this._assertWriterUsedCorrectly();
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this._addOperationForAffectedMarkers('merge', t);
          if (!(e instanceof Sg)) {
            throw new h('writer-merge-no-element-before', this);
          }
          if (!(n instanceof Sg)) {
            throw new h('writer-merge-no-element-after', this);
          }
          if (!t.root.document) {
            this._mergeDetached(t);
          } else {
            this._merge(t);
          }
        }
        createPositionFromPath(t, e, n) {
          return this.model.createPositionFromPath(t, e, n);
        }
        createPositionAt(t, e) {
          return this.model.createPositionAt(t, e);
        }
        createPositionAfter(t) {
          return this.model.createPositionAfter(t);
        }
        createPositionBefore(t) {
          return this.model.createPositionBefore(t);
        }
        createRange(t, e) {
          return this.model.createRange(t, e);
        }
        createRangeIn(t) {
          return this.model.createRangeIn(t);
        }
        createRangeOn(t) {
          return this.model.createRangeOn(t);
        }
        createSelection(...t) {
          return this.model.createSelection(...t);
        }
        _mergeDetached(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this.move(Fg._createIn(n), Ig._createAt(e, 'end'));
          this.remove(n);
        }
        _merge(t) {
          const e = Ig._createAt(t.nodeBefore, 'end');
          const n = Ig._createAt(t.nodeAfter, 0);
          const i = t.root.document.graveyard;
          const o = new Ig(i, [0]);
          const r = t.root.document.version;
          const s = new jk(n, t.nodeAfter.maxOffset, e, o, r);
          this.batch.addOperation(s);
          this.model.applyOperation(s);
        }
        rename(t, e) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof Sg)) {
            throw new h('writer-rename-not-element-instance', this);
          }
          const n = t.root.document ? t.root.document.version : null;
          const i = new Vk(Ig._createBefore(t), t.name, e, n);
          this.batch.addOperation(i);
          this.model.applyOperation(i);
        }
        split(t, e) {
          this._assertWriterUsedCorrectly();
          let n = t.parent;
          if (!n.parent) {
            throw new h('writer-split-element-no-parent', this);
          }
          if (!e) {
            e = n.parent;
          }
          if (
            !t.parent.getAncestors({ includeSelf: true }).includes(e)
          ) {
            throw new h('writer-split-invalid-limit-element', this);
          }
          let i;
          let o;
          do {
            const e = n.root.document
              ? n.root.document.version
              : null;
            const r = n.maxOffset - t.offset;
            const s = qk.getInsertionPosition(t);
            const a = new qk(t, r, s, null, e);
            this.batch.addOperation(a);
            this.model.applyOperation(a);
            if (!i && !o) {
              i = n;
              o = t.parent.nextSibling;
            }
            t = this.createPositionAfter(t.parent);
            n = t.parent;
          } while (n !== e);
          return {
            position: t,
            range: new Fg(Ig._createAt(i, 'end'), Ig._createAt(o, 0)),
          };
        }
        wrap(t, e) {
          this._assertWriterUsedCorrectly();
          if (!t.isFlat) {
            throw new h('writer-wrap-range-not-flat', this);
          }
          const n = e instanceof Sg ? e : new Sg(e);
          if (n.childCount > 0) {
            throw new h('writer-wrap-element-not-empty', this);
          }
          if (n.parent !== null) {
            throw new h('writer-wrap-element-attached', this);
          }
          this.insert(n, t.start);
          const i = new Fg(
            t.start.getShiftedBy(1),
            t.end.getShiftedBy(1)
          );
          this.move(i, Ig._createAt(n, 0));
        }
        unwrap(t) {
          this._assertWriterUsedCorrectly();
          if (t.parent === null) {
            throw new h('writer-unwrap-element-no-parent', this);
          }
          this.move(Fg._createIn(t), this.createPositionAfter(t));
          this.remove(t);
        }
        addMarker(t, e) {
          this._assertWriterUsedCorrectly();
          if (!e || typeof e.usingOperation != 'boolean') {
            throw new h('writer-addmarker-no-usingoperation', this);
          }
          const n = e.usingOperation;
          const i = e.range;
          const o =
            e.affectsData === undefined ? false : e.affectsData;
          if (this.model.markers.has(t)) {
            throw new h('writer-addmarker-marker-exists', this);
          }
          if (!i) {
            throw new h('writer-addmarker-no-range', this);
          }
          if (!n) {
            return this.model.markers._set(t, i, n, o);
          }
          Qk(this, t, null, i, o);
          return this.model.markers.get(t);
        }
        updateMarker(t, e) {
          this._assertWriterUsedCorrectly();
          const n = typeof t == 'string' ? t : t.name;
          const i = this.model.markers.get(n);
          if (!i) {
            throw new h(
              'writer-updatemarker-marker-not-exists',
              this
            );
          }
          if (!e) {
            u(
              'writer-updatemarker-reconvert-using-editingcontroller',
              { markerName: n }
            );
            this.model.markers._refresh(i);
            return;
          }
          const o = typeof e.usingOperation == 'boolean';
          const r = typeof e.affectsData == 'boolean';
          const s = r ? e.affectsData : i.affectsData;
          if (!o && !e.range && !r) {
            throw new h('writer-updatemarker-wrong-options', this);
          }
          const a = i.getRange();
          const c = e.range ? e.range : a;
          if (o && e.usingOperation !== i.managedUsingOperations) {
            if (e.usingOperation) {
              Qk(this, n, null, c, s);
            } else {
              Qk(this, n, a, null, s);
              this.model.markers._set(n, c, undefined, s);
            }
            return;
          }
          if (i.managedUsingOperations) {
            Qk(this, n, a, c, s);
          } else {
            this.model.markers._set(n, c, undefined, s);
          }
        }
        removeMarker(t) {
          this._assertWriterUsedCorrectly();
          const e = typeof t == 'string' ? t : t.name;
          if (!this.model.markers.has(e)) {
            throw new h('writer-removemarker-no-marker', this);
          }
          const n = this.model.markers.get(e);
          if (!n.managedUsingOperations) {
            this.model.markers._remove(e);
            return;
          }
          const i = n.getRange();
          Qk(this, e, i, null, n.affectsData);
        }
        setSelection(...t) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setTo(...t);
        }
        setSelectionFocus(t, e) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setFocus(t, e);
        }
        setSelectionAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (typeof t === 'string') {
            this._setSelectionAttribute(t, e);
          } else {
            for (const [e, n] of Za(t)) {
              this._setSelectionAttribute(e, n);
            }
          }
        }
        removeSelectionAttribute(t) {
          this._assertWriterUsedCorrectly();
          if (typeof t === 'string') {
            this._removeSelectionAttribute(t);
          } else {
            for (const e of t) {
              this._removeSelectionAttribute(e);
            }
          }
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(t) {
          this.model.document.selection._restoreGravity(t);
        }
        _setSelectionAttribute(t, e) {
          const n = this.model.document.selection;
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const i = em._getStoreAttributeKey(t);
            this.setAttribute(i, e, n.anchor.parent);
          }
          n._setAttribute(t, e);
        }
        _removeSelectionAttribute(t) {
          const e = this.model.document.selection;
          if (e.isCollapsed && e.anchor.parent.isEmpty) {
            const n = em._getStoreAttributeKey(t);
            this.removeAttribute(n, e.anchor.parent);
          }
          e._removeAttribute(t);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this) {
            throw new h('writer-incorrect-use', this);
          }
        }
        _addOperationForAffectedMarkers(t, e) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations) {
              continue;
            }
            const i = n.getRange();
            let o = false;
            if (t === 'move') {
              const t = e;
              o =
                t.containsPosition(i.start) ||
                t.start.isEqual(i.start) ||
                t.containsPosition(i.end) ||
                t.end.isEqual(i.end);
            } else {
              const t = e;
              const n = t.nodeBefore;
              const r = t.nodeAfter;
              const s = i.start.parent == n && i.start.isAtEnd;
              const a = i.end.parent == r && i.end.offset == 0;
              const c = i.end.nodeAfter == r;
              const l = i.start.nodeAfter == r;
              o = s || a || c || l;
            }
            if (o) {
              this.updateMarker(n.name, { range: i });
            }
          }
        }
      }
      function Jk(t, e, n, i) {
        const o = t.model;
        const r = o.document;
        let s = i.start;
        let a;
        let c;
        let l;
        for (const t of i.getWalker({ shallow: true })) {
          l = t.item.getAttribute(e);
          if (a && c != l) {
            if (c != n) {
              d();
            }
            s = a;
          }
          a = t.nextPosition;
          c = l;
        }
        if (a instanceof Ig && a != s && c != n) {
          d();
        }
        function d() {
          const i = new Fg(s, a);
          const l = i.root.document ? r.version : null;
          const d = new Ok(i, e, c, n, l);
          t.batch.addOperation(d);
          o.applyOperation(d);
        }
      }
      function Yk(t, e, n, i) {
        const o = t.model;
        const r = o.document;
        const s = i.getAttribute(e);
        let a, c;
        if (s != n) {
          const l = i.root === i;
          if (l) {
            const t = i.document ? r.version : null;
            c = new Hk(i, e, s, n, t);
          } else {
            a = new Fg(Ig._createBefore(i), t.createPositionAfter(i));
            const o = a.root.document ? r.version : null;
            c = new Ok(a, e, s, n, o);
          }
          t.batch.addOperation(c);
          o.applyOperation(c);
        }
      }
      function Qk(t, e, n, i, o) {
        const r = t.model;
        const s = r.document;
        const a = new Mk(e, n, i, r.markers, !!o, s.version);
        t.batch.addOperation(a);
        r.applyOperation(a);
      }
      function Xk(t, e, n, i) {
        let o;
        if (t.root.document) {
          const n = i.document;
          const r = new Ig(n.graveyard, [0]);
          o = new Fk(t, e, r, n.version);
        } else {
          o = new Gk(t, e);
        }
        n.addOperation(o);
        i.applyOperation(o);
      }
      function tb(t, e) {
        if (t === e) {
          return true;
        }
        if (t instanceof dk && e instanceof dk) {
          return true;
        }
        return false;
      }
      function eb(t) {
        t.document.registerPostFixer((e) => nb(e, t));
      }
      function nb(t, e) {
        const n = e.document.selection;
        const i = e.schema;
        const o = [];
        let r = false;
        for (const t of n.getRanges()) {
          const e = ib(t, i);
          if (e && !e.isEqual(t)) {
            o.push(e);
            r = true;
          } else {
            o.push(t);
          }
        }
        if (r) {
          t.setSelection(cb(o), { backward: n.isBackward });
        }
        return false;
      }
      function ib(t, e) {
        if (t.isCollapsed) {
          return ob(t, e);
        }
        return rb(t, e);
      }
      function ob(t, e) {
        const n = t.start;
        const i = e.getNearestSelectionRange(n);
        if (!i) {
          const t = n
            .getAncestors()
            .reverse()
            .find((t) => e.isObject(t));
          if (t) {
            return Fg._createOn(t);
          }
          return null;
        }
        if (!i.isCollapsed) {
          return i;
        }
        const o = i.start;
        if (n.isEqual(o)) {
          return null;
        }
        return new Fg(o);
      }
      function rb(t, e) {
        const { start: n, end: i } = t;
        const o = e.checkChild(n, '$text');
        const r = e.checkChild(i, '$text');
        const s = e.getLimitElement(n);
        const a = e.getLimitElement(i);
        if (s === a) {
          if (o && r) {
            return null;
          }
          if (ab(n, i, e)) {
            const t = n.nodeAfter && e.isSelectable(n.nodeAfter);
            const o = t
              ? null
              : e.getNearestSelectionRange(n, 'forward');
            const r = i.nodeBefore && e.isSelectable(i.nodeBefore);
            const s = r
              ? null
              : e.getNearestSelectionRange(i, 'backward');
            const a = o ? o.start : n;
            const c = s ? s.end : i;
            return new Fg(a, c);
          }
        }
        const c = s && !s.is('rootElement');
        const l = a && !a.is('rootElement');
        if (c || l) {
          const t =
            n.nodeAfter &&
            i.nodeBefore &&
            n.nodeAfter.parent === i.nodeBefore.parent;
          const o = c && (!t || !lb(n.nodeAfter, e));
          const r = l && (!t || !lb(i.nodeBefore, e));
          let d = n;
          let h = i;
          if (o) {
            d = Ig._createBefore(sb(s, e));
          }
          if (r) {
            h = Ig._createAfter(sb(a, e));
          }
          return new Fg(d, h);
        }
        return null;
      }
      function sb(t, e) {
        let n = t;
        let i = n;
        while (e.isLimit(i) && i.parent) {
          n = i;
          i = i.parent;
        }
        return n;
      }
      function ab(t, e, n) {
        const i =
          (t.nodeAfter && !n.isLimit(t.nodeAfter)) ||
          n.checkChild(t, '$text');
        const o =
          (e.nodeBefore && !n.isLimit(e.nodeBefore)) ||
          n.checkChild(e, '$text');
        return i || o;
      }
      function cb(t) {
        const e = [...t];
        const n = new Set();
        let i = 1;
        while (i < e.length) {
          const t = e[i];
          const o = e.slice(0, i);
          for (const [r, s] of o.entries()) {
            if (n.has(r)) {
              continue;
            }
            if (t.isEqual(s)) {
              n.add(r);
            } else if (t.isIntersecting(s)) {
              n.add(r);
              n.add(i);
              const o = t.getJoined(s);
              e.push(o);
            }
          }
          i++;
        }
        const o = e.filter((t, e) => !n.has(e));
        return o;
      }
      function lb(t, e) {
        return t && e.isSelectable(t);
      }
      class db extends C(Ig) {
        constructor(t, e, n = 'toNone') {
          super(t, e, n);
          if (!this.root.is('rootElement')) {
            throw new h('model-liveposition-root-not-rootelement', t);
          }
          hb.call(this);
        }
        detach() {
          this.stopListening();
        }
        toPosition() {
          return new Ig(
            this.root,
            this.path.slice(),
            this.stickiness
          );
        }
        static fromPosition(t, e) {
          return new this(
            t.root,
            t.path.slice(),
            e ? e : t.stickiness
          );
        }
      }
      db.prototype.is = function (t) {
        return (
          t === 'livePosition' ||
          t === 'model:livePosition' ||
          t == 'position' ||
          t === 'model:position'
        );
      };
      function hb() {
        this.listenTo(
          this.root.document.model,
          'applyOperation',
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            ub.call(this, n);
          },
          { priority: 'low' }
        );
      }
      function ub(t) {
        const e = this.getTransformedByOperation(t);
        if (!this.isEqual(e)) {
          const t = this.toPosition();
          this.path = e.path;
          this.root = e.root;
          this.fire('change', t);
        }
      }
      function fb(t, e, n = {}) {
        if (e.isCollapsed) {
          return;
        }
        const i = e.getFirstRange();
        if (i.root.rootName == '$graveyard') {
          return;
        }
        const o = t.schema;
        t.change((t) => {
          if (!n.doNotResetEntireContent && Eb(o, e)) {
            xb(t, e);
            return;
          }
          const r = {};
          if (!n.doNotAutoparagraph) {
            const t = e.getSelectedElement();
            if (t) {
              Object.assign(
                r,
                o.getAttributesWithProperty(t, 'copyOnReplace', true)
              );
            }
          }
          const [s, a] = gb(i);
          if (!s.isTouching(a)) {
            t.remove(t.createRange(s, a));
          }
          if (!n.leaveUnmerged) {
            pb(t, s, a);
            o.removeDisallowedAttributes(s.parent.getChildren(), t);
          }
          Db(t, e, s);
          if (!n.doNotAutoparagraph && Ab(o, s)) {
            yb(t, s, e, r);
          }
          s.detach();
          a.detach();
        });
      }
      function gb(t) {
        const e = t.root.document.model;
        const n = t.start;
        let i = t.end;
        if (e.hasContent(t, { ignoreMarkers: true })) {
          const n = mb(i);
          if (n && i.isTouching(e.createPositionAt(n, 0))) {
            const n = e.createSelection(t);
            e.modifySelection(n, { direction: 'backward' });
            const o = n.getLastPosition();
            const r = e.createRange(o, i);
            if (!e.hasContent(r, { ignoreMarkers: true })) {
              i = o;
            }
          }
        }
        return [
          db.fromPosition(n, 'toPrevious'),
          db.fromPosition(i, 'toNext'),
        ];
      }
      function mb(t) {
        const e = t.parent;
        const n = e.root.document.model.schema;
        const i = e.getAncestors({
          parentFirst: true,
          includeSelf: true,
        });
        for (const t of i) {
          if (n.isLimit(t)) {
            return null;
          }
          if (n.isBlock(t)) {
            return t;
          }
        }
      }
      function pb(t, e, n) {
        const i = t.model;
        if (!_b(t.model.schema, e, n)) {
          return;
        }
        const [o, r] = vb(e, n);
        if (!o || !r) {
          return;
        }
        if (
          !i.hasContent(o, { ignoreMarkers: true }) &&
          i.hasContent(r, { ignoreMarkers: true })
        ) {
          bb(t, e, n, o.parent);
        } else {
          kb(t, e, n, o.parent);
        }
      }
      function kb(t, e, n, i) {
        const o = e.parent;
        const r = n.parent;
        if (o == i || r == i) {
          return;
        }
        e = t.createPositionAfter(o);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(r, e);
        }
        t.merge(e);
        while (n.parent.isEmpty) {
          const e = n.parent;
          n = t.createPositionBefore(e);
          t.remove(e);
        }
        if (!_b(t.model.schema, e, n)) {
          return;
        }
        kb(t, e, n, i);
      }
      function bb(t, e, n, i) {
        const o = e.parent;
        const r = n.parent;
        if (o == i || r == i) {
          return;
        }
        e = t.createPositionAfter(o);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(o, n);
        }
        while (e.parent.isEmpty) {
          const n = e.parent;
          e = t.createPositionBefore(n);
          t.remove(n);
        }
        n = t.createPositionBefore(r);
        wb(t, n);
        if (!_b(t.model.schema, e, n)) {
          return;
        }
        bb(t, e, n, i);
      }
      function wb(t, e) {
        const n = e.nodeBefore;
        const i = e.nodeAfter;
        if (n.name != i.name) {
          t.rename(n, i.name);
        }
        t.clearAttributes(n);
        t.setAttributes(Object.fromEntries(i.getAttributes()), n);
        t.merge(e);
      }
      function _b(t, e, n) {
        const i = e.parent;
        const o = n.parent;
        if (i == o) {
          return false;
        }
        if (t.isLimit(i) || t.isLimit(o)) {
          return false;
        }
        return Cb(e, n, t);
      }
      function vb(t, e) {
        const n = t.getAncestors();
        const i = e.getAncestors();
        let o = 0;
        while (n[o] && n[o] == i[o]) {
          o++;
        }
        return [n[o], i[o]];
      }
      function Ab(t, e) {
        const n = t.checkChild(e, '$text');
        const i = t.checkChild(e, 'paragraph');
        return !n && i;
      }
      function Cb(t, e, n) {
        const i = new Fg(t, e);
        for (const t of i.getWalker()) {
          if (n.isLimit(t.item)) {
            return false;
          }
        }
        return true;
      }
      function yb(t, e, n, i = {}) {
        const o = t.createElement('paragraph');
        t.model.schema.setAllowedAttributes(o, i, t);
        t.insert(o, e);
        Db(t, n, t.createPositionAt(o, 0));
      }
      function xb(t, e) {
        const n = t.model.schema.getLimitElement(e);
        t.remove(t.createRangeIn(n));
        yb(t, t.createPositionAt(n, 0), e);
      }
      function Eb(t, e) {
        const n = t.getLimitElement(e);
        if (!e.containsEntireContent(n)) {
          return false;
        }
        const i = e.getFirstRange();
        if (i.start.parent == i.end.parent) {
          return false;
        }
        return t.checkChild(n, 'paragraph');
      }
      function Db(t, e, n) {
        if (e instanceof em) {
          t.setSelection(n);
        } else {
          e.setTo(n);
        }
      }
      function Sb(t, e) {
        return t.change((t) => {
          const n = t.createDocumentFragment();
          const i = e.getFirstRange();
          if (!i || i.isCollapsed) {
            return n;
          }
          const o = i.start.root;
          const r = i.start.getCommonPath(i.end);
          const s = o.getNodeByPath(r);
          let a;
          if (i.start.parent == i.end.parent) {
            a = i;
          } else {
            a = t.createRange(
              t.createPositionAt(s, i.start.path[r.length]),
              t.createPositionAt(s, i.end.path[r.length] + 1)
            );
          }
          const c = a.end.offset - a.start.offset;
          for (const e of a.getItems({ shallow: true })) {
            if (e.is('$textProxy')) {
              t.appendText(e.data, e.getAttributes(), n);
            } else {
              t.append(t.cloneElement(e, true), n);
            }
          }
          if (a != i) {
            const e = i._getTransformedByMove(
              a.start,
              t.createPositionAt(n, 0),
              c
            )[0];
            const o = t.createRange(
              t.createPositionAt(n, 0),
              e.start
            );
            const r = t.createRange(
              e.end,
              t.createPositionAt(n, 'end')
            );
            Tb(r, t);
            Tb(o, t);
          }
          return n;
        });
      }
      function Tb(t, e) {
        const n = [];
        Array.from(t.getItems({ direction: 'backward' }))
          .map((t) => e.createRangeOn(t))
          .filter((e) => {
            const n =
              (e.start.isAfter(t.start) ||
                e.start.isEqual(t.start)) &&
              (e.end.isBefore(t.end) || e.end.isEqual(t.end));
            return n;
          })
          .forEach((t) => {
            n.push(t.start.parent);
            e.remove(t);
          });
        n.forEach((t) => {
          let n = t;
          while (n.parent && n.isEmpty) {
            const t = e.createRangeOn(n);
            n = n.parent;
            e.remove(t);
          }
        });
      }
      function Bb(t, e, n, i) {
        return t.change((o) => {
          let r;
          if (!n) {
            r = t.document.selection;
          } else if (n instanceof Wg || n instanceof em) {
            r = n;
          } else {
            r = o.createSelection(n, i);
          }
          if (!r.isCollapsed) {
            t.deleteContent(r, { doNotAutoparagraph: true });
          }
          const s = new Pb(t, o, r.anchor);
          let a;
          if (e.is('documentFragment')) {
            a = e.getChildren();
          } else {
            a = [e];
          }
          s.handleNodes(a);
          const c = s.getSelectionRange();
          if (c) {
            if (r instanceof em) {
              o.setSelection(c);
            } else {
              r.setTo(c);
            }
          } else {
          }
          const l = s.getAffectedRange() || t.createRange(r.anchor);
          s.destroy();
          return l;
        });
      }
      class Pb {
        constructor(t, e, n) {
          this.model = t;
          this.writer = e;
          this.position = n;
          this.canMergeWith = new Set([this.position.parent]);
          this.schema = t.schema;
          this._documentFragment = e.createDocumentFragment();
          this._documentFragmentPosition = e.createPositionAt(
            this._documentFragment,
            0
          );
          this._firstNode = null;
          this._lastNode = null;
          this._lastAutoParagraph = null;
          this._filterAttributesOf = [];
          this._affectedStart = null;
          this._affectedEnd = null;
        }
        handleNodes(t) {
          for (const e of Array.from(t)) {
            this._handleNode(e);
          }
          this._insertPartialFragment();
          if (this._lastAutoParagraph) {
            this._updateLastNodeFromAutoParagraph(
              this._lastAutoParagraph
            );
          }
          this._mergeOnRight();
          this.schema.removeDisallowedAttributes(
            this._filterAttributesOf,
            this.writer
          );
          this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(t) {
          const e = this.writer.createPositionAfter(this._lastNode);
          const n = this.writer.createPositionAfter(t);
          if (n.isAfter(e)) {
            this._lastNode = t;
            if (this.position.parent != t || !this.position.isAtEnd) {
              throw new h(
                'insertcontent-invalid-insertion-position',
                this
              );
            }
            this.position = n;
            this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          if (this._nodeToSelect) {
            return Fg._createOn(this._nodeToSelect);
          }
          return this.model.schema.getNearestSelectionRange(
            this.position
          );
        }
        getAffectedRange() {
          if (!this._affectedStart) {
            return null;
          }
          return new Fg(this._affectedStart, this._affectedEnd);
        }
        destroy() {
          if (this._affectedStart) {
            this._affectedStart.detach();
          }
          if (this._affectedEnd) {
            this._affectedEnd.detach();
          }
        }
        _handleNode(t) {
          if (this.schema.isObject(t)) {
            this._handleObject(t);
            return;
          }
          let e = this._checkAndAutoParagraphToAllowedPosition(t);
          if (!e) {
            e = this._checkAndSplitToAllowedPosition(t);
            if (!e) {
              this._handleDisallowedNode(t);
              return;
            }
          }
          this._appendToFragment(t);
          if (!this._firstNode) {
            this._firstNode = t;
          }
          this._lastNode = t;
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty) {
            return;
          }
          const t = db.fromPosition(this.position, 'toNext');
          this._setAffectedBoundaries(this.position);
          if (this._documentFragment.getChild(0) == this._firstNode) {
            this.writer.insert(this._firstNode, this.position);
            this._mergeOnLeft();
            this.position = t.toPosition();
          }
          if (!this._documentFragment.isEmpty) {
            this.writer.insert(this._documentFragment, this.position);
          }
          this._documentFragmentPosition =
            this.writer.createPositionAt(this._documentFragment, 0);
          this.position = t.toPosition();
          t.detach();
        }
        _handleObject(t) {
          if (this._checkAndSplitToAllowedPosition(t)) {
            this._appendToFragment(t);
          } else {
            this._tryAutoparagraphing(t);
          }
        }
        _handleDisallowedNode(t) {
          if (t.is('element')) {
            this.handleNodes(t.getChildren());
          } else {
            this._tryAutoparagraphing(t);
          }
        }
        _appendToFragment(t) {
          if (!this.schema.checkChild(this.position, t)) {
            throw new h('insertcontent-wrong-position', this, {
              node: t,
              position: this.position,
            });
          }
          this.writer.insert(t, this._documentFragmentPosition);
          this._documentFragmentPosition =
            this._documentFragmentPosition.getShiftedBy(t.offsetSize);
          if (
            this.schema.isObject(t) &&
            !this.schema.checkChild(this.position, '$text')
          ) {
            this._nodeToSelect = t;
          } else {
            this._nodeToSelect = null;
          }
          this._filterAttributesOf.push(t);
        }
        _setAffectedBoundaries(t) {
          if (!this._affectedStart) {
            this._affectedStart = db.fromPosition(t, 'toPrevious');
          }
          if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
            if (this._affectedEnd) {
              this._affectedEnd.detach();
            }
            this._affectedEnd = db.fromPosition(t, 'toNext');
          }
        }
        _mergeOnLeft() {
          const t = this._firstNode;
          if (!(t instanceof Sg)) {
            return;
          }
          if (!this._canMergeLeft(t)) {
            return;
          }
          const e = db._createBefore(t);
          e.stickiness = 'toNext';
          const n = db.fromPosition(this.position, 'toNext');
          if (this._affectedStart.isEqual(e)) {
            this._affectedStart.detach();
            this._affectedStart = db._createAt(
              e.nodeBefore,
              'end',
              'toPrevious'
            );
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore;
            this._lastNode = e.nodeBefore;
          }
          this.writer.merge(e);
          if (
            e.isEqual(this._affectedEnd) &&
            this._firstNode === this._lastNode
          ) {
            this._affectedEnd.detach();
            this._affectedEnd = db._createAt(
              e.nodeBefore,
              'end',
              'toNext'
            );
          }
          this.position = n.toPosition();
          n.detach();
          this._filterAttributesOf.push(this.position.parent);
          e.detach();
        }
        _mergeOnRight() {
          const t = this._lastNode;
          if (!(t instanceof Sg)) {
            return;
          }
          if (!this._canMergeRight(t)) {
            return;
          }
          const e = db._createAfter(t);
          e.stickiness = 'toNext';
          if (!this.position.isEqual(e)) {
            throw new h(
              'insertcontent-invalid-insertion-position',
              this
            );
          }
          this.position = Ig._createAt(e.nodeBefore, 'end');
          const n = db.fromPosition(this.position, 'toPrevious');
          if (this._affectedEnd.isEqual(e)) {
            this._affectedEnd.detach();
            this._affectedEnd = db._createAt(
              e.nodeBefore,
              'end',
              'toNext'
            );
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore;
            this._lastNode = e.nodeBefore;
          }
          this.writer.merge(e);
          if (
            e.getShiftedBy(-1).isEqual(this._affectedStart) &&
            this._firstNode === this._lastNode
          ) {
            this._affectedStart.detach();
            this._affectedStart = db._createAt(
              e.nodeBefore,
              0,
              'toPrevious'
            );
          }
          this.position = n.toPosition();
          n.detach();
          this._filterAttributesOf.push(this.position.parent);
          e.detach();
        }
        _canMergeLeft(t) {
          const e = t.previousSibling;
          return (
            e instanceof Sg &&
            this.canMergeWith.has(e) &&
            this.model.schema.checkMerge(e, t)
          );
        }
        _canMergeRight(t) {
          const e = t.nextSibling;
          return (
            e instanceof Sg &&
            this.canMergeWith.has(e) &&
            this.model.schema.checkMerge(t, e)
          );
        }
        _tryAutoparagraphing(t) {
          const e = this.writer.createElement('paragraph');
          if (
            this._getAllowedIn(this.position.parent, e) &&
            this.schema.checkChild(e, t)
          ) {
            e._appendChild(t);
            this._handleNode(e);
          }
        }
        _checkAndAutoParagraphToAllowedPosition(t) {
          if (this.schema.checkChild(this.position.parent, t)) {
            return true;
          }
          if (
            !this.schema.checkChild(
              this.position.parent,
              'paragraph'
            ) ||
            !this.schema.checkChild('paragraph', t)
          ) {
            return false;
          }
          this._insertPartialFragment();
          const e = this.writer.createElement('paragraph');
          this.writer.insert(e, this.position);
          this._setAffectedBoundaries(this.position);
          this._lastAutoParagraph = e;
          this.position = this.writer.createPositionAt(e, 0);
          return true;
        }
        _checkAndSplitToAllowedPosition(t) {
          const e = this._getAllowedIn(this.position.parent, t);
          if (!e) {
            return false;
          }
          if (e != this.position.parent) {
            this._insertPartialFragment();
          }
          while (e != this.position.parent) {
            if (this.position.isAtStart) {
              const t = this.position.parent;
              this.position = this.writer.createPositionBefore(t);
              if (t.isEmpty && t.parent === e) {
                this.writer.remove(t);
              }
            } else if (this.position.isAtEnd) {
              this.position = this.writer.createPositionAfter(
                this.position.parent
              );
            } else {
              const t = this.writer.createPositionAfter(
                this.position.parent
              );
              this._setAffectedBoundaries(this.position);
              this.writer.split(this.position);
              this.position = t;
              this.canMergeWith.add(this.position.nodeAfter);
            }
          }
          return true;
        }
        _getAllowedIn(t, e) {
          if (this.schema.checkChild(t, e)) {
            return t;
          }
          if (this.schema.isLimit(t)) {
            return null;
          }
          return this._getAllowedIn(t.parent, e);
        }
      }
      function Ib(t, e, n = 'auto') {
        const i = t.getSelectedElement();
        if (i && e.schema.isObject(i) && !e.schema.isInline(i)) {
          if (n == 'before' || n == 'after') {
            return e.createRange(e.createPositionAt(i, n));
          }
          return e.createRangeOn(i);
        }
        const o = Xf(t.getSelectedBlocks());
        if (!o) {
          return e.createRange(t.focus);
        }
        if (o.isEmpty) {
          return e.createRange(e.createPositionAt(o, 0));
        }
        const r = e.createPositionAfter(o);
        if (t.focus.isTouching(r)) {
          return e.createRange(r);
        }
        return e.createRange(e.createPositionBefore(o));
      }
      function Rb(t, e, n, i, o = {}) {
        if (!t.schema.isObject(e)) {
          throw new h('insertobject-element-not-an-object', t, {
            object: e,
          });
        }
        let r;
        if (!n) {
          r = t.document.selection;
        } else if (n instanceof Wg || n instanceof em) {
          r = n;
        } else {
          r = t.createSelection(n, i);
        }
        let s = r;
        if (o.findOptimalPosition && t.schema.isBlock(e)) {
          s = t.createSelection(Ib(r, t, o.findOptimalPosition));
        }
        const a = Xf(r.getSelectedBlocks());
        const c = {};
        if (a) {
          Object.assign(
            c,
            t.schema.getAttributesWithProperty(
              a,
              'copyOnReplace',
              true
            )
          );
        }
        return t.change((n) => {
          if (!s.isCollapsed) {
            t.deleteContent(s, { doNotAutoparagraph: true });
          }
          let i = e;
          const r = s.anchor.parent;
          if (
            !t.schema.checkChild(r, e) &&
            t.schema.checkChild(r, 'paragraph') &&
            t.schema.checkChild('paragraph', e)
          ) {
            i = n.createElement('paragraph');
            n.insert(e, i);
          }
          t.schema.setAllowedAttributes(i, c, n);
          const a = t.insertContent(i, s);
          if (a.isCollapsed) {
            return a;
          }
          if (o.setSelection) {
            zb(n, e, o.setSelection, c);
          }
          return a;
        });
      }
      function zb(t, e, n, i) {
        const o = t.model;
        if (n == 'after') {
          let n = e.nextSibling;
          const r = n && o.schema.checkChild(n, '$text');
          if (!r && o.schema.checkChild(e.parent, 'paragraph')) {
            n = t.createElement('paragraph');
            o.schema.setAllowedAttributes(n, i, t);
            o.insertContent(n, t.createPositionAfter(e));
          }
          if (n) {
            t.setSelection(n, 0);
          }
        } else if (n == 'on') {
          t.setSelection(e, 'on');
        } else {
          throw new h(
            'insertobject-invalid-place-parameter-value',
            o
          );
        }
      }
      const Ob = ' ,.?!:;"-()';
      function Fb(t, e, n = {}) {
        const i = t.schema;
        const o = n.direction != 'backward';
        const r = n.unit ? n.unit : 'character';
        const s = !!n.treatEmojiAsSingleUnit;
        const a = e.focus;
        const c = new Bg({
          boundaries: Vb(a, o),
          singleCharacters: true,
          direction: o ? 'forward' : 'backward',
        });
        const l = {
          walker: c,
          schema: i,
          isForward: o,
          unit: r,
          treatEmojiAsSingleUnit: s,
        };
        let d;
        while ((d = c.next())) {
          if (d.done) {
            return;
          }
          const n = Nb(l, d.value);
          if (n) {
            if (e instanceof em) {
              t.change((t) => {
                t.setSelectionFocus(n);
              });
            } else {
              e.setFocus(n);
            }
            return;
          }
        }
      }
      function Nb(t, e) {
        const {
          isForward: n,
          walker: i,
          unit: o,
          schema: r,
          treatEmojiAsSingleUnit: s,
        } = t;
        const { type: a, item: c, nextPosition: l } = e;
        if (a == 'text') {
          if (t.unit === 'word') {
            return Lb(i, n);
          }
          return Mb(i, o, s);
        }
        if (a == (n ? 'elementStart' : 'elementEnd')) {
          if (r.isSelectable(c)) {
            return Ig._createAt(c, n ? 'after' : 'before');
          }
          if (r.checkChild(l, '$text')) {
            return l;
          }
        } else {
          if (r.isLimit(c)) {
            i.skip(() => true);
            return;
          }
          if (r.checkChild(l, '$text')) {
            return l;
          }
        }
      }
      function Mb(t, e, n) {
        const i = t.position.textNode;
        if (i) {
          const o = i.data;
          let r = t.position.offset - i.startOffset;
          while (
            gk(o, r) ||
            (e == 'character' && mk(o, r)) ||
            (n && kk(o, r))
          ) {
            t.next();
            r = t.position.offset - i.startOffset;
          }
        }
        return t.position;
      }
      function Lb(t, e) {
        let n = t.position.textNode;
        if (n) {
          let i = t.position.offset - n.startOffset;
          while (!Hb(n.data, i, e) && !jb(n, i, e)) {
            t.next();
            const o = e
              ? t.position.nodeAfter
              : t.position.nodeBefore;
            if (o && o.is('$text')) {
              const i = o.data.charAt(e ? 0 : o.data.length - 1);
              if (!Ob.includes(i)) {
                t.next();
                n = t.position.textNode;
              }
            }
            i = t.position.offset - n.startOffset;
          }
        }
        return t.position;
      }
      function Vb(t, e) {
        const n = t.root;
        const i = Ig._createAt(n, e ? 'end' : 0);
        if (e) {
          return new Fg(t, i);
        } else {
          return new Fg(i, t);
        }
      }
      function Hb(t, e, n) {
        const i = e + (n ? 0 : -1);
        return Ob.includes(t.charAt(i));
      }
      function jb(t, e, n) {
        return e === (n ? t.endOffset : 0);
      }
      class qb extends W {
        constructor() {
          super();
          this.markers = new Ak();
          this.document = new _k(this);
          this.schema = new Sp();
          this._pendingChanges = [];
          this._currentWriter = null;
          [
            'insertContent',
            'insertObject',
            'deleteContent',
            'modifySelection',
            'getSelectedContent',
            'applyOperation',
          ].forEach((t) => this.decorate(t));
          this.on(
            'applyOperation',
            (t, e) => {
              const n = e[0];
              n._validate();
            },
            { priority: 'highest' }
          );
          this.schema.register('$root', { isLimit: true });
          this.schema.register('$container', {
            allowIn: ['$root', '$container'],
          });
          this.schema.register('$block', {
            allowIn: ['$root', '$container'],
            isBlock: true,
          });
          this.schema.register('$blockObject', {
            allowWhere: '$block',
            isBlock: true,
            isObject: true,
          });
          this.schema.register('$inlineObject', {
            allowWhere: '$text',
            allowAttributesOf: '$text',
            isInline: true,
            isObject: true,
          });
          this.schema.register('$text', {
            allowIn: '$block',
            isInline: true,
            isContent: true,
          });
          this.schema.register('$clipboardHolder', {
            allowContentOf: '$root',
            allowChildren: '$text',
            isLimit: true,
          });
          this.schema.register('$documentFragment', {
            allowContentOf: '$root',
            allowChildren: '$text',
            isLimit: true,
          });
          this.schema.register('$marker');
          this.schema.addChildCheck((t, e) => {
            if (e.name === '$marker') {
              return true;
            }
          });
          eb(this);
          this.document.registerPostFixer(tp);
        }
        change(t) {
          try {
            if (this._pendingChanges.length === 0) {
              this._pendingChanges.push({
                batch: new ok(),
                callback: t,
              });
              return this._runPendingChanges()[0];
            } else {
              return t(this._currentWriter);
            }
          } catch (t) {
            h.rethrowUnexpectedError(t, this);
          }
        }
        enqueueChange(t, e) {
          try {
            if (!t) {
              t = new ok();
            } else if (typeof t === 'function') {
              e = t;
              t = new ok();
            } else if (!(t instanceof ok)) {
              t = new ok(t);
            }
            this._pendingChanges.push({ batch: t, callback: e });
            if (this._pendingChanges.length == 1) {
              this._runPendingChanges();
            }
          } catch (t) {
            h.rethrowUnexpectedError(t, this);
          }
        }
        applyOperation(t) {
          t._execute();
        }
        insertContent(t, e, n) {
          return Bb(this, t, e, n);
        }
        insertObject(t, e, n, i) {
          return Rb(this, t, e, n, i);
        }
        deleteContent(t, e) {
          fb(this, t, e);
        }
        modifySelection(t, e) {
          Fb(this, t, e);
        }
        getSelectedContent(t) {
          return Sb(this, t);
        }
        hasContent(t, e = {}) {
          const n = t instanceof Fg ? t : Fg._createIn(t);
          if (n.isCollapsed) {
            return false;
          }
          const {
            ignoreWhitespaces: i = false,
            ignoreMarkers: o = false,
          } = e;
          if (!o) {
            for (const t of this.markers.getMarkersIntersectingRange(
              n
            )) {
              if (t.affectsData) {
                return true;
              }
            }
          }
          for (const t of n.getItems()) {
            if (this.schema.isContent(t)) {
              if (t.is('$textProxy')) {
                if (!i) {
                  return true;
                } else if (t.data.search(/\S/) !== -1) {
                  return true;
                }
              } else {
                return true;
              }
            }
          }
          return false;
        }
        createPositionFromPath(t, e, n) {
          return new Ig(t, e, n);
        }
        createPositionAt(t, e) {
          return Ig._createAt(t, e);
        }
        createPositionAfter(t) {
          return Ig._createAfter(t);
        }
        createPositionBefore(t) {
          return Ig._createBefore(t);
        }
        createRange(t, e) {
          return new Fg(t, e);
        }
        createRangeIn(t) {
          return Fg._createIn(t);
        }
        createRangeOn(t) {
          return Fg._createOn(t);
        }
        createSelection(...t) {
          return new Wg(...t);
        }
        createBatch(t) {
          return new ok(t);
        }
        createOperationFromJSON(t) {
          return Uk.fromJSON(t, this.document);
        }
        destroy() {
          this.document.destroy();
          this.stopListening();
        }
        _runPendingChanges() {
          const t = [];
          this.fire('_beforeChanges');
          try {
            while (this._pendingChanges.length) {
              const e = this._pendingChanges[0].batch;
              this._currentWriter = new Zk(this, e);
              const n = this._pendingChanges[0].callback(
                this._currentWriter
              );
              t.push(n);
              this.document._handleChangeBlock(this._currentWriter);
              this._pendingChanges.shift();
              this._currentWriter = null;
            }
          } finally {
            this._pendingChanges.length = 0;
            this._currentWriter = null;
            this.fire('_afterChanges');
          }
          return t;
        }
      }
      class Wb extends eg {
        constructor(t) {
          super();
          this.editor = t;
        }
        set(t, e, n = {}) {
          if (typeof e == 'string') {
            const t = e;
            e = (e, n) => {
              this.editor.execute(t);
              n();
            };
          }
          super.set(t, e, n);
        }
      }
      class Ub {
        constructor(t = {}) {
          const e =
            t.language ||
            (this.constructor.defaultConfig &&
              this.constructor.defaultConfig.language);
          this._context = t.context || new Ma({ language: e });
          this._context._addEditor(this, !t.context);
          const n = Array.from(this.constructor.builtinPlugins || []);
          this.config = new _a(t, this.constructor.defaultConfig);
          this.config.define('plugins', n);
          this.config.define(this._context._getEditorConfig());
          this.plugins = new xa(this, n, this._context.plugins);
          this.locale = this._context.locale;
          this.t = this.locale.t;
          this._readOnlyLocks = new Set();
          this.commands = new yp();
          this.set('state', 'initializing');
          this.once('ready', () => (this.state = 'ready'), {
            priority: 'high',
          });
          this.once('destroy', () => (this.state = 'destroyed'), {
            priority: 'high',
          });
          this.model = new qb();
          const i = new Wl();
          this.data = new Xp(this.model, i);
          this.editing = new Cp(this.model, i);
          this.editing.view.document.bind('isReadOnly').to(this);
          this.conversion = new ek(
            [
              this.editing.downcastDispatcher,
              this.data.downcastDispatcher,
            ],
            this.data.upcastDispatcher
          );
          this.conversion.addAlias(
            'dataDowncast',
            this.data.downcastDispatcher
          );
          this.conversion.addAlias(
            'editingDowncast',
            this.editing.downcastDispatcher
          );
          this.keystrokes = new Wb(this);
          this.keystrokes.listenTo(this.editing.view.document);
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0;
        }
        set isReadOnly(t) {
          throw new h('editor-isreadonly-has-no-setter');
        }
        enableReadOnlyMode(t) {
          if (typeof t !== 'string' && typeof t !== 'symbol') {
            throw new h('editor-read-only-lock-id-invalid', null, {
              lockId: t,
            });
          }
          if (this._readOnlyLocks.has(t)) {
            return;
          }
          this._readOnlyLocks.add(t);
          if (this._readOnlyLocks.size === 1) {
            this.fire('change:isReadOnly', 'isReadOnly', true, false);
          }
        }
        disableReadOnlyMode(t) {
          if (typeof t !== 'string' && typeof t !== 'symbol') {
            throw new h('editor-read-only-lock-id-invalid', null, {
              lockId: t,
            });
          }
          if (!this._readOnlyLocks.has(t)) {
            return;
          }
          this._readOnlyLocks.delete(t);
          if (this._readOnlyLocks.size === 0) {
            this.fire('change:isReadOnly', 'isReadOnly', false, true);
          }
        }
        initPlugins() {
          const t = this.config;
          const e = t.get('plugins');
          const n = t.get('removePlugins') || [];
          const i = t.get('extraPlugins') || [];
          const o = t.get('substitutePlugins') || [];
          return this.plugins.init(e.concat(i), n, o);
        }
        destroy() {
          let t = Promise.resolve();
          if (this.state == 'initializing') {
            t = new Promise((t) => this.once('ready', t));
          }
          return t
            .then(() => {
              this.fire('destroy');
              this.stopListening();
              this.commands.destroy();
            })
            .then(() => this.plugins.destroy())
            .then(() => {
              this.model.destroy();
              this.data.destroy();
              this.editing.destroy();
              this.keystrokes.destroy();
            })
            .then(() => this._context._removeEditor(this));
        }
        execute(...t) {
          try {
            return this.commands.execute(...t);
          } catch (t) {
            h.rethrowUnexpectedError(t, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
      }
      et(Ub, q);
      class Gb {
        constructor(t) {
          this.editor = t;
          this._components = new Map();
        }
        *names() {
          for (const t of this._components.values()) {
            yield t.originalName;
          }
        }
        add(t, e) {
          this._components.set($b(t), {
            callback: e,
            originalName: t,
          });
        }
        create(t) {
          if (!this.has(t)) {
            throw new h('componentfactory-item-missing', this, {
              name: t,
            });
          }
          return this._components
            .get($b(t))
            .callback(this.editor.locale);
        }
        has(t) {
          return this._components.has($b(t));
        }
      }
      function $b(t) {
        return String(t).toLowerCase();
      }
      class Kb extends ya {
        constructor(t = []) {
          super(t, { idProperty: 'viewUid' });
          this.on('add', (t, e, n) => {
            this._renderViewIntoCollectionParent(e, n);
          });
          this.on('remove', (t, e) => {
            if (e.element && this._parentElement) {
              e.element.remove();
            }
          });
          this._parentElement = null;
        }
        destroy() {
          this.map((t) => t.destroy());
        }
        setParent(t) {
          this._parentElement = t;
          for (const t of this) {
            this._renderViewIntoCollectionParent(t);
          }
        }
        delegate(...t) {
          if (!t.length || !Zb(t)) {
            throw new h(
              'ui-viewcollection-delegate-wrong-events',
              this
            );
          }
          return {
            to: (e) => {
              for (const n of this) {
                for (const i of t) {
                  n.delegate(i).to(e);
                }
              }
              this.on('add', (n, i) => {
                for (const n of t) {
                  i.delegate(n).to(e);
                }
              });
              this.on('remove', (n, i) => {
                for (const n of t) {
                  i.stopDelegating(n, e);
                }
              });
            },
          };
        }
        _renderViewIntoCollectionParent(t, e) {
          if (!t.isRendered) {
            t.render();
          }
          if (t.element && this._parentElement) {
            this._parentElement.insertBefore(
              t.element,
              this._parentElement.children[e]
            );
          }
        }
      }
      function Zb(t) {
        return t.every((t) => typeof t == 'string');
      }
      const Jb = 'http://www.w3.org/1999/xhtml';
      class Yb {
        constructor(t) {
          Object.assign(this, cw(aw(t)));
          this._isRendered = false;
          this._revertData = null;
        }
        render() {
          const t = this._renderNode({ intoFragment: true });
          this._isRendered = true;
          return t;
        }
        apply(t) {
          this._revertData = vw();
          this._renderNode({
            node: t,
            isApplying: true,
            revertData: this._revertData,
          });
          return t;
        }
        revert(t) {
          if (!this._revertData) {
            throw new h('ui-template-revert-not-applied', [this, t]);
          }
          this._revertTemplateFromNode(t, this._revertData);
        }
        *getViews() {
          function* t(e) {
            if (e.children) {
              for (const n of e.children) {
                if (bw(n)) {
                  yield n;
                } else if (ww(n)) {
                  yield* t(n);
                }
              }
            }
          }
          yield* t(this);
        }
        static bind(t, e) {
          return {
            to(n, i) {
              return new Xb({
                eventNameOrFunction: n,
                attribute: n,
                observable: t,
                emitter: e,
                callback: i,
              });
            },
            if(n, i, o) {
              return new tw({
                observable: t,
                emitter: e,
                attribute: n,
                valueIfTrue: i,
                callback: o,
              });
            },
          };
        }
        static extend(t, e) {
          if (t._isRendered) {
            throw new h('template-extend-render', [this, t]);
          }
          pw(t, cw(aw(e)));
        }
        _renderNode(t) {
          let e;
          if (t.node) {
            e = this.tag && this.text;
          } else {
            e = this.tag ? this.text : !this.text;
          }
          if (e) {
            throw new h('ui-template-wrong-syntax', this);
          }
          if (this.text) {
            return this._renderText(t);
          } else {
            return this._renderElement(t);
          }
        }
        _renderElement(t) {
          let e = t.node;
          if (!e) {
            e = t.node = document.createElementNS(
              this.ns || Jb,
              this.tag
            );
          }
          this._renderAttributes(t);
          this._renderElementChildren(t);
          this._setUpListeners(t);
          return e;
        }
        _renderText(t) {
          let e = t.node;
          if (e) {
            t.revertData.text = e.textContent;
          } else {
            e = t.node = document.createTextNode('');
          }
          if (ew(this.text)) {
            this._bindToObservable({
              schema: this.text,
              updater: ow(e),
              data: t,
            });
          } else {
            e.textContent = this.text.join('');
          }
          return e;
        }
        _renderAttributes(t) {
          let e, n, i, o;
          if (!this.attributes) {
            return;
          }
          const r = t.node;
          const s = t.revertData;
          for (e in this.attributes) {
            i = r.getAttribute(e);
            n = this.attributes[e];
            if (s) {
              s.attributes[e] = i;
            }
            o = N(n[0]) && n[0].ns ? n[0].ns : null;
            if (ew(n)) {
              const a = o ? n[0].value : n;
              if (s && Aw(e)) {
                a.unshift(i);
              }
              this._bindToObservable({
                schema: a,
                updater: rw(r, e, o),
                data: t,
              });
            } else if (e == 'style' && typeof n[0] !== 'string') {
              this._renderStyleAttribute(n[0], t);
            } else {
              if (s && i && Aw(e)) {
                n.unshift(i);
              }
              n = n
                .map((t) => (t ? t.value || t : t))
                .reduce((t, e) => t.concat(e), [])
                .reduce(gw, '');
              if (!kw(n)) {
                r.setAttributeNS(o, e, n);
              }
            }
          }
        }
        _renderStyleAttribute(t, e) {
          const n = e.node;
          for (const i in t) {
            const o = t[i];
            if (ew(o)) {
              this._bindToObservable({
                schema: [o],
                updater: sw(n, i),
                data: e,
              });
            } else {
              n.style[i] = o;
            }
          }
        }
        _renderElementChildren(t) {
          const e = t.node;
          const n = t.intoFragment
            ? document.createDocumentFragment()
            : e;
          const i = t.isApplying;
          let o = 0;
          for (const r of this.children) {
            if (_w(r)) {
              if (!i) {
                r.setParent(e);
                for (const t of r) {
                  n.appendChild(t.element);
                }
              }
            } else if (bw(r)) {
              if (!i) {
                if (!r.isRendered) {
                  r.render();
                }
                n.appendChild(r.element);
              }
            } else if (Nh(r)) {
              n.appendChild(r);
            } else {
              if (i) {
                const e = t.revertData;
                const i = vw();
                e.children.push(i);
                r._renderNode({
                  node: n.childNodes[o++],
                  isApplying: true,
                  revertData: i,
                });
              } else {
                n.appendChild(r.render());
              }
            }
          }
          if (t.intoFragment) {
            e.appendChild(n);
          }
        }
        _setUpListeners(t) {
          if (!this.eventListeners) {
            return;
          }
          for (const e in this.eventListeners) {
            const n = this.eventListeners[e].map((n) => {
              const [i, o] = e.split('@');
              return n.activateDomEventListener(i, o, t);
            });
            if (t.revertData) {
              t.revertData.bindings.push(n);
            }
          }
        }
        _bindToObservable({ schema: t, updater: e, data: n }) {
          const i = n.revertData;
          iw(t, e, n);
          const o = t
            .filter((t) => !kw(t))
            .filter((t) => t.observable)
            .map((i) => i.activateAttributeListener(t, e, n));
          if (i) {
            i.bindings.push(o);
          }
        }
        _revertTemplateFromNode(t, e) {
          for (const t of e.bindings) {
            for (const e of t) {
              e();
            }
          }
          if (e.text) {
            t.textContent = e.text;
            return;
          }
          for (const n in e.attributes) {
            const i = e.attributes[n];
            if (i === null) {
              t.removeAttribute(n);
            } else {
              t.setAttribute(n, i);
            }
          }
          for (let n = 0; n < e.children.length; ++n) {
            this._revertTemplateFromNode(
              t.childNodes[n],
              e.children[n]
            );
          }
        }
      }
      et(Yb, C);
      class Qb {
        constructor(t) {
          Object.assign(this, t);
        }
        getValue(t) {
          const e = this.observable[this.attribute];
          return this.callback ? this.callback(e, t) : e;
        }
        activateAttributeListener(t, e, n) {
          const i = () => iw(t, e, n);
          this.emitter.listenTo(
            this.observable,
            'change:' + this.attribute,
            i
          );
          return () => {
            this.emitter.stopListening(
              this.observable,
              'change:' + this.attribute,
              i
            );
          };
        }
      }
      class Xb extends Qb {
        activateDomEventListener(t, e, n) {
          const i = (t, n) => {
            if (!e || n.target.matches(e)) {
              if (typeof this.eventNameOrFunction == 'function') {
                this.eventNameOrFunction(n);
              } else {
                this.observable.fire(this.eventNameOrFunction, n);
              }
            }
          };
          this.emitter.listenTo(n.node, t, i);
          return () => {
            this.emitter.stopListening(n.node, t, i);
          };
        }
      }
      class tw extends Qb {
        getValue(t) {
          const e = super.getValue(t);
          return kw(e) ? false : this.valueIfTrue || true;
        }
      }
      function ew(t) {
        if (!t) {
          return false;
        }
        if (t.value) {
          t = t.value;
        }
        if (Array.isArray(t)) {
          return t.some(ew);
        } else if (t instanceof Qb) {
          return true;
        }
        return false;
      }
      function nw(t, e) {
        return t.map((t) => {
          if (t instanceof Qb) {
            return t.getValue(e);
          }
          return t;
        });
      }
      function iw(t, e, { node: n }) {
        let i = nw(t, n);
        if (t.length == 1 && t[0] instanceof tw) {
          i = i[0];
        } else {
          i = i.reduce(gw, '');
        }
        if (kw(i)) {
          e.remove();
        } else {
          e.set(i);
        }
      }
      function ow(t) {
        return {
          set(e) {
            t.textContent = e;
          },
          remove() {
            t.textContent = '';
          },
        };
      }
      function rw(t, e, n) {
        return {
          set(i) {
            t.setAttributeNS(n, e, i);
          },
          remove() {
            t.removeAttributeNS(n, e);
          },
        };
      }
      function sw(t, e) {
        return {
          set(n) {
            t.style[e] = n;
          },
          remove() {
            t.style[e] = null;
          },
        };
      }
      function aw(t) {
        const e = ka(t, (t) => {
          if (t && (t instanceof Qb || ww(t) || bw(t) || _w(t))) {
            return t;
          }
        });
        return e;
      }
      function cw(t) {
        if (typeof t == 'string') {
          t = hw(t);
        } else if (t.text) {
          uw(t);
        }
        if (t.on) {
          t.eventListeners = dw(t.on);
          delete t.on;
        }
        if (!t.text) {
          if (t.attributes) {
            lw(t.attributes);
          }
          const e = [];
          if (t.children) {
            if (_w(t.children)) {
              e.push(t.children);
            } else {
              for (const n of t.children) {
                if (ww(n) || bw(n) || Nh(n)) {
                  e.push(n);
                } else {
                  e.push(new Yb(n));
                }
              }
            }
          }
          t.children = e;
        }
        return t;
      }
      function lw(t) {
        for (const e in t) {
          if (t[e].value) {
            t[e].value = Ea(t[e].value);
          }
          fw(t, e);
        }
      }
      function dw(t) {
        for (const e in t) {
          fw(t, e);
        }
        return t;
      }
      function hw(t) {
        return { text: [t] };
      }
      function uw(t) {
        t.text = Ea(t.text);
      }
      function fw(t, e) {
        t[e] = Ea(t[e]);
      }
      function gw(t, e) {
        if (kw(e)) {
          return t;
        } else if (kw(t)) {
          return e;
        } else {
          return `${t} ${e}`;
        }
      }
      function mw(t, e) {
        for (const n in e) {
          if (t[n]) {
            t[n].push(...e[n]);
          } else {
            t[n] = e[n];
          }
        }
      }
      function pw(t, e) {
        if (e.attributes) {
          if (!t.attributes) {
            t.attributes = {};
          }
          mw(t.attributes, e.attributes);
        }
        if (e.eventListeners) {
          if (!t.eventListeners) {
            t.eventListeners = {};
          }
          mw(t.eventListeners, e.eventListeners);
        }
        if (e.text) {
          t.text.push(...e.text);
        }
        if (e.children && e.children.length) {
          if (t.children.length != e.children.length) {
            throw new h('ui-template-extend-children-mismatch', t);
          }
          let n = 0;
          for (const i of e.children) {
            pw(t.children[n++], i);
          }
        }
      }
      function kw(t) {
        return !t && t !== 0;
      }
      function bw(t) {
        return t instanceof Dw;
      }
      function ww(t) {
        return t instanceof Yb;
      }
      function _w(t) {
        return t instanceof Kb;
      }
      function vw() {
        return { children: [], bindings: [], attributes: {} };
      }
      function Aw(t) {
        return t == 'class' || t == 'style';
      }
      var Cw = n(6150);
      var yw = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      yw.insert = 'head';
      yw.singleton = true;
      var xw = Lh()(Cw.Z, yw);
      const Ew = Cw.Z.locals || {};
      class Dw {
        constructor(t) {
          this.element = null;
          this.isRendered = false;
          this.locale = t;
          this.t = t && t.t;
          this._viewCollections = new ya();
          this._unboundChildren = this.createCollection();
          this._viewCollections.on('add', (e, n) => {
            n.locale = t;
          });
          this.decorate('render');
        }
        get bindTemplate() {
          if (this._bindTemplate) {
            return this._bindTemplate;
          }
          return (this._bindTemplate = Yb.bind(this, this));
        }
        createCollection(t) {
          const e = new Kb(t);
          this._viewCollections.add(e);
          return e;
        }
        registerChild(t) {
          if (!Ca(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.add(e);
          }
        }
        deregisterChild(t) {
          if (!Ca(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.remove(e);
          }
        }
        setTemplate(t) {
          this.template = new Yb(t);
        }
        extendTemplate(t) {
          Yb.extend(this.template, t);
        }
        render() {
          if (this.isRendered) {
            throw new h('ui-view-render-already-rendered', this);
          }
          if (this.template) {
            this.element = this.template.render();
            this.registerChild(this.template.getViews());
          }
          this.isRendered = true;
        }
        destroy() {
          this.stopListening();
          this._viewCollections.map((t) => t.destroy());
          if (this.template && this.template._revertData) {
            this.template.revert(this.element);
          }
        }
      }
      et(Dw, uu);
      et(Dw, q);
      function Sw(t) {
        if (!t || !t.parentNode) {
          return null;
        }
        if (t.offsetParent === Sa.document.body) {
          return null;
        }
        return t.offsetParent;
      }
      function Tw({
        element: t,
        target: e,
        positions: n,
        limiter: i,
        fitInViewport: o,
        viewportOffsetConfig: r,
      }) {
        if (_e(e)) {
          e = e();
        }
        if (_e(i)) {
          i = i();
        }
        const s = Sw(t);
        const a = new ag(t);
        const c = new ag(e);
        let l;
        const d = (o && Bw(r)) || null;
        const h = {
          targetRect: c,
          elementRect: a,
          positionedElementAncestor: s,
          viewportRect: d,
        };
        if (!i && !o) {
          l = new zw(n[0], h);
        } else {
          const t = i && new ag(i).getVisible();
          Object.assign(h, { limiterRect: t, viewportRect: d });
          l = Pw(n, h) || new zw(n[0], h);
        }
        return l;
      }
      function Bw(t) {
        t = Object.assign(
          { top: 0, bottom: 0, left: 0, right: 0 },
          t
        );
        const e = new ag(Sa.window);
        e.top += t.top;
        e.height -= t.top;
        e.bottom -= t.bottom;
        e.height -= t.bottom;
        return e;
      }
      function Pw(t, e) {
        const { elementRect: n } = e;
        const i = n.getArea();
        const o = t.map((t) => new zw(t, e)).filter((t) => !!t.name);
        let r = 0;
        let s = null;
        for (const t of o) {
          const {
            limiterIntersectionArea: e,
            viewportIntersectionArea: n,
          } = t;
          if (e === i) {
            return t;
          }
          const o = n ** 2 + e ** 2;
          if (o > r) {
            r = o;
            s = t;
          }
        }
        return s;
      }
      function Iw(t, e) {
        const n = Rw(new ag(e));
        const i = rg(e);
        let o = 0;
        let r = 0;
        o -= n.left;
        r -= n.top;
        o += e.scrollLeft;
        r += e.scrollTop;
        o -= i.left;
        r -= i.top;
        t.moveBy(o, r);
      }
      function Rw(t) {
        const { scrollX: e, scrollY: n } = Sa.window;
        return t.clone().moveBy(e, n);
      }
      class zw {
        constructor(t, e) {
          const n = t(e.targetRect, e.elementRect, e.viewportRect);
          if (!n) {
            return;
          }
          const { left: i, top: o, name: r, config: s } = n;
          this.name = r;
          this.config = s;
          this._positioningFunctionCorrdinates = { left: i, top: o };
          this._options = e;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get limiterIntersectionArea() {
          const t = this._options.limiterRect;
          if (t) {
            const e = this._options.viewportRect;
            if (e) {
              const n = t.getIntersection(e);
              if (n) {
                return n.getIntersectionArea(this._rect);
              }
            } else {
              return t.getIntersectionArea(this._rect);
            }
          }
          return 0;
        }
        get viewportIntersectionArea() {
          const t = this._options.viewportRect;
          if (t) {
            return t.getIntersectionArea(this._rect);
          }
          return 0;
        }
        get _rect() {
          if (this._cachedRect) {
            return this._cachedRect;
          }
          this._cachedRect = this._options.elementRect
            .clone()
            .moveTo(
              this._positioningFunctionCorrdinates.left,
              this._positioningFunctionCorrdinates.top
            );
          return this._cachedRect;
        }
        get _absoluteRect() {
          if (this._cachedAbsoluteRect) {
            return this._cachedAbsoluteRect;
          }
          this._cachedAbsoluteRect = Rw(this._rect);
          if (this._options.positionedElementAncestor) {
            Iw(
              this._cachedAbsoluteRect,
              this._options.positionedElementAncestor
            );
          }
          return this._cachedAbsoluteRect;
        }
      }
      function Ow(t) {
        return (e) => e + t;
      }
      var Fw = n(8245);
      var Nw = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Nw.insert = 'head';
      Nw.singleton = true;
      var Mw = Lh()(Fw.Z, Nw);
      const Lw = Fw.Z.locals || {};
      const Vw = Ow('px');
      const Hw = Sa.document.body;
      class jw extends Dw {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('top', 0);
          this.set('left', 0);
          this.set('position', 'arrow_nw');
          this.set('isVisible', false);
          this.set('withArrow', true);
          this.set('class');
          this.content = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-balloon-panel',
                e.to('position', (t) => `ck-balloon-panel_${t}`),
                e.if('isVisible', 'ck-balloon-panel_visible'),
                e.if('withArrow', 'ck-balloon-panel_with-arrow'),
                e.to('class'),
              ],
              style: { top: e.to('top', Vw), left: e.to('left', Vw) },
            },
            children: this.content,
          });
        }
        show() {
          this.isVisible = true;
        }
        hide() {
          this.isVisible = false;
        }
        attachTo(t) {
          this.show();
          const e = jw.defaultPositions;
          const n = Object.assign(
            {},
            {
              element: this.element,
              positions: [
                e.southArrowNorth,
                e.southArrowNorthMiddleWest,
                e.southArrowNorthMiddleEast,
                e.southArrowNorthWest,
                e.southArrowNorthEast,
                e.northArrowSouth,
                e.northArrowSouthMiddleWest,
                e.northArrowSouthMiddleEast,
                e.northArrowSouthWest,
                e.northArrowSouthEast,
                e.viewportStickyNorth,
              ],
              limiter: Hw,
              fitInViewport: true,
            },
            t
          );
          const i = jw._getOptimalPosition(n);
          const o = parseInt(i.left);
          const r = parseInt(i.top);
          const { name: s, config: a = {} } = i;
          const { withArrow: c = true } = a;
          Object.assign(this, {
            top: r,
            left: o,
            position: s,
            withArrow: c,
          });
        }
        pin(t) {
          this.unpin();
          this._pinWhenIsVisibleCallback = () => {
            if (this.isVisible) {
              this._startPinning(t);
            } else {
              this._stopPinning();
            }
          };
          this._startPinning(t);
          this.listenTo(
            this,
            'change:isVisible',
            this._pinWhenIsVisibleCallback
          );
        }
        unpin() {
          if (this._pinWhenIsVisibleCallback) {
            this._stopPinning();
            this.stopListening(
              this,
              'change:isVisible',
              this._pinWhenIsVisibleCallback
            );
            this._pinWhenIsVisibleCallback = null;
            this.hide();
          }
        }
        _startPinning(t) {
          this.attachTo(t);
          const e = qw(t.target);
          const n = t.limiter ? qw(t.limiter) : Hw;
          this.listenTo(
            Sa.document,
            'scroll',
            (i, o) => {
              const r = o.target;
              const s = e && r.contains(e);
              const a = n && r.contains(n);
              if (s || a || !e || !n) {
                this.attachTo(t);
              }
            },
            { useCapture: true }
          );
          this.listenTo(Sa.window, 'resize', () => {
            this.attachTo(t);
          });
        }
        _stopPinning() {
          this.stopListening(Sa.document, 'scroll');
          this.stopListening(Sa.window, 'resize');
        }
      }
      function qw(t) {
        if (wa(t)) {
          return t;
        }
        if (og(t)) {
          return t.commonAncestorContainer;
        }
        if (typeof t == 'function') {
          return qw(t());
        }
        return null;
      }
      jw.arrowSideOffset = 25;
      jw.arrowHeightOffset = 10;
      jw.stickyVerticalOffset = 20;
      jw._getOptimalPosition = Tw;
      jw.defaultPositions = Ww();
      function Ww({
        sideOffset: t = jw.arrowSideOffset,
        heightOffset: e = jw.arrowHeightOffset,
        stickyVerticalOffset: n = jw.stickyVerticalOffset,
        config: i,
      } = {}) {
        return {
          northWestArrowSouthWest: (e, n) => ({
            top: o(e, n),
            left: e.left - t,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northWestArrowSouthMiddleWest: (e, n) => ({
            top: o(e, n),
            left: e.left - n.width * 0.25 - t,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northWestArrowSouth: (t, e) => ({
            top: o(t, e),
            left: t.left - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northWestArrowSouthMiddleEast: (e, n) => ({
            top: o(e, n),
            left: e.left - n.width * 0.75 + t,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northWestArrowSouthEast: (e, n) => ({
            top: o(e, n),
            left: e.left - n.width + t,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          northArrowSouthWest: (e, n) => ({
            top: o(e, n),
            left: e.left + e.width / 2 - t,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northArrowSouthMiddleWest: (e, n) => ({
            top: o(e, n),
            left: e.left + e.width / 2 - n.width * 0.25 - t,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northArrowSouth: (t, e) => ({
            top: o(t, e),
            left: t.left + t.width / 2 - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northArrowSouthMiddleEast: (e, n) => ({
            top: o(e, n),
            left: e.left + e.width / 2 - n.width * 0.75 + t,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northArrowSouthEast: (e, n) => ({
            top: o(e, n),
            left: e.left + e.width / 2 - n.width + t,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          northEastArrowSouthWest: (e, n) => ({
            top: o(e, n),
            left: e.right - t,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northEastArrowSouthMiddleWest: (e, n) => ({
            top: o(e, n),
            left: e.right - n.width * 0.25 - t,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northEastArrowSouth: (t, e) => ({
            top: o(t, e),
            left: t.right - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northEastArrowSouthMiddleEast: (e, n) => ({
            top: o(e, n),
            left: e.right - n.width * 0.75 + t,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northEastArrowSouthEast: (e, n) => ({
            top: o(e, n),
            left: e.right - n.width + t,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          southWestArrowNorthWest: (e, n) => ({
            top: r(e, n),
            left: e.left - t,
            name: 'arrow_nw',
            ...(i && { config: i }),
          }),
          southWestArrowNorthMiddleWest: (e, n) => ({
            top: r(e, n),
            left: e.left - n.width * 0.25 - t,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southWestArrowNorth: (t, e) => ({
            top: r(t, e),
            left: t.left - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southWestArrowNorthMiddleEast: (e, n) => ({
            top: r(e, n),
            left: e.left - n.width * 0.75 + t,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southWestArrowNorthEast: (e, n) => ({
            top: r(e, n),
            left: e.left - n.width + t,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          southArrowNorthWest: (e, n) => ({
            top: r(e, n),
            left: e.left + e.width / 2 - t,
            name: 'arrow_nw',
            ...(i && { config: i }),
          }),
          southArrowNorthMiddleWest: (e, n) => ({
            top: r(e, n),
            left: e.left + e.width / 2 - n.width * 0.25 - t,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southArrowNorth: (t, e) => ({
            top: r(t, e),
            left: t.left + t.width / 2 - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southArrowNorthMiddleEast: (e, n) => ({
            top: r(e, n),
            left: e.left + e.width / 2 - n.width * 0.75 + t,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southArrowNorthEast: (e, n) => ({
            top: r(e, n),
            left: e.left + e.width / 2 - n.width + t,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          southEastArrowNorthWest: (e, n) => ({
            top: r(e, n),
            left: e.right - t,
            name: 'arrow_nw',
            ...(i && { config: i }),
          }),
          southEastArrowNorthMiddleWest: (e, n) => ({
            top: r(e, n),
            left: e.right - n.width * 0.25 - t,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southEastArrowNorth: (t, e) => ({
            top: r(t, e),
            left: t.right - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southEastArrowNorthMiddleEast: (e, n) => ({
            top: r(e, n),
            left: e.right - n.width * 0.75 + t,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southEastArrowNorthEast: (e, n) => ({
            top: r(e, n),
            left: e.right - n.width + t,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          westArrowEast: (t, n) => ({
            top: t.top + t.height / 2 - n.height / 2,
            left: t.left - n.width - e,
            name: 'arrow_e',
            ...(i && { config: i }),
          }),
          eastArrowWest: (t, n) => ({
            top: t.top + t.height / 2 - n.height / 2,
            left: t.right + e,
            name: 'arrow_w',
            ...(i && { config: i }),
          }),
          viewportStickyNorth: (t, e, o) => {
            if (!t.getIntersection(o)) {
              return null;
            }
            return {
              top: o.top + n,
              left: t.left + t.width / 2 - e.width / 2,
              name: 'arrowless',
              config: { withArrow: false, ...i },
            };
          },
        };
        function o(t, n) {
          return t.top - n.height - e;
        }
        function r(t) {
          return t.bottom + e;
        }
      }
      var Uw = n(9948);
      var Gw = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Gw.insert = 'head';
      Gw.singleton = true;
      var $w = Lh()(Uw.Z, Gw);
      const Kw = Uw.Z.locals || {};
      const Zw = 'ck-tooltip';
      class Jw {
        constructor(t) {
          Jw._editors.add(t);
          if (Jw._instance) {
            return Jw._instance;
          }
          Jw._instance = this;
          this.tooltipTextView = new Dw(t.locale);
          this.tooltipTextView.set('text', '');
          this.tooltipTextView.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-tooltip__text'] },
            children: [
              { text: this.tooltipTextView.bindTemplate.to('text') },
            ],
          });
          this.balloonPanelView = new jw(t.locale);
          this.balloonPanelView.class = Zw;
          this.balloonPanelView.content.add(this.tooltipTextView);
          this._currentElementWithTooltip = null;
          this._currentTooltipPosition = null;
          this._pinTooltipDebounced = qf(this._pinTooltip, 600);
          this.listenTo(
            Sa.document,
            'mouseenter',
            this._onEnterOrFocus.bind(this),
            { useCapture: true }
          );
          this.listenTo(
            Sa.document,
            'mouseleave',
            this._onLeaveOrBlur.bind(this),
            { useCapture: true }
          );
          this.listenTo(
            Sa.document,
            'focus',
            this._onEnterOrFocus.bind(this),
            { useCapture: true }
          );
          this.listenTo(
            Sa.document,
            'blur',
            this._onLeaveOrBlur.bind(this),
            { useCapture: true }
          );
          this.listenTo(
            Sa.document,
            'scroll',
            this._onScroll.bind(this),
            { useCapture: true }
          );
          this._watchdogExcluded = true;
        }
        destroy(t) {
          Jw._editors.delete(t);
          this.stopListening(t.ui);
          if (!Jw._editors.size) {
            this._unpinTooltip();
            this.balloonPanelView.destroy();
            this.stopListening();
            Jw._instance = null;
          }
        }
        _onEnterOrFocus(t, { target: e }) {
          const n = Yw(e);
          if (!n) {
            return;
          }
          if (n === this._currentElementWithTooltip) {
            return;
          }
          this._unpinTooltip();
          this._pinTooltipDebounced(n, Qw(n));
        }
        _onLeaveOrBlur(t, { target: e, relatedTarget: n }) {
          if (t.name === 'mouseleave') {
            if (!wa(e)) {
              return;
            }
            if (
              this._currentElementWithTooltip &&
              e !== this._currentElementWithTooltip
            ) {
              return;
            }
            const t = Yw(e);
            const i = Yw(n);
            if (t && t !== i) {
              this._unpinTooltip();
            }
          } else {
            if (
              this._currentElementWithTooltip &&
              e !== this._currentElementWithTooltip
            ) {
              return;
            }
            this._unpinTooltip();
          }
        }
        _onScroll(t, { target: e }) {
          if (!this._currentElementWithTooltip) {
            return;
          }
          if (
            e.contains(this.balloonPanelView.element) &&
            e.contains(this._currentElementWithTooltip)
          ) {
            return;
          }
          this._unpinTooltip();
        }
        _pinTooltip(t, { text: e, position: n, cssClass: i }) {
          const o = Xf(Jw._editors.values()).ui.view.body;
          if (!o.has(this.balloonPanelView)) {
            o.add(this.balloonPanelView);
          }
          this.tooltipTextView.text = e;
          this.balloonPanelView.pin({
            target: t,
            positions: Jw.getPositioningFunctions(n),
          });
          this.balloonPanelView.class = [Zw, i]
            .filter((t) => t)
            .join(' ');
          for (const t of Jw._editors) {
            this.listenTo(
              t.ui,
              'update',
              this._updateTooltipPosition.bind(this),
              { priority: 'low' }
            );
          }
          this._currentElementWithTooltip = t;
          this._currentTooltipPosition = n;
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel();
          this.balloonPanelView.unpin();
          for (const t of Jw._editors) {
            this.stopListening(t.ui, 'update');
          }
          this._currentElementWithTooltip = null;
          this._currentTooltipPosition = null;
        }
        _updateTooltipPosition() {
          if (!Qf(this._currentElementWithTooltip)) {
            this._unpinTooltip();
            return;
          }
          this.balloonPanelView.pin({
            target: this._currentElementWithTooltip,
            positions: Jw.getPositioningFunctions(
              this._currentTooltipPosition
            ),
          });
        }
        static getPositioningFunctions(t) {
          const e = Jw.defaultBalloonPositions;
          return {
            s: [
              e.southArrowNorth,
              e.southArrowNorthEast,
              e.southArrowNorthWest,
            ],
            n: [e.northArrowSouth],
            e: [e.eastArrowWest],
            w: [e.westArrowEast],
            sw: [e.southArrowNorthEast],
            se: [e.southArrowNorthWest],
          }[t];
        }
      }
      et(Jw, uu);
      Jw.defaultBalloonPositions = Ww({
        heightOffset: 5,
        sideOffset: 13,
      });
      Jw._instance = null;
      Jw._editors = new Set();
      function Yw(t) {
        if (!wa(t)) {
          return null;
        }
        return t.closest(
          '[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])'
        );
      }
      function Qw(t) {
        return {
          text: t.dataset.ckeTooltipText,
          position: t.dataset.ckeTooltipPosition || 's',
          cssClass: t.dataset.ckeTooltipClass || '',
        };
      }
      class Xw {
        constructor(t) {
          this.editor = t;
          this.componentFactory = new Gb(t);
          this.focusTracker = new tg();
          this.tooltipManager = new Jw(t);
          this.set(
            'viewportOffset',
            this._readViewportOffsetFromConfig()
          );
          this.isReady = false;
          this.once('ready', () => {
            this.isReady = true;
          });
          this._editableElementsMap = new Map();
          this._focusableToolbarDefinitions = [];
          this.listenTo(
            t.editing.view.document,
            'layoutChanged',
            () => this.update()
          );
          this._initFocusTracking();
        }
        get element() {
          return null;
        }
        update() {
          this.fire('update');
        }
        destroy() {
          this.stopListening();
          this.focusTracker.destroy();
          this.tooltipManager.destroy(this.editor);
          for (const t of this._editableElementsMap.values()) {
            t.ckeditorInstance = null;
          }
          this._editableElementsMap = new Map();
          this._focusableToolbarDefinitions = [];
        }
        setEditableElement(t, e) {
          this._editableElementsMap.set(t, e);
          if (!e.ckeditorInstance) {
            e.ckeditorInstance = this.editor;
          }
          this.focusTracker.add(e);
          const n = () => {
            if (this.editor.editing.view.getDomRoot(t)) {
              return;
            }
            this.editor.keystrokes.listenTo(e);
          };
          if (this.isReady) {
            n();
          } else {
            this.once('ready', n);
          }
        }
        getEditableElement(t = 'main') {
          return this._editableElementsMap.get(t);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        addToolbar(t, e = {}) {
          if (t.isRendered) {
            this.focusTracker.add(t.element);
            this.editor.keystrokes.listenTo(t.element);
          } else {
            t.once('render', () => {
              this.focusTracker.add(t.element);
              this.editor.keystrokes.listenTo(t.element);
            });
          }
          this._focusableToolbarDefinitions.push({
            toolbarView: t,
            options: e,
          });
        }
        get _editableElements() {
          console.warn(
            'editor-ui-deprecated-editable-elements: ' +
              'The EditorUI#_editableElements property has been deprecated and will be removed in the near future.',
            { editorUI: this }
          );
          return this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const t = this.editor;
          const e = t.config.get('ui.viewportOffset');
          if (e) {
            return e;
          }
          const n = t.config.get('toolbar.viewportTopOffset');
          if (n) {
            console.warn(
              'editor-ui-deprecated-viewport-offset-config: ' +
                'The `toolbar.vieportTopOffset` configuration option is deprecated. ' +
                'It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.'
            );
            return { top: n };
          }
          return { top: 0 };
        }
        _initFocusTracking() {
          const t = this.editor;
          const e = t.editing.view;
          let n;
          let i;
          t.keystrokes.set('Alt+F10', (t, o) => {
            const r = this.focusTracker.focusedElement;
            if (
              Array.from(this._editableElementsMap.values()).includes(
                r
              ) &&
              !Array.from(e.domRoots.values()).includes(r)
            ) {
              n = r;
            }
            const s = this._getCurrentFocusedToolbarDefinition();
            if (!s || !i) {
              i = this._getFocusableCandidateToolbarDefinitions(s);
            }
            for (let t = 0; t < i.length; t++) {
              const t = i.shift();
              i.push(t);
              if (
                t !== s &&
                this._focusFocusableCandidateToolbar(t)
              ) {
                if (s && s.options.afterBlur) {
                  s.options.afterBlur();
                }
                break;
              }
            }
            o();
          });
          t.keystrokes.set('Esc', (e, i) => {
            const o = this._getCurrentFocusedToolbarDefinition();
            if (!o) {
              return;
            }
            if (n) {
              n.focus();
              n = null;
            } else {
              t.editing.view.focus();
            }
            if (o.options.afterBlur) {
              o.options.afterBlur();
            }
            i();
          });
        }
        _getFocusableCandidateToolbarDefinitions() {
          const t = [];
          for (const e of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: i } = e;
            if (Qf(n.element) || i.beforeFocus) {
              t.push(e);
            }
          }
          t.sort((t, e) => t_(t) - t_(e));
          return t;
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const t of this._focusableToolbarDefinitions) {
            if (
              t.toolbarView.element &&
              t.toolbarView.element.contains(
                this.focusTracker.focusedElement
              )
            ) {
              return t;
            }
          }
          return null;
        }
        _focusFocusableCandidateToolbar(t) {
          const {
            toolbarView: e,
            options: { beforeFocus: n },
          } = t;
          if (n) {
            n();
          }
          if (!Qf(e.element)) {
            return false;
          }
          e.focus();
          return true;
        }
      }
      et(Xw, q);
      function t_(t) {
        const { toolbarView: e, options: n } = t;
        let i = 10;
        if (Qf(e.element)) {
          i--;
        }
        if (n.isContextual) {
          i--;
        }
        return i;
      }
      function e_(t) {
        if (!_e(t.updateSourceElement)) {
          throw new h('attachtoform-missing-elementapi-interface', t);
        }
        const e = t.sourceElement;
        if (e && e.tagName.toLowerCase() === 'textarea' && e.form) {
          let n;
          const i = e.form;
          const o = () => t.updateSourceElement();
          if (_e(i.submit)) {
            n = i.submit;
            i.submit = () => {
              o();
              n.apply(i);
            };
          }
          i.addEventListener('submit', o);
          t.on('destroy', () => {
            i.removeEventListener('submit', o);
            if (n) {
              i.submit = n;
            }
          });
        }
      }
      const n_ = {
        setData(t) {
          this.data.set(t);
        },
        getData(t) {
          return this.data.get(t);
        },
      };
      const i_ = n_;
      function o_(t, e) {
        if (t instanceof HTMLTextAreaElement) {
          t.value = e;
        }
        t.innerHTML = e;
      }
      const r_ = {
        updateSourceElement(t = this.data.get()) {
          if (!this.sourceElement) {
            throw new h('editor-missing-sourceelement', this);
          }
          const e = this.config.get('updateSourceElementOnDestroy');
          const n = this.sourceElement instanceof HTMLTextAreaElement;
          if (!e && !n) {
            o_(this.sourceElement, '');
            return;
          }
          o_(this.sourceElement, t);
        },
      };
      const s_ = r_;
      function a_(t) {
        const e = t.sourceElement;
        if (!e) {
          return;
        }
        if (e.ckeditorInstance) {
          throw new CKEditorError(
            'editor-source-element-already-used',
            t
          );
        }
        e.ckeditorInstance = t;
        t.once('destroy', () => {
          delete e.ckeditorInstance;
        });
      }
      class c_ extends La {
        static get pluginName() {
          return 'PendingActions';
        }
        init() {
          this.set('hasAny', false);
          this._actions = new ya({ idProperty: '_id' });
          this._actions.delegate('add', 'remove').to(this);
        }
        add(t) {
          if (typeof t !== 'string') {
            throw new h('pendingactions-add-invalid-message', this);
          }
          const e = Object.create(q);
          e.set('message', t);
          this._actions.add(e);
          this.hasAny = true;
          return e;
        }
        remove(t) {
          this._actions.remove(t);
          this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      const l_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
      const d_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>';
      const h_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
      const u_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>';
      const f_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
      const g_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
      const m_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';
      const p_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
      const k_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
      const b_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
      const w_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
      const __ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
      const v_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
      const A_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
      const C_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const y_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>';
      const x_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
      const E_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>';
      const D_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const S_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const T_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
      const B_ =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';
      const P_ =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>';
      const I_ =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>';
      const R_ =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>';
      const z_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>';
      const O_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';
      const F_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
      const N_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
      const M_ = {
        cancel: l_,
        caption: d_,
        check: h_,
        cog: u_,
        eraser: f_,
        lowVision: g_,
        image: m_,
        alignBottom: p_,
        alignMiddle: k_,
        alignTop: b_,
        alignLeft: w_,
        alignCenter: __,
        alignRight: v_,
        alignJustify: A_,
        objectLeft: S_,
        objectCenter: y_,
        objectRight: T_,
        objectFullWidth: E_,
        objectInline: D_,
        objectBlockLeft: C_,
        objectBlockRight: x_,
        objectSizeFull: B_,
        objectSizeLarge: P_,
        objectSizeSmall: I_,
        objectSizeMedium: R_,
        pencil: z_,
        pilcrow: O_,
        quote: F_,
        threeVerticalDots: N_,
      };
      function L_({
        emitter: t,
        activator: e,
        callback: n,
        contextElements: i,
      }) {
        t.listenTo(document, 'mousedown', (t, o) => {
          if (!e()) {
            return;
          }
          const r =
            typeof o.composedPath == 'function'
              ? o.composedPath()
              : [];
          for (const t of i) {
            if (t.contains(o.target) || r.includes(t)) {
              return;
            }
          }
          n();
        });
      }
      function V_(t) {
        t.set('_isCssTransitionsDisabled', false);
        t.disableCssTransitions = () => {
          t._isCssTransitionsDisabled = true;
        };
        t.enableCssTransitions = () => {
          t._isCssTransitionsDisabled = false;
        };
        t.extendTemplate({
          attributes: {
            class: [
              t.bindTemplate.if(
                '_isCssTransitionsDisabled',
                'ck-transitions-disabled'
              ),
            ],
          },
        });
      }
      function H_({ view: t }) {
        t.listenTo(
          t.element,
          'submit',
          (e, n) => {
            n.preventDefault();
            t.fire('submit');
          },
          { useCapture: true }
        );
      }
      function j_({
        keystrokeHandler: t,
        focusTracker: e,
        gridItems: n,
        numberOfColumns: i,
      }) {
        const o = typeof i === 'number' ? () => i : i;
        t.set(
          'arrowright',
          r((t, e) => {
            if (t === e.length - 1) {
              return 0;
            } else {
              return t + 1;
            }
          })
        );
        t.set(
          'arrowleft',
          r((t, e) => {
            if (t === 0) {
              return e.length - 1;
            } else {
              return t - 1;
            }
          })
        );
        t.set(
          'arrowup',
          r((t, e) => {
            let n = t - o();
            if (n < 0) {
              n = t + o() * Math.floor(e.length / o());
              if (n > e.length - 1) {
                n -= o();
              }
            }
            return n;
          })
        );
        t.set(
          'arrowdown',
          r((t, e) => {
            let n = t + o();
            if (n > e.length - 1) {
              n = t % o();
            }
            return n;
          })
        );
        function r(t) {
          return (i) => {
            const o = n.find((t) => t.element === e.focusedElement);
            const r = n.getIndex(o);
            const s = t(r, n);
            n.get(s).focus();
            i.stopPropagation();
            i.preventDefault();
          };
        }
      }
      var q_ = '[object String]';
      function W_(t) {
        return (
          typeof t == 'string' || (!ni(t) && zt(t) && St(t) == q_)
        );
      }
      const U_ = W_;
      function G_(t, e, n = {}, i = []) {
        const o = n && n.xmlns;
        const r = o ? t.createElementNS(o, e) : t.createElement(e);
        for (const t in n) {
          r.setAttribute(t, n[t]);
        }
        if (U_(i) || !Ca(i)) {
          i = [i];
        }
        for (let e of i) {
          if (U_(e)) {
            e = t.createTextNode(e);
          }
          r.appendChild(e);
        }
        return r;
      }
      class $_ extends Kb {
        constructor(t, e = []) {
          super(e);
          this.locale = t;
        }
        attachToDom() {
          this._bodyCollectionContainer = new Yb({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-reset_all',
                'ck-body',
                'ck-rounded-corners',
              ],
              dir: this.locale.uiLanguageDirection,
            },
            children: this,
          }).render();
          let t = document.querySelector('.ck-body-wrapper');
          if (!t) {
            t = G_(document, 'div', { class: 'ck-body-wrapper' });
            document.body.appendChild(t);
          }
          t.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy();
          if (this._bodyCollectionContainer) {
            this._bodyCollectionContainer.remove();
          }
          const t = document.querySelector('.ck-body-wrapper');
          if (t && t.childElementCount == 0) {
            t.remove();
          }
        }
      }
      var K_ = n(1174);
      var Z_ = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Z_.insert = 'head';
      Z_.singleton = true;
      var J_ = Lh()(K_.Z, Z_);
      const Y_ = K_.Z.locals || {};
      class Q_ extends Dw {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set('content', '');
          this.set('viewBox', '0 0 20 20');
          this.set('fillColor', '');
          this.setTemplate({
            tag: 'svg',
            ns: 'http://www.w3.org/2000/svg',
            attributes: {
              class: ['ck', 'ck-icon'],
              viewBox: t.to('viewBox'),
            },
          });
        }
        render() {
          super.render();
          this._updateXMLContent();
          this._colorFillPaths();
          this.on('change:content', () => {
            this._updateXMLContent();
            this._colorFillPaths();
          });
          this.on('change:fillColor', () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const t = new DOMParser().parseFromString(
              this.content.trim(),
              'image/svg+xml'
            );
            const e = t.querySelector('svg');
            const n = e.getAttribute('viewBox');
            if (n) {
              this.viewBox = n;
            }
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild);
            }
            while (e.childNodes.length > 0) {
              this.element.appendChild(e.childNodes[0]);
            }
          }
        }
        _colorFillPaths() {
          if (this.fillColor) {
            this.element
              .querySelectorAll('.ck-icon__fill')
              .forEach((t) => {
                t.style.fill = this.fillColor;
              });
          }
        }
      }
      var X_ = n(4499);
      var tv = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      tv.insert = 'head';
      tv.singleton = true;
      var ev = Lh()(X_.Z, tv);
      const nv = X_.Z.locals || {};
      class iv extends Dw {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          const n = s();
          this.set('class');
          this.set('labelStyle');
          this.set('icon');
          this.set('isEnabled', true);
          this.set('isOn', false);
          this.set('isVisible', true);
          this.set('isToggleable', false);
          this.set('keystroke');
          this.set('label');
          this.set('tabindex', -1);
          this.set('tooltip');
          this.set('tooltipPosition', 's');
          this.set('type', 'button');
          this.set('withText', false);
          this.set('withKeystroke', false);
          this.children = this.createCollection();
          this.labelView = this._createLabelView(n);
          this.iconView = new Q_();
          this.iconView.extendTemplate({
            attributes: { class: 'ck-button__icon' },
          });
          this.keystrokeView = this._createKeystrokeView();
          this.bind('_tooltipString').to(
            this,
            'tooltip',
            this,
            'label',
            this,
            'keystroke',
            this._getTooltipString.bind(this)
          );
          const i = {
            tag: 'button',
            attributes: {
              class: [
                'ck',
                'ck-button',
                e.to('class'),
                e.if('isEnabled', 'ck-disabled', (t) => !t),
                e.if('isVisible', 'ck-hidden', (t) => !t),
                e.to('isOn', (t) => (t ? 'ck-on' : 'ck-off')),
                e.if('withText', 'ck-button_with-text'),
                e.if('withKeystroke', 'ck-button_with-keystroke'),
              ],
              type: e.to('type', (t) => (t ? t : 'button')),
              tabindex: e.to('tabindex'),
              'aria-labelledby': `ck-editor__aria-label_${n}`,
              'aria-disabled': e.if('isEnabled', true, (t) => !t),
              'aria-pressed': e.to('isOn', (t) =>
                this.isToggleable ? String(!!t) : false
              ),
              'data-cke-tooltip-text': e.to('_tooltipString'),
              'data-cke-tooltip-position': e.to('tooltipPosition'),
            },
            children: this.children,
            on: {
              click: e.to((t) => {
                if (this.isEnabled) {
                  this.fire('execute');
                } else {
                  t.preventDefault();
                }
              }),
            },
          };
          if (Sd.isSafari) {
            i.on.mousedown = e.to((t) => {
              this.focus();
              t.preventDefault();
            });
          }
          this.setTemplate(i);
        }
        render() {
          super.render();
          if (this.icon) {
            this.iconView.bind('content').to(this, 'icon');
            this.children.add(this.iconView);
          }
          this.children.add(this.labelView);
          if (this.withKeystroke && this.keystroke) {
            this.children.add(this.keystrokeView);
          }
        }
        focus() {
          this.element.focus();
        }
        _createLabelView(t) {
          const e = new Dw();
          const n = this.bindTemplate;
          e.setTemplate({
            tag: 'span',
            attributes: {
              class: ['ck', 'ck-button__label'],
              style: n.to('labelStyle'),
              id: `ck-editor__aria-label_${t}`,
            },
            children: [{ text: this.bindTemplate.to('label') }],
          });
          return e;
        }
        _createKeystrokeView() {
          const t = new Dw();
          t.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-button__keystroke'] },
            children: [
              {
                text: this.bindTemplate.to('keystroke', (t) => qd(t)),
              },
            ],
          });
          return t;
        }
        _getTooltipString(t, e, n) {
          if (t) {
            if (typeof t == 'string') {
              return t;
            } else {
              if (n) {
                n = qd(n);
              }
              if (t instanceof Function) {
                return t(e, n);
              } else {
                return `${e}${n ? ` (${n})` : ''}`;
              }
            }
          }
          return '';
        }
      }
      var ov = n(9681);
      var rv = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      rv.insert = 'head';
      rv.singleton = true;
      var sv = Lh()(ov.Z, rv);
      const av = ov.Z.locals || {};
      class cv extends iv {
        constructor(t) {
          super(t);
          this.isToggleable = true;
          this.toggleSwitchView = this._createToggleView();
          this.extendTemplate({
            attributes: { class: 'ck-switchbutton' },
          });
        }
        render() {
          super.render();
          this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const t = new Dw();
          t.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-button__toggle'] },
            children: [
              {
                tag: 'span',
                attributes: {
                  class: ['ck', 'ck-button__toggle__inner'],
                },
              },
            ],
          });
          return t;
        }
      }
      function lv(t, e) {
        const n = t.t;
        const i = {
          Black: n('Black'),
          'Dim grey': n('Dim grey'),
          Grey: n('Grey'),
          'Light grey': n('Light grey'),
          White: n('White'),
          Red: n('Red'),
          Orange: n('Orange'),
          Yellow: n('Yellow'),
          'Light green': n('Light green'),
          Green: n('Green'),
          Aquamarine: n('Aquamarine'),
          Turquoise: n('Turquoise'),
          'Light blue': n('Light blue'),
          Blue: n('Blue'),
          Purple: n('Purple'),
        };
        return e.map((t) => {
          const e = i[t.label];
          if (e && e != t.label) {
            t.label = e;
          }
          return t;
        });
      }
      function dv(t) {
        return t.map(hv).filter((t) => !!t);
      }
      function hv(t) {
        if (typeof t === 'string') {
          return {
            model: t,
            label: t,
            hasBorder: false,
            view: { name: 'span', styles: { color: t } },
          };
        } else {
          return {
            model: t.color,
            label: t.label || t.color,
            hasBorder:
              t.hasBorder === undefined ? false : t.hasBorder,
            view: { name: 'span', styles: { color: `${t.color}` } },
          };
        }
      }
      const uv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
      class fv extends iv {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('color');
          this.set('hasBorder');
          this.icon = uv;
          this.extendTemplate({
            attributes: {
              style: { backgroundColor: e.to('color') },
              class: [
                'ck',
                'ck-color-grid__tile',
                e.if(
                  'hasBorder',
                  'ck-color-table__color-tile_bordered'
                ),
              ],
            },
          });
        }
        render() {
          super.render();
          this.iconView.fillColor = 'hsl(0, 0%, 100%)';
        }
      }
      var gv = n(4923);
      var mv = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      mv.insert = 'head';
      mv.singleton = true;
      var pv = Lh()(gv.Z, mv);
      const kv = gv.Z.locals || {};
      class bv extends Dw {
        constructor(t, e) {
          super(t);
          const n = (e && e.colorDefinitions) || [];
          const i = {};
          this.columns = e && e.columns ? e.columns : 5;
          i.gridTemplateColumns = `repeat( ${this.columns}, 1fr)`;
          this.set('selectedColor');
          this.items = this.createCollection();
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this.items.on('add', (t, e) => {
            e.isOn = e.color === this.selectedColor;
          });
          n.forEach((t) => {
            const e = new fv();
            e.set({
              color: t.color,
              label: t.label,
              tooltip: true,
              hasBorder: t.options.hasBorder,
            });
            e.on('execute', () => {
              this.fire('execute', {
                value: t.color,
                hasBorder: t.options.hasBorder,
                label: t.label,
              });
            });
            this.items.add(e);
          });
          this.setTemplate({
            tag: 'div',
            children: this.items,
            attributes: { class: ['ck', 'ck-color-grid'], style: i },
          });
          this.on('change:selectedColor', (t, e, n) => {
            for (const t of this.items) {
              t.isOn = t.color === n;
            }
          });
        }
        focus() {
          if (this.items.length) {
            this.items.first.focus();
          }
        }
        focusLast() {
          if (this.items.length) {
            this.items.last.focus();
          }
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on('add', (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on('remove', (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          j_({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: this.columns,
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
      }
      const wv =
        '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class _v extends iv {
        constructor(t) {
          super(t);
          this.arrowView = this._createArrowView();
          this.extendTemplate({
            attributes: {
              'aria-haspopup': true,
              'aria-expanded': this.bindTemplate.to('isOn', (t) =>
                String(t)
              ),
            },
          });
          this.delegate('execute').to(this, 'open');
        }
        render() {
          super.render();
          this.children.add(this.arrowView);
        }
        _createArrowView() {
          const t = new Q_();
          t.content = wv;
          t.extendTemplate({
            attributes: { class: 'ck-dropdown__arrow' },
          });
          return t;
        }
      }
      var vv = n(66);
      var Av = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Av.insert = 'head';
      Av.singleton = true;
      var Cv = Lh()(vv.Z, Av);
      const yv = vv.Z.locals || {};
      class xv extends Dw {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('class');
          this.set('icon');
          this.set('isEnabled', true);
          this.set('isOn', false);
          this.set('isToggleable', false);
          this.set('isVisible', true);
          this.set('keystroke');
          this.set('label');
          this.set('tabindex', -1);
          this.set('tooltip');
          this.set('tooltipPosition', 's');
          this.set('type', 'button');
          this.set('withText', false);
          this.children = this.createCollection();
          this.actionView = this._createActionView();
          this.arrowView = this._createArrowView();
          this.keystrokes = new eg();
          this.focusTracker = new tg();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-splitbutton',
                e.to('class'),
                e.if('isVisible', 'ck-hidden', (t) => !t),
                this.arrowView.bindTemplate.if(
                  'isOn',
                  'ck-splitbutton_open'
                ),
              ],
            },
            children: this.children,
          });
        }
        render() {
          super.render();
          this.children.add(this.actionView);
          this.children.add(this.arrowView);
          this.focusTracker.add(this.actionView.element);
          this.focusTracker.add(this.arrowView.element);
          this.keystrokes.listenTo(this.element);
          this.keystrokes.set('arrowright', (t, e) => {
            if (
              this.focusTracker.focusedElement ===
              this.actionView.element
            ) {
              this.arrowView.focus();
              e();
            }
          });
          this.keystrokes.set('arrowleft', (t, e) => {
            if (
              this.focusTracker.focusedElement ===
              this.arrowView.element
            ) {
              this.actionView.focus();
              e();
            }
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const t = new iv();
          t.bind(
            'icon',
            'isEnabled',
            'isOn',
            'isToggleable',
            'keystroke',
            'label',
            'tabindex',
            'tooltip',
            'tooltipPosition',
            'type',
            'withText'
          ).to(this);
          t.extendTemplate({
            attributes: { class: 'ck-splitbutton__action' },
          });
          t.delegate('execute').to(this);
          return t;
        }
        _createArrowView() {
          const t = new iv();
          const e = t.bindTemplate;
          t.icon = wv;
          t.extendTemplate({
            attributes: {
              class: ['ck-splitbutton__arrow'],
              'data-cke-tooltip-disabled': e.to('isOn'),
              'aria-haspopup': true,
              'aria-expanded': e.to('isOn', (t) => String(t)),
            },
          });
          t.bind('isEnabled').to(this);
          t.bind('label').to(this);
          t.bind('tooltip').to(this);
          t.delegate('execute').to(this, 'open');
          return t;
        }
      }
      class Ev extends Dw {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('isVisible', false);
          this.set('position', 'se');
          this.children = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-reset',
                'ck-dropdown__panel',
                e.to('position', (t) => `ck-dropdown__panel_${t}`),
                e.if('isVisible', 'ck-dropdown__panel-visible'),
              ],
            },
            children: this.children,
            on: { selectstart: e.to((t) => t.preventDefault()) },
          });
        }
        focus() {
          if (this.children.length) {
            if (typeof this.children.first.focus === 'function') {
              this.children.first.focus();
            } else {
              u('ui-dropdown-panel-focus-child-missing-focus', {
                childView: this.children.first,
                dropdownPanel: this,
              });
            }
          }
        }
        focusLast() {
          if (this.children.length) {
            const t = this.children.last;
            if (typeof t.focusLast === 'function') {
              t.focusLast();
            } else {
              t.focus();
            }
          }
        }
      }
      var Dv = n(3488);
      var Sv = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Sv.insert = 'head';
      Sv.singleton = true;
      var Tv = Lh()(Dv.Z, Sv);
      const Bv = Dv.Z.locals || {};
      class Pv extends Dw {
        constructor(t, e, n) {
          super(t);
          const i = this.bindTemplate;
          this.buttonView = e;
          this.panelView = n;
          this.set('isOpen', false);
          this.set('isEnabled', true);
          this.set('class');
          this.set('id');
          this.set('panelPosition', 'auto');
          this.keystrokes = new eg();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-dropdown',
                i.to('class'),
                i.if('isEnabled', 'ck-disabled', (t) => !t),
              ],
              id: i.to('id'),
              'aria-describedby': i.to('ariaDescribedById'),
            },
            children: [e, n],
          });
          e.extendTemplate({
            attributes: {
              class: ['ck-dropdown__button'],
              'data-cke-tooltip-disabled': i.to('isOpen'),
            },
          });
        }
        render() {
          super.render();
          this.listenTo(this.buttonView, 'open', () => {
            this.isOpen = !this.isOpen;
          });
          this.panelView.bind('isVisible').to(this, 'isOpen');
          this.on('change:isOpen', () => {
            if (!this.isOpen) {
              this.focus();
              return;
            }
            if (this.panelPosition === 'auto') {
              this.panelView.position = Pv._getOptimalPosition({
                element: this.panelView.element,
                target: this.buttonView.element,
                fitInViewport: true,
                positions: this._panelPositions,
              }).name;
            } else {
              this.panelView.position = this.panelPosition;
            }
            this.panelView.focus();
          });
          this.keystrokes.listenTo(this.element);
          const t = (t, e) => {
            if (this.isOpen) {
              this.isOpen = false;
              e();
            }
          };
          this.keystrokes.set('arrowdown', (t, e) => {
            if (this.buttonView.isEnabled && !this.isOpen) {
              this.isOpen = true;
              e();
            }
          });
          this.keystrokes.set('arrowright', (t, e) => {
            if (this.isOpen) {
              e();
            }
          });
          this.keystrokes.set('arrowleft', t);
          this.keystrokes.set('esc', t);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const {
            south: t,
            north: e,
            southEast: n,
            southWest: i,
            northEast: o,
            northWest: r,
            southMiddleEast: s,
            southMiddleWest: a,
            northMiddleEast: c,
            northMiddleWest: l,
          } = Pv.defaultPanelPositions;
          if (this.locale.uiLanguageDirection !== 'rtl') {
            return [n, i, s, a, t, o, r, c, l, e];
          } else {
            return [i, n, a, s, t, r, o, l, c, e];
          }
        }
      }
      Pv.defaultPanelPositions = {
        south: (t, e) => ({
          top: t.bottom,
          left: t.left - (e.width - t.width) / 2,
          name: 's',
        }),
        southEast: (t) => ({
          top: t.bottom,
          left: t.left,
          name: 'se',
        }),
        southWest: (t, e) => ({
          top: t.bottom,
          left: t.left - e.width + t.width,
          name: 'sw',
        }),
        southMiddleEast: (t, e) => ({
          top: t.bottom,
          left: t.left - (e.width - t.width) / 4,
          name: 'sme',
        }),
        southMiddleWest: (t, e) => ({
          top: t.bottom,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: 'smw',
        }),
        north: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 2,
          name: 'n',
        }),
        northEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left,
          name: 'ne',
        }),
        northWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - e.width + t.width,
          name: 'nw',
        }),
        northMiddleEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 4,
          name: 'nme',
        }),
        northMiddleWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: 'nmw',
        }),
      };
      Pv._getOptimalPosition = Tw;
      class Iv {
        constructor(t) {
          Object.assign(this, t);
          if (t.actions && t.keystrokeHandler) {
            for (const e in t.actions) {
              let n = t.actions[e];
              if (typeof n == 'string') {
                n = [n];
              }
              for (const i of n) {
                t.keystrokeHandler.set(i, (t, n) => {
                  this[e]();
                  n();
                });
              }
            }
          }
        }
        get first() {
          return this.focusables.find(Rv) || null;
        }
        get last() {
          return this.focusables.filter(Rv).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let t = null;
          if (this.focusTracker.focusedElement === null) {
            return null;
          }
          this.focusables.find((e, n) => {
            const i = e.element === this.focusTracker.focusedElement;
            if (i) {
              t = n;
            }
            return i;
          });
          return t;
        }
        focusFirst() {
          this._focus(this.first);
        }
        focusLast() {
          this._focus(this.last);
        }
        focusNext() {
          this._focus(this.next);
        }
        focusPrevious() {
          this._focus(this.previous);
        }
        _focus(t) {
          if (t) {
            t.focus();
          }
        }
        _getFocusableItem(t) {
          const e = this.current;
          const n = this.focusables.length;
          if (!n) {
            return null;
          }
          if (e === null) {
            return this[t === 1 ? 'first' : 'last'];
          }
          let i = (e + n + t) % n;
          do {
            const e = this.focusables.get(i);
            if (Rv(e)) {
              return e;
            }
            i = (i + n + t) % n;
          } while (i !== e);
          return null;
        }
      }
      function Rv(t) {
        return !!(t.focus && Qf(t.element));
      }
      class zv extends Dw {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-toolbar__separator'] },
          });
        }
      }
      class Ov extends Dw {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-toolbar__line-break'] },
          });
        }
      }
      function Fv(t) {
        return t.bindTemplate.to((e) => {
          if (e.target === t.element) {
            e.preventDefault();
          }
        });
      }
      function Nv(t) {
        if (Array.isArray(t)) {
          return { items: t, removeItems: [] };
        }
        if (!t) {
          return { items: [], removeItems: [] };
        }
        return Object.assign({ items: [], removeItems: [] }, t);
      }
      var Mv = n(5571);
      var Lv = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Lv.insert = 'head';
      Lv.singleton = true;
      var Vv = Lh()(Mv.Z, Lv);
      const Hv = Mv.Z.locals || {};
      class jv extends Dw {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          const i = this.t;
          this.options = e || {};
          this.set('ariaLabel', i('Editor toolbar'));
          this.set('maxWidth', 'auto');
          this.items = this.createCollection();
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this.set('class');
          this.set('isCompact', false);
          this.itemsView = new qv(t);
          this.children = this.createCollection();
          this.children.add(this.itemsView);
          this.focusables = this.createCollection();
          const o = t.uiLanguageDirection === 'rtl';
          this._focusCycler = new Iv({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: [
                o ? 'arrowright' : 'arrowleft',
                'arrowup',
              ],
              focusNext: [
                o ? 'arrowleft' : 'arrowright',
                'arrowdown',
              ],
            },
          });
          const r = [
            'ck',
            'ck-toolbar',
            n.to('class'),
            n.if('isCompact', 'ck-toolbar_compact'),
          ];
          if (
            this.options.shouldGroupWhenFull &&
            this.options.isFloating
          ) {
            r.push('ck-toolbar_floating');
          }
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: r,
              role: 'toolbar',
              'aria-label': n.to('ariaLabel'),
              style: { maxWidth: n.to('maxWidth') },
            },
            children: this.children,
            on: { mousedown: Fv(this) },
          });
          this._behavior = this.options.shouldGroupWhenFull
            ? new Uv(this)
            : new Wv(this);
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on('add', (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on('remove', (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          this._behavior.render(this);
        }
        destroy() {
          this._behavior.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
          return super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(t, e) {
          const n = Nv(t);
          const i = n.items.filter((t, i, o) => {
            if (t === '|') {
              return true;
            }
            if (n.removeItems.indexOf(t) !== -1) {
              return false;
            }
            if (t === '-') {
              if (this.options.shouldGroupWhenFull) {
                u(
                  'toolbarview-line-break-ignored-when-grouping-items',
                  o
                );
                return false;
              }
              return true;
            }
            if (!e.has(t)) {
              u('toolbarview-item-unavailable', { name: t });
              return false;
            }
            return true;
          });
          const o = this._cleanSeparators(i).map((t) => {
            if (t === '|') {
              return new zv();
            } else if (t === '-') {
              return new Ov();
            }
            return e.create(t);
          });
          this.items.addMany(o);
        }
        _cleanSeparators(t) {
          const e = (t) => t !== '-' && t !== '|';
          const n = t.length;
          const i = t.findIndex(e);
          const o = n - t.slice().reverse().findIndex(e);
          return t.slice(i, o).filter((t, n, i) => {
            if (e(t)) {
              return true;
            }
            const o = n > 0 && i[n - 1] === t;
            return !o;
          });
        }
      }
      class qv extends Dw {
        constructor(t) {
          super(t);
          this.children = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-toolbar__items'] },
            children: this.children,
          });
        }
      }
      class Wv {
        constructor(t) {
          const e = t.bindTemplate;
          t.set('isVertical', false);
          t.itemsView.children.bindTo(t.items).using((t) => t);
          t.focusables.bindTo(t.items).using((t) => t);
          t.extendTemplate({
            attributes: {
              class: [e.if('isVertical', 'ck-toolbar_vertical')],
            },
          });
        }
        render() {}
        destroy() {}
      }
      class Uv {
        constructor(t) {
          this.view = t;
          this.viewChildren = t.children;
          this.viewFocusables = t.focusables;
          this.viewItemsView = t.itemsView;
          this.viewFocusTracker = t.focusTracker;
          this.viewLocale = t.locale;
          this.ungroupedItems = t.createCollection();
          this.groupedItems = t.createCollection();
          this.groupedItemsDropdown =
            this._createGroupedItemsDropdown();
          this.resizeObserver = null;
          this.cachedPadding = null;
          this.shouldUpdateGroupingOnNextResize = false;
          t.itemsView.children
            .bindTo(this.ungroupedItems)
            .using((t) => t);
          this.ungroupedItems.on(
            'add',
            this._updateFocusCycleableItems.bind(this)
          );
          this.ungroupedItems.on(
            'remove',
            this._updateFocusCycleableItems.bind(this)
          );
          t.children.on(
            'add',
            this._updateFocusCycleableItems.bind(this)
          );
          t.children.on(
            'remove',
            this._updateFocusCycleableItems.bind(this)
          );
          t.items.on('change', (t, e) => {
            const n = e.index;
            for (const t of e.removed) {
              if (n >= this.ungroupedItems.length) {
                this.groupedItems.remove(t);
              } else {
                this.ungroupedItems.remove(t);
              }
            }
            for (let t = n; t < n + e.added.length; t++) {
              const i = e.added[t - n];
              if (t > this.ungroupedItems.length) {
                this.groupedItems.add(
                  i,
                  t - this.ungroupedItems.length
                );
              } else {
                this.ungroupedItems.add(i, t);
              }
            }
            this._updateGrouping();
          });
          t.extendTemplate({
            attributes: { class: ['ck-toolbar_grouping'] },
          });
        }
        render(t) {
          this.viewElement = t.element;
          this._enableGroupingOnResize();
          this._enableGroupingOnMaxWidthChange(t);
        }
        destroy() {
          this.groupedItemsDropdown.destroy();
          this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (
            !this.viewElement.ownerDocument.body.contains(
              this.viewElement
            )
          ) {
            return;
          }
          if (!Qf(this.viewElement)) {
            this.shouldUpdateGroupingOnNextResize = true;
            return;
          }
          const t = this.groupedItems.length;
          let e;
          while (this._areItemsOverflowing) {
            this._groupLastItem();
            e = true;
          }
          if (!e && this.groupedItems.length) {
            while (
              this.groupedItems.length &&
              !this._areItemsOverflowing
            ) {
              this._ungroupFirstItem();
            }
            if (this._areItemsOverflowing) {
              this._groupLastItem();
            }
          }
          if (this.groupedItems.length !== t) {
            this.view.fire('groupedItemsUpdate');
          }
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length) {
            return false;
          }
          const t = this.viewElement;
          const e = this.viewLocale.uiLanguageDirection;
          const n = new ag(t.lastChild);
          const i = new ag(t);
          if (!this.cachedPadding) {
            const n = Sa.window.getComputedStyle(t);
            const i = e === 'ltr' ? 'paddingRight' : 'paddingLeft';
            this.cachedPadding = Number.parseInt(n[i]);
          }
          if (e === 'ltr') {
            return n.right > i.right - this.cachedPadding;
          } else {
            return n.left < i.left + this.cachedPadding;
          }
        }
        _enableGroupingOnResize() {
          let t;
          this.resizeObserver = new Yf(this.viewElement, (e) => {
            if (
              !t ||
              t !== e.contentRect.width ||
              this.shouldUpdateGroupingOnNextResize
            ) {
              this.shouldUpdateGroupingOnNextResize = false;
              this._updateGrouping();
              t = e.contentRect.width;
            }
          });
          this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(t) {
          t.on('change:maxWidth', () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          if (!this.groupedItems.length) {
            this.viewChildren.add(new zv());
            this.viewChildren.add(this.groupedItemsDropdown);
            this.viewFocusTracker.add(
              this.groupedItemsDropdown.element
            );
          }
          this.groupedItems.add(
            this.ungroupedItems.remove(this.ungroupedItems.last),
            0
          );
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(
            this.groupedItems.remove(this.groupedItems.first)
          );
          if (!this.groupedItems.length) {
            this.viewChildren.remove(this.groupedItemsDropdown);
            this.viewChildren.remove(this.viewChildren.last);
            this.viewFocusTracker.remove(
              this.groupedItemsDropdown.element
            );
          }
        }
        _createGroupedItemsDropdown() {
          const t = this.viewLocale;
          const e = t.t;
          const n = aA(t);
          n.class = 'ck-toolbar__grouped-dropdown';
          n.panelPosition =
            t.uiLanguageDirection === 'ltr' ? 'sw' : 'se';
          cA(n, []);
          n.buttonView.set({
            label: e('Show more items'),
            tooltip: true,
            tooltipPosition:
              t.uiLanguageDirection === 'rtl' ? 'se' : 'sw',
            icon: N_,
          });
          n.toolbarView.items
            .bindTo(this.groupedItems)
            .using((t) => t);
          return n;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear();
          this.ungroupedItems.map((t) => {
            this.viewFocusables.add(t);
          });
          if (this.groupedItems.length) {
            this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
      }
      var Gv = n(1162);
      var $v = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      $v.insert = 'head';
      $v.singleton = true;
      var Kv = Lh()(Gv.Z, $v);
      const Zv = Gv.Z.locals || {};
      class Jv extends Dw {
        constructor() {
          super();
          this.items = this.createCollection();
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this._focusCycler = new Iv({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: 'arrowup',
              focusNext: 'arrowdown',
            },
          });
          this.setTemplate({
            tag: 'ul',
            attributes: { class: ['ck', 'ck-reset', 'ck-list'] },
            children: this.items,
          });
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on('add', (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on('remove', (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      class Yv extends Dw {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('isVisible', true);
          this.children = this.createCollection();
          this.setTemplate({
            tag: 'li',
            attributes: {
              class: [
                'ck',
                'ck-list__item',
                e.if('isVisible', 'ck-hidden', (t) => !t),
              ],
            },
            children: this.children,
          });
        }
        focus() {
          this.children.first.focus();
        }
      }
      class Qv extends Dw {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: 'li',
            attributes: { class: ['ck', 'ck-list__separator'] },
          });
        }
      }
      var Xv = n(5075);
      var tA = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      tA.insert = 'head';
      tA.singleton = true;
      var eA = Lh()(Xv.Z, tA);
      const nA = Xv.Z.locals || {};
      var iA = n(6875);
      var oA = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      oA.insert = 'head';
      oA.singleton = true;
      var rA = Lh()(iA.Z, oA);
      const sA = iA.Z.locals || {};
      function aA(t, e = _v) {
        const n = new e(t);
        const i = new Ev(t);
        const o = new Pv(t, n, i);
        n.bind('isEnabled').to(o);
        if (n instanceof _v) {
          n.bind('isOn').to(o, 'isOpen');
        } else {
          n.arrowView.bind('isOn').to(o, 'isOpen');
        }
        hA(o);
        return o;
      }
      function cA(t, e, n = {}) {
        const i = t.locale;
        const o = i.t;
        const r = (t.toolbarView = new jv(i));
        r.set('ariaLabel', o('Dropdown toolbar'));
        t.extendTemplate({
          attributes: { class: ['ck-toolbar-dropdown'] },
        });
        e.map((t) => r.items.add(t));
        if (n.enableActiveItemFocusOnDropdownOpen) {
          dA(t, () => r.items.find((t) => t.isOn));
        }
        t.panelView.children.add(r);
        r.items.delegate('execute').to(t);
      }
      function lA(t, e) {
        const n = t.locale;
        const i = (t.listView = new Jv(n));
        i.items.bindTo(e).using(({ type: t, model: e }) => {
          if (t === 'separator') {
            return new Qv(n);
          } else if (t === 'button' || t === 'switchbutton') {
            const i = new Yv(n);
            let o;
            if (t === 'button') {
              o = new iv(n);
            } else {
              o = new cv(n);
            }
            o.bind(...Object.keys(e)).to(e);
            o.delegate('execute').to(i);
            i.children.add(o);
            return i;
          }
        });
        t.panelView.children.add(i);
        i.items.delegate('execute').to(t);
        dA(t, () =>
          i.items.find((t) => {
            if (t instanceof Yv) {
              return t.children.first.isOn;
            }
            return false;
          })
        );
      }
      function dA(t, e) {
        t.on(
          'change:isOpen',
          () => {
            if (!t.isOpen) {
              return;
            }
            const n = e();
            if (!n) {
              return;
            }
            if (typeof n.focus === 'function') {
              n.focus();
            } else {
              u(
                'ui-dropdown-focus-child-on-open-child-missing-focus',
                { view: n }
              );
            }
          },
          { priority: 'low' }
        );
      }
      function hA(t) {
        uA(t);
        fA(t);
        gA(t);
      }
      function uA(t) {
        t.on('render', () => {
          L_({
            emitter: t,
            activator: () => t.isOpen,
            callback: () => {
              t.isOpen = false;
            },
            contextElements: [t.element],
          });
        });
      }
      function fA(t) {
        t.on('execute', (e) => {
          if (e.source instanceof cv) {
            return;
          }
          t.isOpen = false;
        });
      }
      function gA(t) {
        t.keystrokes.set('arrowdown', (e, n) => {
          if (t.isOpen) {
            t.panelView.focus();
            n();
          }
        });
        t.keystrokes.set('arrowup', (e, n) => {
          if (t.isOpen) {
            t.panelView.focusLast();
            n();
          }
        });
      }
      var mA = n(4547);
      var pA = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      pA.insert = 'head';
      pA.singleton = true;
      var kA = Lh()(mA.Z, pA);
      const bA = mA.Z.locals || {};
      class wA extends Dw {
        constructor(t) {
          super(t);
          this.body = new $_(t);
        }
        render() {
          super.render();
          this.body.attachToDom();
        }
        destroy() {
          this.body.detachFromDom();
          return super.destroy();
        }
      }
      var _A = n(2751);
      var vA = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      vA.insert = 'head';
      vA.singleton = true;
      var AA = Lh()(_A.Z, vA);
      const CA = _A.Z.locals || {};
      class yA extends Dw {
        constructor(t) {
          super(t);
          this.set('text');
          this.set('for');
          this.id = `ck-editor__label_${s()}`;
          const e = this.bindTemplate;
          this.setTemplate({
            tag: 'label',
            attributes: {
              class: ['ck', 'ck-label'],
              id: this.id,
              for: e.to('for'),
            },
            children: [{ text: e.to('text') }],
          });
        }
      }
      class xA extends wA {
        constructor(t) {
          super(t);
          this.top = this.createCollection();
          this.main = this.createCollection();
          this._voiceLabelView = this._createVoiceLabel();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-reset',
                'ck-editor',
                'ck-rounded-corners',
              ],
              role: 'application',
              dir: t.uiLanguageDirection,
              lang: t.uiLanguage,
              'aria-labelledby': this._voiceLabelView.id,
            },
            children: [
              this._voiceLabelView,
              {
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-editor__top', 'ck-reset_all'],
                  role: 'presentation',
                },
                children: this.top,
              },
              {
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-editor__main'],
                  role: 'presentation',
                },
                children: this.main,
              },
            ],
          });
        }
        _createVoiceLabel() {
          const t = this.t;
          const e = new yA();
          e.text = t('Rich Text Editor');
          e.extendTemplate({
            attributes: { class: 'ck-voice-label' },
          });
          return e;
        }
      }
      class EA extends Dw {
        constructor(t, e, n) {
          super(t);
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-content',
                'ck-editor__editable',
                'ck-rounded-corners',
              ],
              lang: t.contentLanguage,
              dir: t.contentLanguageDirection,
            },
          });
          this.name = null;
          this.set('isFocused', false);
          this._editableElement = n;
          this._hasExternalElement = !!this._editableElement;
          this._editingView = e;
        }
        render() {
          super.render();
          if (this._hasExternalElement) {
            this.template.apply(
              (this.element = this._editableElement)
            );
          } else {
            this._editableElement = this.element;
          }
          this.on('change:isFocused', () =>
            this._updateIsFocusedClasses()
          );
          this._updateIsFocusedClasses();
        }
        destroy() {
          if (this._hasExternalElement) {
            this.template.revert(this._editableElement);
          }
          super.destroy();
        }
        _updateIsFocusedClasses() {
          const t = this._editingView;
          if (t.isRenderingInProgress) {
            n(this);
          } else {
            e(this);
          }
          function e(e) {
            t.change((n) => {
              const i = t.document.getRoot(e.name);
              n.addClass(
                e.isFocused ? 'ck-focused' : 'ck-blurred',
                i
              );
              n.removeClass(
                e.isFocused ? 'ck-blurred' : 'ck-focused',
                i
              );
            });
          }
          function n(i) {
            t.once('change:isRenderingInProgress', (t, o, r) => {
              if (!r) {
                e(i);
              } else {
                n(i);
              }
            });
          }
        }
      }
      class DA extends EA {
        constructor(t, e, n, i = {}) {
          super(t, e, n);
          const o = t.t;
          this.extendTemplate({
            attributes: {
              role: 'textbox',
              class: 'ck-editor__editable_inline',
            },
          });
          this._generateLabel =
            i.label ||
            (() => o('Editor editing area: %0', this.name));
        }
        render() {
          super.render();
          const t = this._editingView;
          t.change((e) => {
            const n = t.document.getRoot(this.name);
            e.setAttribute(
              'aria-label',
              this._generateLabel(this),
              n
            );
          });
        }
      }
      var SA = n(5523);
      var TA = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      TA.insert = 'head';
      TA.singleton = true;
      var BA = Lh()(SA.Z, TA);
      const PA = SA.Z.locals || {};
      class IA extends Dw {
        constructor(t, e = {}) {
          super(t);
          const n = this.bindTemplate;
          this.set('label', e.label || '');
          this.set('class', e.class || null);
          this.children = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-form__header', n.to('class')],
            },
            children: this.children,
          });
          const i = new Dw(t);
          i.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-form__header__label'] },
            children: [{ text: n.to('label') }],
          });
          this.children.add(i);
        }
      }
      var RA = n(6985);
      var zA = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      zA.insert = 'head';
      zA.singleton = true;
      var OA = Lh()(RA.Z, zA);
      const FA = RA.Z.locals || {};
      class NA extends Dw {
        constructor(t) {
          super(t);
          this.set('value');
          this.set('id');
          this.set('placeholder');
          this.set('isReadOnly', false);
          this.set('hasError', false);
          this.set('ariaDescribedById');
          this.focusTracker = new tg();
          this.bind('isFocused').to(this.focusTracker);
          this.set('isEmpty', true);
          this.set('inputMode', 'text');
          const e = this.bindTemplate;
          this.setTemplate({
            tag: 'input',
            attributes: {
              class: [
                'ck',
                'ck-input',
                e.if('isFocused', 'ck-input_focused'),
                e.if('isEmpty', 'ck-input-text_empty'),
                e.if('hasError', 'ck-error'),
              ],
              id: e.to('id'),
              placeholder: e.to('placeholder'),
              readonly: e.to('isReadOnly'),
              inputmode: e.to('inputMode'),
              'aria-invalid': e.if('hasError', true),
              'aria-describedby': e.to('ariaDescribedById'),
            },
            on: {
              input: e.to((...t) => {
                this.fire('input', ...t);
                this._updateIsEmpty();
              }),
              change: e.to(this._updateIsEmpty.bind(this)),
            },
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
          this._setDomElementValue(this.value);
          this._updateIsEmpty();
          this.on('change:value', (t, e, n) => {
            this._setDomElementValue(n);
            this._updateIsEmpty();
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        _updateIsEmpty() {
          this.isEmpty = MA(this.element);
        }
        _setDomElementValue(t) {
          this.element.value = !t && t !== 0 ? '' : t;
        }
      }
      function MA(t) {
        return !t.value;
      }
      class LA extends NA {
        constructor(t) {
          super(t);
          this.extendTemplate({
            attributes: { type: 'text', class: ['ck-input-text'] },
          });
        }
      }
      class VA extends (null && InputView) {
        constructor(t, { min: e, max: n, step: i } = {}) {
          super(t);
          const o = this.bindTemplate;
          this.set('min', e);
          this.set('max', n);
          this.set('step', i);
          this.extendTemplate({
            attributes: {
              type: 'number',
              class: ['ck-input-number'],
              min: o.to('min'),
              max: o.to('max'),
              step: o.to('step'),
            },
          });
        }
      }
      class HA extends (null && View) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: 'iframe',
            attributes: {
              class: ['ck', 'ck-reset_all'],
              sandbox: 'allow-same-origin allow-scripts',
            },
            on: { load: e.to('loaded') },
          });
        }
        render() {
          return new Promise((t) => {
            this.on('loaded', t);
            super.render();
          });
        }
      }
      var jA = n(8111);
      var qA = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      qA.insert = 'head';
      qA.singleton = true;
      var WA = Lh()(jA.Z, qA);
      const UA = jA.Z.locals || {};
      class GA extends Dw {
        constructor(t, e) {
          super(t);
          const n = `ck-labeled-field-view-${s()}`;
          const i = `ck-labeled-field-view-status-${s()}`;
          this.fieldView = e(this, n, i);
          this.set('label');
          this.set('isEnabled', true);
          this.set('isEmpty', true);
          this.set('isFocused', false);
          this.set('errorText', null);
          this.set('infoText', null);
          this.set('class');
          this.set('placeholder');
          this.labelView = this._createLabelView(n);
          this.statusView = this._createStatusView(i);
          this.bind('_statusText').to(
            this,
            'errorText',
            this,
            'infoText',
            (t, e) => t || e
          );
          const o = this.bindTemplate;
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-labeled-field-view',
                o.to('class'),
                o.if('isEnabled', 'ck-disabled', (t) => !t),
                o.if('isEmpty', 'ck-labeled-field-view_empty'),
                o.if('isFocused', 'ck-labeled-field-view_focused'),
                o.if(
                  'placeholder',
                  'ck-labeled-field-view_placeholder'
                ),
                o.if('errorText', 'ck-error'),
              ],
            },
            children: [
              {
                tag: 'div',
                attributes: {
                  class: [
                    'ck',
                    'ck-labeled-field-view__input-wrapper',
                  ],
                },
                children: [this.fieldView, this.labelView],
              },
              this.statusView,
            ],
          });
        }
        _createLabelView(t) {
          const e = new yA(this.locale);
          e.for = t;
          e.bind('text').to(this, 'label');
          return e;
        }
        _createStatusView(t) {
          const e = new Dw(this.locale);
          const n = this.bindTemplate;
          e.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-labeled-field-view__status',
                n.if(
                  'errorText',
                  'ck-labeled-field-view__status_error'
                ),
                n.if('_statusText', 'ck-hidden', (t) => !t),
              ],
              id: t,
              role: n.if('errorText', 'alert'),
            },
            children: [{ text: n.to('_statusText') }],
          });
          return e;
        }
        focus() {
          this.fieldView.focus();
        }
      }
      function $A(t, e, n) {
        const i = new LA(t.locale);
        i.set({ id: e, ariaDescribedById: n });
        i.bind('isReadOnly').to(t, 'isEnabled', (t) => !t);
        i.bind('hasError').to(t, 'errorText', (t) => !!t);
        i.on('input', () => {
          t.errorText = null;
        });
        t.bind('isEmpty', 'isFocused', 'placeholder').to(i);
        return i;
      }
      function KA(t, e, n) {
        const i = new InputNumberView(t.locale);
        i.set({ id: e, ariaDescribedById: n, inputMode: 'numeric' });
        i.bind('isReadOnly').to(t, 'isEnabled', (t) => !t);
        i.bind('hasError').to(t, 'errorText', (t) => !!t);
        i.on('input', () => {
          t.errorText = null;
        });
        t.bind('isEmpty', 'isFocused', 'placeholder').to(i);
        return i;
      }
      function ZA(t, e, n) {
        const i = createDropdown(t.locale);
        i.set({ id: e, ariaDescribedById: n });
        i.bind('isEnabled').to(t);
        return i;
      }
      class JA extends La {
        static get pluginName() {
          return 'Notification';
        }
        init() {
          this.on(
            'show:warning',
            (t, e) => {
              window.alert(e.message);
            },
            { priority: 'lowest' }
          );
        }
        showSuccess(t, e = {}) {
          this._showNotification({
            message: t,
            type: 'success',
            namespace: e.namespace,
            title: e.title,
          });
        }
        showInfo(t, e = {}) {
          this._showNotification({
            message: t,
            type: 'info',
            namespace: e.namespace,
            title: e.title,
          });
        }
        showWarning(t, e = {}) {
          this._showNotification({
            message: t,
            type: 'warning',
            namespace: e.namespace,
            title: e.title,
          });
        }
        _showNotification(t) {
          const e =
            `show:${t.type}` + (t.namespace ? `:${t.namespace}` : '');
          this.fire(e, {
            message: t.message,
            type: t.type,
            title: t.title || '',
          });
        }
      }
      class YA {
        constructor(t, e) {
          if (e) {
            _f(this, e);
          }
          if (t) {
            this.set(t);
          }
        }
      }
      et(YA, q);
      const QA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
      const XA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
      var tC = n(1757);
      var eC = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      eC.insert = 'head';
      eC.singleton = true;
      var nC = Lh()(tC.Z, eC);
      const iC = tC.Z.locals || {};
      var oC = n(3553);
      var rC = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      rC.insert = 'head';
      rC.singleton = true;
      var sC = Lh()(oC.Z, rC);
      const aC = oC.Z.locals || {};
      const cC = Ow('px');
      class lC extends nt {
        static get pluginName() {
          return 'ContextualBalloon';
        }
        constructor(t) {
          super(t);
          this.positionLimiter = () => {
            const t = this.editor.editing.view;
            const e = t.document;
            const n = e.selection.editableElement;
            if (n) {
              return t.domConverter.mapViewToDom(n.root);
            }
            return null;
          };
          this.set('visibleView', null);
          this.view = new jw(t.locale);
          t.ui.view.body.add(this.view);
          t.ui.focusTracker.add(this.view.element);
          this._viewToStack = new Map();
          this._idToStack = new Map();
          this.set('_numberOfStacks', 0);
          this.set('_singleViewMode', false);
          this._rotatorView = this._createRotatorView();
          this._fakePanelsView = this._createFakePanelsView();
        }
        destroy() {
          super.destroy();
          this.view.destroy();
          this._rotatorView.destroy();
          this._fakePanelsView.destroy();
        }
        hasView(t) {
          return Array.from(this._viewToStack.keys()).includes(t);
        }
        add(t) {
          if (this.hasView(t.view)) {
            throw new h('contextualballoon-add-view-exist', [
              this,
              t,
            ]);
          }
          const e = t.stackId || 'main';
          if (!this._idToStack.has(e)) {
            this._idToStack.set(e, new Map([[t.view, t]]));
            this._viewToStack.set(t.view, this._idToStack.get(e));
            this._numberOfStacks = this._idToStack.size;
            if (!this._visibleStack || t.singleViewMode) {
              this.showStack(e);
            }
            return;
          }
          const n = this._idToStack.get(e);
          if (t.singleViewMode) {
            this.showStack(e);
          }
          n.set(t.view, t);
          this._viewToStack.set(t.view, n);
          if (n === this._visibleStack) {
            this._showView(t);
          }
        }
        remove(t) {
          if (!this.hasView(t)) {
            throw new h('contextualballoon-remove-view-not-exist', [
              this,
              t,
            ]);
          }
          const e = this._viewToStack.get(t);
          if (this._singleViewMode && this.visibleView === t) {
            this._singleViewMode = false;
          }
          if (this.visibleView === t) {
            if (e.size === 1) {
              if (this._idToStack.size > 1) {
                this._showNextStack();
              } else {
                this.view.hide();
                this.visibleView = null;
                this._rotatorView.hideView();
              }
            } else {
              this._showView(Array.from(e.values())[e.size - 2]);
            }
          }
          if (e.size === 1) {
            this._idToStack.delete(this._getStackId(e));
            this._numberOfStacks = this._idToStack.size;
          } else {
            e.delete(t);
          }
          this._viewToStack.delete(t);
        }
        updatePosition(t) {
          if (t) {
            this._visibleStack.get(this.visibleView).position = t;
          }
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
        }
        showStack(t) {
          this.visibleStack = t;
          const e = this._idToStack.get(t);
          if (!e) {
            throw new h(
              'contextualballoon-showstack-stack-not-exist',
              this
            );
          }
          if (this._visibleStack === e) {
            return;
          }
          this._showView(Array.from(e.values()).pop());
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(t) {
          const e = Array.from(this._idToStack.entries()).find(
            (e) => e[1] === t
          );
          return e[0];
        }
        _showNextStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) + 1;
          if (!t[e]) {
            e = 0;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _showPrevStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) - 1;
          if (!t[e]) {
            e = t.length - 1;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _createRotatorView() {
          const t = new dC(this.editor.locale);
          const e = this.editor.locale.t;
          this.view.content.add(t);
          t.bind('isNavigationVisible').to(
            this,
            '_numberOfStacks',
            this,
            '_singleViewMode',
            (t, e) => !e && t > 1
          );
          t.on(
            'change:isNavigationVisible',
            () => this.updatePosition(),
            { priority: 'low' }
          );
          t.bind('counter').to(
            this,
            'visibleView',
            this,
            '_numberOfStacks',
            (t, n) => {
              if (n < 2) {
                return '';
              }
              const i =
                Array.from(this._idToStack.values()).indexOf(
                  this._visibleStack
                ) + 1;
              return e('%0 of %1', [i, n]);
            }
          );
          t.buttonNextView.on('execute', () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showNextStack();
          });
          t.buttonPrevView.on('execute', () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showPrevStack();
          });
          return t;
        }
        _createFakePanelsView() {
          const t = new hC(this.editor.locale, this.view);
          t.bind('numberOfPanels').to(
            this,
            '_numberOfStacks',
            this,
            '_singleViewMode',
            (t, e) => {
              const n = !e && t >= 2;
              return n ? Math.min(t - 1, 2) : 0;
            }
          );
          t.listenTo(this.view, 'change:top', () =>
            t.updatePosition()
          );
          t.listenTo(this.view, 'change:left', () =>
            t.updatePosition()
          );
          this.editor.ui.view.body.add(t);
          return t;
        }
        _showView({
          view: t,
          balloonClassName: e = '',
          withArrow: n = true,
          singleViewMode: i = false,
        }) {
          this.view.class = e;
          this.view.withArrow = n;
          this._rotatorView.showView(t);
          this.visibleView = t;
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
          if (i) {
            this._singleViewMode = true;
          }
        }
        _getBalloonPosition() {
          let t = Array.from(this._visibleStack.values()).pop()
            .position;
          if (t) {
            if (!t.limiter) {
              t = Object.assign({}, t, {
                limiter: this.positionLimiter,
              });
            }
            t = Object.assign({}, t, {
              viewportOffsetConfig: this.editor.ui.viewportOffset,
            });
          }
          return t;
        }
      }
      class dC extends Dw {
        constructor(t) {
          super(t);
          const e = t.t;
          const n = this.bindTemplate;
          this.set('isNavigationVisible', true);
          this.focusTracker = new tg();
          this.buttonPrevView = this._createButtonView(
            e('Previous'),
            QA
          );
          this.buttonNextView = this._createButtonView(e('Next'), XA);
          this.content = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-balloon-rotator'],
              'z-index': '-1',
            },
            children: [
              {
                tag: 'div',
                attributes: {
                  class: [
                    'ck-balloon-rotator__navigation',
                    n.to('isNavigationVisible', (t) =>
                      t ? '' : 'ck-hidden'
                    ),
                  ],
                },
                children: [
                  this.buttonPrevView,
                  {
                    tag: 'span',
                    attributes: {
                      class: ['ck-balloon-rotator__counter'],
                    },
                    children: [{ text: n.to('counter') }],
                  },
                  this.buttonNextView,
                ],
              },
              {
                tag: 'div',
                attributes: { class: 'ck-balloon-rotator__content' },
                children: this.content,
              },
            ],
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
        }
        showView(t) {
          this.hideView();
          this.content.add(t);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(t, e) {
          const n = new iv(this.locale);
          n.set({ label: t, icon: e, tooltip: true });
          return n;
        }
      }
      class hC extends Dw {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          this.set('top', 0);
          this.set('left', 0);
          this.set('height', 0);
          this.set('width', 0);
          this.set('numberOfPanels', 0);
          this.content = this.createCollection();
          this._balloonPanelView = e;
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck-fake-panel',
                n.to('numberOfPanels', (t) => (t ? '' : 'ck-hidden')),
              ],
              style: {
                top: n.to('top', cC),
                left: n.to('left', cC),
                width: n.to('width', cC),
                height: n.to('height', cC),
              },
            },
            children: this.content,
          });
          this.on('change:numberOfPanels', (t, e, n, i) => {
            if (n > i) {
              this._addPanels(n - i);
            } else {
              this._removePanels(i - n);
            }
            this.updatePosition();
          });
        }
        _addPanels(t) {
          while (t--) {
            const t = new Dw();
            t.setTemplate({ tag: 'div' });
            this.content.add(t);
            this.registerChild(t);
          }
        }
        _removePanels(t) {
          while (t--) {
            const t = this.content.last;
            this.content.remove(t);
            this.deregisterChild(t);
            t.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: t, left: e } = this._balloonPanelView;
            const { width: n, height: i } = new ag(
              this._balloonPanelView.element
            );
            Object.assign(this, {
              top: t,
              left: e,
              width: n,
              height: i,
            });
          }
        }
      }
      var uC = n(3609);
      var fC = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      fC.insert = 'head';
      fC.singleton = true;
      var gC = Lh()(uC.Z, fC);
      const mC = uC.Z.locals || {};
      const pC = Ow('px');
      class kC extends Dw {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('isActive', false);
          this.set('isSticky', false);
          this.set('limiterElement', null);
          this.set('limiterBottomOffset', 50);
          this.set('viewportTopOffset', 0);
          this.set('_marginLeft', null);
          this.set('_isStickyToTheLimiter', false);
          this.set('_hasViewportTopOffset', false);
          this.content = this.createCollection();
          this._contentPanelPlaceholder = new Yb({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-sticky-panel__placeholder'],
              style: {
                display: e.to('isSticky', (t) =>
                  t ? 'block' : 'none'
                ),
                height: e.to('isSticky', (t) =>
                  t ? pC(this._panelRect.height) : null
                ),
              },
            },
          }).render();
          this._contentPanel = new Yb({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-sticky-panel__content',
                e.if('isSticky', 'ck-sticky-panel__content_sticky'),
                e.if(
                  '_isStickyToTheLimiter',
                  'ck-sticky-panel__content_sticky_bottom-limit'
                ),
              ],
              style: {
                width: e.to('isSticky', (t) =>
                  t
                    ? pC(
                        this._contentPanelPlaceholder.getBoundingClientRect()
                          .width
                      )
                    : null
                ),
                top: e.to('_hasViewportTopOffset', (t) =>
                  t ? pC(this.viewportTopOffset) : null
                ),
                bottom: e.to('_isStickyToTheLimiter', (t) =>
                  t ? pC(this.limiterBottomOffset) : null
                ),
                marginLeft: e.to('_marginLeft'),
              },
            },
            children: this.content,
          }).render();
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-sticky-panel'] },
            children: [
              this._contentPanelPlaceholder,
              this._contentPanel,
            ],
          });
        }
        render() {
          super.render();
          this._checkIfShouldBeSticky();
          this.listenTo(Sa.window, 'scroll', () => {
            this._checkIfShouldBeSticky();
          });
          this.listenTo(this, 'change:isActive', () => {
            this._checkIfShouldBeSticky();
          });
        }
        _checkIfShouldBeSticky() {
          const t = (this._panelRect =
            this._contentPanel.getBoundingClientRect());
          let e;
          if (!this.limiterElement) {
            this.isSticky = false;
          } else {
            e = this._limiterRect =
              this.limiterElement.getBoundingClientRect();
            this.isSticky =
              this.isActive &&
              e.top < this.viewportTopOffset &&
              this._panelRect.height + this.limiterBottomOffset <
                e.height;
          }
          if (this.isSticky) {
            this._isStickyToTheLimiter =
              e.bottom <
              t.height +
                this.limiterBottomOffset +
                this.viewportTopOffset;
            this._hasViewportTopOffset =
              !this._isStickyToTheLimiter && !!this.viewportTopOffset;
            this._marginLeft = this._isStickyToTheLimiter
              ? null
              : pC(-Sa.window.scrollX);
          } else {
            this._isStickyToTheLimiter = false;
            this._hasViewportTopOffset = false;
            this._marginLeft = null;
          }
        }
      }
      const bC = Ow('px');
      class wC extends (null && Plugin) {
        static get pluginName() {
          return 'BalloonToolbar';
        }
        static get requires() {
          return [ContextualBalloon];
        }
        constructor(t) {
          super(t);
          this._balloonConfig = normalizeToolbarConfig(
            t.config.get('balloonToolbar')
          );
          this.toolbarView = this._createToolbarView();
          this.focusTracker = new FocusTracker();
          t.ui.once('ready', () => {
            this.focusTracker.add(t.ui.getEditableElement());
            this.focusTracker.add(this.toolbarView.element);
          });
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this.show(true),
            afterBlur: () => this.hide(),
            isContextual: true,
          });
          this._resizeObserver = null;
          this._balloon = t.plugins.get(ContextualBalloon);
          this._fireSelectionChangeDebounced = debounce(
            () => this.fire('_selectionChangeDebounced'),
            200
          );
          this.decorate('show');
        }
        init() {
          const t = this.editor;
          const e = t.model.document.selection;
          this.listenTo(
            this.focusTracker,
            'change:isFocused',
            (t, e, n) => {
              const i =
                this._balloon.visibleView === this.toolbarView;
              if (!n && i) {
                this.hide();
              } else if (n) {
                this.show();
              }
            }
          );
          this.listenTo(e, 'change:range', (t, n) => {
            if (n.directChange || e.isCollapsed) {
              this.hide();
            }
            this._fireSelectionChangeDebounced();
          });
          this.listenTo(this, '_selectionChangeDebounced', () => {
            if (this.editor.editing.view.document.isFocused) {
              this.show();
            }
          });
          if (!this._balloonConfig.shouldNotGroupWhenFull) {
            this.listenTo(t, 'ready', () => {
              const e = t.ui.view.editable.element;
              this._resizeObserver = new ResizeObserver(e, () => {
                this.toolbarView.maxWidth = bC(
                  new Rect(e).width * 0.9
                );
              });
            });
          }
          this.listenTo(
            this.toolbarView,
            'groupedItemsUpdate',
            () => {
              this._updatePosition();
            }
          );
        }
        afterInit() {
          const t = this.editor.ui.componentFactory;
          this.toolbarView.fillFromConfig(this._balloonConfig, t);
        }
        _createToolbarView() {
          const t = this.editor.locale.t;
          const e = !this._balloonConfig.shouldNotGroupWhenFull;
          const n = new ToolbarView(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          });
          n.ariaLabel = t('Editor contextual toolbar');
          n.render();
          return n;
        }
        show(t = false) {
          const e = this.editor;
          const n = e.model.document.selection;
          const i = e.model.schema;
          if (this._balloon.hasView(this.toolbarView)) {
            return;
          }
          if (n.isCollapsed && !t) {
            return;
          }
          if (_C(n, i)) {
            return;
          }
          if (
            Array.from(this.toolbarView.items).every(
              (t) => t.isEnabled !== undefined && !t.isEnabled
            )
          ) {
            return;
          }
          this.listenTo(this.editor.ui, 'update', () => {
            this._updatePosition();
          });
          this._balloon.add({
            view: this.toolbarView,
            position: this._getBalloonPositionData(),
            balloonClassName: 'ck-toolbar-container',
          });
        }
        hide() {
          if (this._balloon.hasView(this.toolbarView)) {
            this.stopListening(this.editor.ui, 'update');
            this._balloon.remove(this.toolbarView);
          }
        }
        _getBalloonPositionData() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const i = n.selection;
          const o = n.selection.isBackward;
          return {
            target: () => {
              const t = o ? i.getFirstRange() : i.getLastRange();
              const n = Rect.getDomRangeRects(
                e.domConverter.viewRangeToDom(t)
              );
              if (o) {
                return n[0];
              } else {
                if (n.length > 1 && n[n.length - 1].width === 0) {
                  n.pop();
                }
                return n[n.length - 1];
              }
            },
            positions: this._getBalloonPositions(o),
          };
        }
        _updatePosition() {
          this._balloon.updatePosition(
            this._getBalloonPositionData()
          );
        }
        destroy() {
          super.destroy();
          this.stopListening();
          this._fireSelectionChangeDebounced.cancel();
          this.toolbarView.destroy();
          this.focusTracker.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _getBalloonPositions(t) {
          const e = env.isSafari && env.isiOS;
          const n = e
            ? generatePositions({
                heightOffset: Math.max(
                  BalloonPanelView.arrowHeightOffset,
                  Math.round(20 / global.window.visualViewport.scale)
                ),
              })
            : BalloonPanelView.defaultPositions;
          return t
            ? [
                n.northWestArrowSouth,
                n.northWestArrowSouthWest,
                n.northWestArrowSouthEast,
                n.northWestArrowSouthMiddleEast,
                n.northWestArrowSouthMiddleWest,
                n.southWestArrowNorth,
                n.southWestArrowNorthWest,
                n.southWestArrowNorthEast,
                n.southWestArrowNorthMiddleWest,
                n.southWestArrowNorthMiddleEast,
              ]
            : [
                n.southEastArrowNorth,
                n.southEastArrowNorthEast,
                n.southEastArrowNorthWest,
                n.southEastArrowNorthMiddleEast,
                n.southEastArrowNorthMiddleWest,
                n.northEastArrowSouth,
                n.northEastArrowSouthEast,
                n.northEastArrowSouthWest,
                n.northEastArrowSouthMiddleEast,
                n.northEastArrowSouthMiddleWest,
              ];
        }
      }
      function _C(t, e) {
        if (t.rangeCount === 1) {
          return false;
        }
        return [...t.getRanges()].every((t) => {
          const n = t.getContainedElement();
          return n && e.isSelectable(n);
        });
      }
      var vC = n(6706);
      var AC = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      AC.insert = 'head';
      AC.singleton = true;
      var CC = Lh()(vC.Z, AC);
      const yC = vC.Z.locals || {};
      const xC = Ow('px');
      class EC extends (null && ButtonView) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.isVisible = false;
          this.isToggleable = true;
          this.set('top', 0);
          this.set('left', 0);
          this.extendTemplate({
            attributes: {
              class: 'ck-block-toolbar-button',
              style: {
                top: e.to('top', (t) => xC(t)),
                left: e.to('left', (t) => xC(t)),
              },
            },
          });
        }
      }
      const DC = Ow('px');
      class SC extends (null && Plugin) {
        static get pluginName() {
          return 'BlockToolbar';
        }
        constructor(t) {
          super(t);
          this._blockToolbarConfig = normalizeToolbarConfig(
            this.editor.config.get('blockToolbar')
          );
          this.toolbarView = this._createToolbarView();
          this.panelView = this._createPanelView();
          this.buttonView = this._createButtonView();
          this._resizeObserver = null;
          clickOutsideHandler({
            emitter: this.panelView,
            contextElements: [
              this.panelView.element,
              this.buttonView.element,
            ],
            activator: () => this.panelView.isVisible,
            callback: () => this._hidePanel(),
          });
        }
        init() {
          const t = this.editor;
          this.listenTo(
            t.model.document.selection,
            'change:range',
            (t, e) => {
              if (e.directChange) {
                this._hidePanel();
              }
            }
          );
          this.listenTo(t.ui, 'update', () => this._updateButton());
          this.listenTo(
            t,
            'change:isReadOnly',
            () => this._updateButton(),
            { priority: 'low' }
          );
          this.listenTo(t.ui.focusTracker, 'change:isFocused', () =>
            this._updateButton()
          );
          this.listenTo(
            this.buttonView,
            'change:isVisible',
            (t, e, n) => {
              if (n) {
                this.buttonView.listenTo(window, 'resize', () =>
                  this._updateButton()
                );
              } else {
                this.buttonView.stopListening(window, 'resize');
                this._hidePanel();
              }
            }
          );
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this._showPanel(),
            afterBlur: () => this._hidePanel(),
          });
        }
        afterInit() {
          const t = this.editor.ui.componentFactory;
          const e = this._blockToolbarConfig;
          this.toolbarView.fillFromConfig(e, t);
          for (const t of this.toolbarView.items) {
            t.on('execute', () => this._hidePanel(true), {
              priority: 'high',
            });
          }
          if (!e.shouldNotGroupWhenFull) {
            this.listenTo(this.editor, 'ready', () => {
              const t = this.editor.ui.view.editable.element;
              this._resizeObserver = new ResizeObserver(t, () => {
                this.toolbarView.maxWidth =
                  this._getToolbarMaxWidth();
              });
            });
          }
        }
        destroy() {
          super.destroy();
          this.panelView.destroy();
          this.buttonView.destroy();
          this.toolbarView.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _createToolbarView() {
          const t = this.editor.locale.t;
          const e = !this._blockToolbarConfig.shouldNotGroupWhenFull;
          const n = new ToolbarView(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          });
          n.ariaLabel = t('Editor block content toolbar');
          n.focusTracker.on('change:isFocused', (t, e, n) => {
            if (!n) {
              this._hidePanel();
            }
          });
          return n;
        }
        _createPanelView() {
          const t = this.editor;
          const e = new BalloonPanelView(t.locale);
          e.content.add(this.toolbarView);
          e.class = 'ck-toolbar-container';
          t.ui.view.body.add(e);
          t.ui.focusTracker.add(e.element);
          this.toolbarView.keystrokes.set('Esc', (t, e) => {
            this._hidePanel(true);
            e();
          });
          return e;
        }
        _createButtonView() {
          const t = this.editor;
          const e = t.t;
          const n = new BlockButtonView(t.locale);
          n.set({
            label: e('Edit block'),
            icon: pilcrow,
            withText: false,
          });
          n.bind('isOn').to(this.panelView, 'isVisible');
          n.bind('tooltip').to(
            this.panelView,
            'isVisible',
            (t) => !t
          );
          this.listenTo(n, 'execute', () => {
            if (!this.panelView.isVisible) {
              this._showPanel();
            } else {
              this._hidePanel(true);
            }
          });
          t.ui.view.body.add(n);
          t.ui.focusTracker.add(n.element);
          return n;
        }
        _updateButton() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          if (!t.ui.focusTracker.isFocused) {
            this._hideButton();
            return;
          }
          if (t.isReadOnly) {
            this._hideButton();
            return;
          }
          const i = Array.from(
            e.document.selection.getSelectedBlocks()
          )[0];
          if (
            !i ||
            Array.from(this.toolbarView.items).every(
              (t) => !t.isEnabled
            )
          ) {
            this._hideButton();
            return;
          }
          const o = n.domConverter.mapViewToDom(
            t.editing.mapper.toViewElement(i)
          );
          this.buttonView.isVisible = true;
          this._attachButtonToElement(o);
          if (this.panelView.isVisible) {
            this._showPanel();
          }
        }
        _hideButton() {
          this.buttonView.isVisible = false;
        }
        _showPanel() {
          if (!this.buttonView.isVisible) {
            return;
          }
          const t = this.panelView.isVisible;
          this.panelView.show();
          this.toolbarView.maxWidth = this._getToolbarMaxWidth();
          this.panelView.pin({
            target: this.buttonView.element,
            limiter: this.editor.ui.getEditableElement(),
          });
          if (!t) {
            this.toolbarView.items.get(0).focus();
          }
        }
        _hidePanel(t) {
          this.panelView.isVisible = false;
          if (t) {
            this.editor.editing.view.focus();
          }
        }
        _attachButtonToElement(t) {
          const e = window.getComputedStyle(t);
          const n = new Rect(this.editor.ui.getEditableElement());
          const i = parseInt(e.paddingTop, 10);
          const o =
            parseInt(e.lineHeight, 10) ||
            parseInt(e.fontSize, 10) * 1.2;
          const r = getOptimalPosition({
            element: this.buttonView.element,
            target: t,
            positions: [
              (t, e) => {
                let r;
                if (
                  this.editor.locale.uiLanguageDirection === 'ltr'
                ) {
                  r = n.left - e.width;
                } else {
                  r = n.right;
                }
                return {
                  top: t.top + i + (o - e.height) / 2,
                  left: r,
                };
              },
            ],
          });
          this.buttonView.top = r.top;
          this.buttonView.left = r.left;
        }
        _getToolbarMaxWidth() {
          const t = this.editor.ui.view.editable.element;
          const e = new Rect(t);
          const n = new Rect(this.buttonView.element);
          const i = this.editor.locale.uiLanguageDirection === 'rtl';
          const o = i ? n.left - e.right + n.width : e.left - n.left;
          return DC(e.width + o);
        }
      }
      var TC = n(8894);
      var BC = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      BC.insert = 'head';
      BC.singleton = true;
      var PC = Lh()(TC.Z, BC);
      const IC = TC.Z.locals || {};
      const RC = new WeakMap();
      function zC(t) {
        const {
          view: e,
          element: n,
          text: i,
          isDirectHost: o = true,
          keepOnFocus: r = false,
        } = t;
        const s = e.document;
        if (!RC.has(s)) {
          RC.set(s, new Map());
          s.registerPostFixer((t) => LC(s, t));
        }
        RC.get(s).set(n, {
          text: i,
          isDirectHost: o,
          keepOnFocus: r,
          hostElement: o ? n : null,
        });
        e.change((t) => LC(s, t));
      }
      function OC(t, e) {
        const n = e.document;
        t.change((t) => {
          if (!RC.has(n)) {
            return;
          }
          const i = RC.get(n);
          const o = i.get(e);
          t.removeAttribute('data-placeholder', o.hostElement);
          NC(t, o.hostElement);
          i.delete(e);
        });
      }
      function FC(t, e) {
        if (!e.hasClass('ck-placeholder')) {
          t.addClass('ck-placeholder', e);
          return true;
        }
        return false;
      }
      function NC(t, e) {
        if (e.hasClass('ck-placeholder')) {
          t.removeClass('ck-placeholder', e);
          return true;
        }
        return false;
      }
      function MC(t, e) {
        if (!t.isAttached()) {
          return false;
        }
        const n = Array.from(t.getChildren()).some(
          (t) => !t.is('uiElement')
        );
        if (n) {
          return false;
        }
        if (e) {
          return true;
        }
        const i = t.document;
        if (!i.isFocused) {
          return true;
        }
        const o = i.selection;
        const r = o.anchor;
        return !!r && r.parent !== t;
      }
      function LC(t, e) {
        const n = RC.get(t);
        const i = [];
        let o = false;
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            i.push(t);
            if (VC(e, t, r)) {
              o = true;
            }
          }
        }
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            continue;
          }
          const n = HC(t);
          if (!n) {
            continue;
          }
          if (i.includes(n)) {
            continue;
          }
          r.hostElement = n;
          if (VC(e, t, r)) {
            o = true;
          }
        }
        return o;
      }
      function VC(t, e, n) {
        const { text: i, isDirectHost: o, hostElement: r } = n;
        let s = false;
        if (r.getAttribute('data-placeholder') !== i) {
          t.setAttribute('data-placeholder', i, r);
          s = true;
        }
        const a = o || e.childCount == 1;
        if (a && MC(r, n.keepOnFocus)) {
          if (FC(t, r)) {
            s = true;
          }
        } else if (NC(t, r)) {
          s = true;
        }
        return s;
      }
      function HC(t) {
        if (t.childCount) {
          const e = t.getChild(0);
          if (
            e.is('element') &&
            !e.is('uiElement') &&
            !e.is('attributeElement')
          ) {
            return e;
          }
        }
        return null;
      }
      const jC = new Map();
      function qC(t, e, n) {
        let i = jC.get(t);
        if (!i) {
          i = new Map();
          jC.set(t, i);
        }
        i.set(e, n);
      }
      function WC(t, e) {
        const n = jC.get(t);
        if (n && n.has(e)) {
          return n.get(e);
        }
        return UC;
      }
      function UC(t) {
        return [t];
      }
      function GC(t, e, n = {}) {
        const i = WC(t.constructor, e.constructor);
        try {
          t = t.clone();
          return i(t, e, n);
        } catch (t) {
          throw t;
        }
      }
      function $C(t, e, n) {
        t = t.slice();
        e = e.slice();
        const i = new KC(
          n.document,
          n.useRelations,
          n.forceWeakRemove
        );
        i.setOriginalOperations(t);
        i.setOriginalOperations(e);
        const o = i.originalOperations;
        if (t.length == 0 || e.length == 0) {
          return {
            operationsA: t,
            operationsB: e,
            originalOperations: o,
          };
        }
        const r = new WeakMap();
        for (const e of t) {
          r.set(e, 0);
        }
        const s = {
          nextBaseVersionA: t[t.length - 1].baseVersion + 1,
          nextBaseVersionB: e[e.length - 1].baseVersion + 1,
          originalOperationsACount: t.length,
          originalOperationsBCount: e.length,
        };
        let a = 0;
        while (a < t.length) {
          const n = t[a];
          const o = r.get(n);
          if (o == e.length) {
            a++;
            continue;
          }
          const s = e[o];
          const c = GC(n, s, i.getContext(n, s, true));
          const l = GC(s, n, i.getContext(s, n, false));
          i.updateRelation(n, s);
          i.setOriginalOperations(c, n);
          i.setOriginalOperations(l, s);
          for (const t of c) {
            r.set(t, o + l.length);
          }
          t.splice(a, 1, ...c);
          e.splice(o, 1, ...l);
        }
        if (n.padWithNoOps) {
          const n = t.length - s.originalOperationsACount;
          const i = e.length - s.originalOperationsBCount;
          JC(t, i - n);
          JC(e, n - i);
        }
        ZC(t, s.nextBaseVersionB);
        ZC(e, s.nextBaseVersionA);
        return {
          operationsA: t,
          operationsB: e,
          originalOperations: o,
        };
      }
      class KC {
        constructor(t, e, n = false) {
          this.originalOperations = new Map();
          this._history = t.history;
          this._useRelations = e;
          this._forceWeakRemove = !!n;
          this._relations = new Map();
        }
        setOriginalOperations(t, e = null) {
          const n = e ? this.originalOperations.get(e) : null;
          for (const e of t) {
            this.originalOperations.set(e, n || e);
          }
        }
        updateRelation(t, e) {
          if (t instanceof Fk) {
            if (e instanceof jk) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                e.movedRange.containsPosition(t.targetPosition)
              ) {
                this._setRelation(t, e, 'insertAtSource');
              } else if (
                t.targetPosition.isEqual(e.deletionPosition)
              ) {
                this._setRelation(t, e, 'insertBetween');
              } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                this._setRelation(t, e, 'moveTargetAfter');
              }
            } else if (e instanceof Fk) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                t.targetPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, 'insertBefore');
              } else {
                this._setRelation(t, e, 'insertAfter');
              }
            }
          } else if (t instanceof qk) {
            if (e instanceof jk) {
              if (t.splitPosition.isBefore(e.sourcePosition)) {
                this._setRelation(t, e, 'splitBefore');
              }
            } else if (e instanceof Fk) {
              if (
                t.splitPosition.isEqual(e.sourcePosition) ||
                t.splitPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, 'splitBefore');
              } else {
                const n = Fg._createFromPositionAndShift(
                  e.sourcePosition,
                  e.howMany
                );
                if (
                  t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                  n.containsPosition(t.splitPosition)
                ) {
                  const i = n.end.offset - t.splitPosition.offset;
                  const o = t.splitPosition.offset - n.start.offset;
                  this._setRelation(t, e, { howMany: i, offset: o });
                }
              }
            }
          } else if (t instanceof jk) {
            if (e instanceof jk) {
              if (!t.targetPosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, 'mergeTargetNotMoved');
              }
              if (t.sourcePosition.isEqual(e.targetPosition)) {
                this._setRelation(t, e, 'mergeSourceNotMoved');
              }
              if (t.sourcePosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, 'mergeSameElement');
              }
            } else if (e instanceof qk) {
              if (t.sourcePosition.isEqual(e.splitPosition)) {
                this._setRelation(t, e, 'splitAtSource');
              }
            }
          } else if (t instanceof Mk) {
            const n = t.newRange;
            if (!n) {
              return;
            }
            if (e instanceof Fk) {
              const i = Fg._createFromPositionAndShift(
                e.sourcePosition,
                e.howMany
              );
              const o =
                i.containsPosition(n.start) ||
                i.start.isEqual(n.start);
              const r =
                i.containsPosition(n.end) || i.end.isEqual(n.end);
              if ((o || r) && !i.containsRange(n)) {
                this._setRelation(t, e, {
                  side: o ? 'left' : 'right',
                  path: o ? n.start.path.slice() : n.end.path.slice(),
                });
              }
            } else if (e instanceof jk) {
              const i = n.start.isEqual(e.targetPosition);
              const o = n.start.isEqual(e.deletionPosition);
              const r = n.end.isEqual(e.deletionPosition);
              const s = n.end.isEqual(e.sourcePosition);
              if (i || o || r || s) {
                this._setRelation(t, e, {
                  wasInLeftElement: i,
                  wasStartBeforeMergedElement: o,
                  wasEndBeforeMergedElement: r,
                  wasInRightElement: s,
                });
              }
            }
          }
        }
        getContext(t, e, n) {
          return {
            aIsStrong: n,
            aWasUndone: this._wasUndone(t),
            bWasUndone: this._wasUndone(e),
            abRelation: this._useRelations
              ? this._getRelation(t, e)
              : null,
            baRelation: this._useRelations
              ? this._getRelation(e, t)
              : null,
            forceWeakRemove: this._forceWeakRemove,
          };
        }
        _wasUndone(t) {
          const e = this.originalOperations.get(t);
          return e.wasUndone || this._history.isUndoneOperation(e);
        }
        _getRelation(t, e) {
          const n = this.originalOperations.get(e);
          const i = this._history.getUndoneOperation(n);
          if (!i) {
            return null;
          }
          const o = this.originalOperations.get(t);
          const r = this._relations.get(o);
          if (r) {
            return r.get(i) || null;
          }
          return null;
        }
        _setRelation(t, e, n) {
          const i = this.originalOperations.get(t);
          const o = this.originalOperations.get(e);
          let r = this._relations.get(i);
          if (!r) {
            r = new Map();
            this._relations.set(i, r);
          }
          r.set(o, n);
        }
      }
      function ZC(t, e) {
        for (const n of t) {
          n.baseVersion = e++;
        }
      }
      function JC(t, e) {
        for (let n = 0; n < e; n++) {
          t.push(new Lk(0));
        }
      }
      qC(Ok, Ok, (t, e, n) => {
        if (
          t.key === e.key &&
          t.range.start.hasSameParentAs(e.range.start)
        ) {
          const i = t.range
            .getDifference(e.range)
            .map((e) => new Ok(e, t.key, t.oldValue, t.newValue, 0));
          const o = t.range.getIntersection(e.range);
          if (o) {
            if (n.aIsStrong) {
              i.push(new Ok(o, e.key, e.newValue, t.newValue, 0));
            }
          }
          if (i.length == 0) {
            return [new Lk(0)];
          }
          return i;
        } else {
          return [t];
        }
      });
      qC(Ok, Nk, (t, e) => {
        if (
          t.range.start.hasSameParentAs(e.position) &&
          t.range.containsPosition(e.position)
        ) {
          const n = t.range._getTransformedByInsertion(
            e.position,
            e.howMany,
            !e.shouldReceiveAttributes
          );
          const i = n.map(
            (e) =>
              new Ok(e, t.key, t.oldValue, t.newValue, t.baseVersion)
          );
          if (e.shouldReceiveAttributes) {
            const n = YC(e, t.key, t.oldValue);
            if (n) {
              i.unshift(n);
            }
          }
          return i;
        }
        t.range = t.range._getTransformedByInsertion(
          e.position,
          e.howMany,
          false
        )[0];
        return [t];
      });
      function YC(t, e, n) {
        const i = t.nodes;
        const o = i.getNode(0).getAttribute(e);
        if (o == n) {
          return null;
        }
        const r = new Fg(
          t.position,
          t.position.getShiftedBy(t.howMany)
        );
        return new Ok(r, e, o, n, 0);
      }
      qC(Ok, jk, (t, e) => {
        const n = [];
        if (t.range.start.hasSameParentAs(e.deletionPosition)) {
          if (
            t.range.containsPosition(e.deletionPosition) ||
            t.range.start.isEqual(e.deletionPosition)
          ) {
            n.push(
              Fg._createFromPositionAndShift(e.graveyardPosition, 1)
            );
          }
        }
        const i = t.range._getTransformedByMergeOperation(e);
        if (!i.isCollapsed) {
          n.push(i);
        }
        return n.map(
          (e) =>
            new Ok(e, t.key, t.oldValue, t.newValue, t.baseVersion)
        );
      });
      qC(Ok, Fk, (t, e) => {
        const n = QC(t.range, e);
        return n.map(
          (e) =>
            new Ok(e, t.key, t.oldValue, t.newValue, t.baseVersion)
        );
      });
      function QC(t, e) {
        const n = Fg._createFromPositionAndShift(
          e.sourcePosition,
          e.howMany
        );
        let i = null;
        let o = [];
        if (n.containsRange(t, true)) {
          i = t;
        } else if (t.start.hasSameParentAs(n.start)) {
          o = t.getDifference(n);
          i = t.getIntersection(n);
        } else {
          o = [t];
        }
        const r = [];
        for (let t of o) {
          t = t._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
          const n = e.getMovedRangeStart();
          const i = t.start.hasSameParentAs(n);
          const o = t._getTransformedByInsertion(n, e.howMany, i);
          r.push(...o);
        }
        if (i) {
          r.push(
            i._getTransformedByMove(
              e.sourcePosition,
              e.targetPosition,
              e.howMany,
              false
            )[0]
          );
        }
        return r;
      }
      qC(Ok, qk, (t, e) => {
        if (t.range.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.range.end.offset++;
          }
          return [t];
        }
        if (
          t.range.start.hasSameParentAs(e.splitPosition) &&
          t.range.containsPosition(e.splitPosition)
        ) {
          const n = t.clone();
          n.range = new Fg(
            e.moveTargetPosition.clone(),
            t.range.end._getCombined(
              e.splitPosition,
              e.moveTargetPosition
            )
          );
          t.range.end = e.splitPosition.clone();
          t.range.end.stickiness = 'toPrevious';
          return [t, n];
        }
        t.range = t.range._getTransformedBySplitOperation(e);
        return [t];
      });
      qC(Nk, Ok, (t, e) => {
        const n = [t];
        if (
          t.shouldReceiveAttributes &&
          t.position.hasSameParentAs(e.range.start) &&
          e.range.containsPosition(t.position)
        ) {
          const i = YC(t, e.key, e.newValue);
          if (i) {
            n.push(i);
          }
        }
        return n;
      });
      qC(Nk, Nk, (t, e, n) => {
        if (t.position.isEqual(e.position) && n.aIsStrong) {
          return [t];
        }
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      qC(Nk, Fk, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      qC(Nk, qk, (t, e) => {
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      qC(Nk, jk, (t, e) => {
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      qC(Mk, Nk, (t, e) => {
        if (t.oldRange) {
          t.oldRange =
            t.oldRange._getTransformedByInsertOperation(e)[0];
        }
        if (t.newRange) {
          t.newRange =
            t.newRange._getTransformedByInsertOperation(e)[0];
        }
        return [t];
      });
      qC(Mk, Mk, (t, e, n) => {
        if (t.name == e.name) {
          if (n.aIsStrong) {
            t.oldRange = e.newRange ? e.newRange.clone() : null;
          } else {
            return [new Lk(0)];
          }
        }
        return [t];
      });
      qC(Mk, jk, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByMergeOperation(e);
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      qC(Mk, Fk, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = Fg._createFromRanges(
            t.oldRange._getTransformedByMoveOperation(e)
          );
        }
        if (t.newRange) {
          if (n.abRelation) {
            const i = Fg._createFromRanges(
              t.newRange._getTransformedByMoveOperation(e)
            );
            if (
              n.abRelation.side == 'left' &&
              e.targetPosition.isEqual(t.newRange.start)
            ) {
              t.newRange.end = i.end;
              t.newRange.start.path = n.abRelation.path;
              return [t];
            } else if (
              n.abRelation.side == 'right' &&
              e.targetPosition.isEqual(t.newRange.end)
            ) {
              t.newRange.start = i.start;
              t.newRange.end.path = n.abRelation.path;
              return [t];
            }
          }
          t.newRange = Fg._createFromRanges(
            t.newRange._getTransformedByMoveOperation(e)
          );
        }
        return [t];
      });
      qC(Mk, qk, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedBySplitOperation(e);
        }
        if (t.newRange) {
          if (n.abRelation) {
            const i = t.newRange._getTransformedBySplitOperation(e);
            if (
              t.newRange.start.isEqual(e.splitPosition) &&
              n.abRelation.wasStartBeforeMergedElement
            ) {
              t.newRange.start = Ig._createAt(e.insertionPosition);
            } else if (
              t.newRange.start.isEqual(e.splitPosition) &&
              !n.abRelation.wasInLeftElement
            ) {
              t.newRange.start = Ig._createAt(e.moveTargetPosition);
            }
            if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasInRightElement
            ) {
              t.newRange.end = Ig._createAt(e.moveTargetPosition);
            } else if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasEndBeforeMergedElement
            ) {
              t.newRange.end = Ig._createAt(e.insertionPosition);
            } else {
              t.newRange.end = i.end;
            }
            return [t];
          }
          t.newRange = t.newRange._getTransformedBySplitOperation(e);
        }
        return [t];
      });
      qC(jk, Nk, (t, e) => {
        if (t.sourcePosition.hasSameParentAs(e.position)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition =
          t.sourcePosition._getTransformedByInsertOperation(e);
        t.targetPosition =
          t.targetPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      qC(jk, jk, (t, e, n) => {
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          t.targetPosition.isEqual(e.targetPosition)
        ) {
          if (!n.bWasUndone) {
            return [new Lk(0)];
          } else {
            const n = e.graveyardPosition.path.slice();
            n.push(0);
            t.sourcePosition = new Ig(e.graveyardPosition.root, n);
            t.howMany = 0;
            return [t];
          }
        }
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          !t.targetPosition.isEqual(e.targetPosition) &&
          !n.bWasUndone &&
          n.abRelation != 'splitAtSource'
        ) {
          const i = t.targetPosition.root.rootName == '$graveyard';
          const o = e.targetPosition.root.rootName == '$graveyard';
          const r = i && !o;
          const s = o && !i;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n =
              e.targetPosition._getTransformedByMergeOperation(e);
            const i =
              t.targetPosition._getTransformedByMergeOperation(e);
            return [new Fk(n, t.howMany, i, 0)];
          } else {
            return [new Lk(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition =
          t.sourcePosition._getTransformedByMergeOperation(e);
        t.targetPosition =
          t.targetPosition._getTransformedByMergeOperation(e);
        if (
          !t.graveyardPosition.isEqual(e.graveyardPosition) ||
          !n.aIsStrong
        ) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      qC(jk, Fk, (t, e, n) => {
        const i = Fg._createFromPositionAndShift(
          e.sourcePosition,
          e.howMany
        );
        if (
          e.type == 'remove' &&
          !n.bWasUndone &&
          !n.forceWeakRemove
        ) {
          if (
            t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
            i.containsPosition(t.sourcePosition)
          ) {
            return [new Lk(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
          t.howMany -= e.howMany;
        }
        t.sourcePosition =
          t.sourcePosition._getTransformedByMoveOperation(e);
        t.targetPosition =
          t.targetPosition._getTransformedByMoveOperation(e);
        if (!t.graveyardPosition.isEqual(e.targetPosition)) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        return [t];
      });
      qC(jk, qk, (t, e, n) => {
        if (e.graveyardPosition) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByDeletion(
              e.graveyardPosition,
              1
            );
          if (t.deletionPosition.isEqual(e.graveyardPosition)) {
            t.howMany = e.howMany;
          }
        }
        if (t.targetPosition.isEqual(e.splitPosition)) {
          const i = e.howMany != 0;
          const o =
            e.graveyardPosition &&
            t.deletionPosition.isEqual(e.graveyardPosition);
          if (i || o || n.abRelation == 'mergeTargetNotMoved') {
            t.sourcePosition =
              t.sourcePosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (t.sourcePosition.isEqual(e.splitPosition)) {
          if (n.abRelation == 'mergeSourceNotMoved') {
            t.howMany = 0;
            t.targetPosition =
              t.targetPosition._getTransformedBySplitOperation(e);
            return [t];
          }
          if (
            n.abRelation == 'mergeSameElement' ||
            t.sourcePosition.offset > 0
          ) {
            t.sourcePosition = e.moveTargetPosition.clone();
            t.targetPosition =
              t.targetPosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
          t.howMany = e.splitPosition.offset;
        }
        t.sourcePosition =
          t.sourcePosition._getTransformedBySplitOperation(e);
        t.targetPosition =
          t.targetPosition._getTransformedBySplitOperation(e);
        return [t];
      });
      qC(Fk, Nk, (t, e) => {
        const n = Fg._createFromPositionAndShift(
          t.sourcePosition,
          t.howMany
        );
        const i = n._getTransformedByInsertOperation(e, false)[0];
        t.sourcePosition = i.start;
        t.howMany = i.end.offset - i.start.offset;
        if (!t.targetPosition.isEqual(e.position)) {
          t.targetPosition =
            t.targetPosition._getTransformedByInsertOperation(e);
        }
        return [t];
      });
      qC(Fk, Fk, (t, e, n) => {
        const i = Fg._createFromPositionAndShift(
          t.sourcePosition,
          t.howMany
        );
        const o = Fg._createFromPositionAndShift(
          e.sourcePosition,
          e.howMany
        );
        let r = n.aIsStrong;
        let s = !n.aIsStrong;
        if (
          n.abRelation == 'insertBefore' ||
          n.baRelation == 'insertAfter'
        ) {
          s = true;
        } else if (
          n.abRelation == 'insertAfter' ||
          n.baRelation == 'insertBefore'
        ) {
          s = false;
        }
        let a;
        if (t.targetPosition.isEqual(e.targetPosition) && s) {
          a = t.targetPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
        } else {
          a = t.targetPosition._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
        }
        if (XC(t, e) && XC(e, t)) {
          return [e.getReversed()];
        }
        const c = i.containsPosition(e.targetPosition);
        if (c && i.containsRange(o, true)) {
          i.start = i.start._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          i.end = i.end._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          return ty([i], a);
        }
        const l = o.containsPosition(t.targetPosition);
        if (l && o.containsRange(i, true)) {
          i.start = i.start._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart()
          );
          i.end = i.end._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart()
          );
          return ty([i], a);
        }
        const d = Ha(
          t.sourcePosition.getParentPath(),
          e.sourcePosition.getParentPath()
        );
        if (d == 'prefix' || d == 'extension') {
          i.start = i.start._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          i.end = i.end._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          return ty([i], a);
        }
        if (
          t.type == 'remove' &&
          e.type != 'remove' &&
          !n.aWasUndone &&
          !n.forceWeakRemove
        ) {
          r = true;
        } else if (
          t.type != 'remove' &&
          e.type == 'remove' &&
          !n.bWasUndone &&
          !n.forceWeakRemove
        ) {
          r = false;
        }
        const h = [];
        const u = i.getDifference(o);
        for (const t of u) {
          t.start = t.start._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
          t.end = t.end._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
          const n =
            Ha(
              t.start.getParentPath(),
              e.getMovedRangeStart().getParentPath()
            ) == 'same';
          const i = t._getTransformedByInsertion(
            e.getMovedRangeStart(),
            e.howMany,
            n
          );
          h.push(...i);
        }
        const f = i.getIntersection(o);
        if (f !== null && r) {
          f.start = f.start._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart()
          );
          f.end = f.end._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart()
          );
          if (h.length === 0) {
            h.push(f);
          } else if (h.length == 1) {
            if (
              o.start.isBefore(i.start) ||
              o.start.isEqual(i.start)
            ) {
              h.unshift(f);
            } else {
              h.push(f);
            }
          } else {
            h.splice(1, 0, f);
          }
        }
        if (h.length === 0) {
          return [new Lk(t.baseVersion)];
        }
        return ty(h, a);
      });
      qC(Fk, qk, (t, e, n) => {
        let i = t.targetPosition.clone();
        if (
          !t.targetPosition.isEqual(e.insertionPosition) ||
          !e.graveyardPosition ||
          n.abRelation == 'moveTargetAfter'
        ) {
          i = t.targetPosition._getTransformedBySplitOperation(e);
        }
        const o = Fg._createFromPositionAndShift(
          t.sourcePosition,
          t.howMany
        );
        if (o.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.howMany++;
          }
          t.targetPosition = i;
          return [t];
        }
        if (
          o.start.hasSameParentAs(e.splitPosition) &&
          o.containsPosition(e.splitPosition)
        ) {
          let t = new Fg(e.splitPosition, o.end);
          t = t._getTransformedBySplitOperation(e);
          const n = [new Fg(o.start, e.splitPosition), t];
          return ty(n, i);
        }
        if (
          t.targetPosition.isEqual(e.splitPosition) &&
          n.abRelation == 'insertAtSource'
        ) {
          i = e.moveTargetPosition;
        }
        if (
          t.targetPosition.isEqual(e.insertionPosition) &&
          n.abRelation == 'insertBetween'
        ) {
          i = t.targetPosition;
        }
        const r = o._getTransformedBySplitOperation(e);
        const s = [r];
        if (e.graveyardPosition) {
          const i =
            o.start.isEqual(e.graveyardPosition) ||
            o.containsPosition(e.graveyardPosition);
          if (t.howMany > 1 && i && !n.aWasUndone) {
            s.push(
              Fg._createFromPositionAndShift(e.insertionPosition, 1)
            );
          }
        }
        return ty(s, i);
      });
      qC(Fk, jk, (t, e, n) => {
        const i = Fg._createFromPositionAndShift(
          t.sourcePosition,
          t.howMany
        );
        if (
          e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
          i.containsPosition(e.sourcePosition)
        ) {
          if (t.type == 'remove' && !n.forceWeakRemove) {
            if (!n.aWasUndone) {
              const n = [];
              let i = e.graveyardPosition.clone();
              let o =
                e.targetPosition._getTransformedByMergeOperation(e);
              if (t.howMany > 1) {
                n.push(
                  new Fk(
                    t.sourcePosition,
                    t.howMany - 1,
                    t.targetPosition,
                    0
                  )
                );
                i = i._getTransformedByMove(
                  t.sourcePosition,
                  t.targetPosition,
                  t.howMany - 1
                );
                o = o._getTransformedByMove(
                  t.sourcePosition,
                  t.targetPosition,
                  t.howMany - 1
                );
              }
              const r = e.deletionPosition._getCombined(
                t.sourcePosition,
                t.targetPosition
              );
              const s = new Fk(i, 1, r, 0);
              const a = s.getMovedRangeStart().path.slice();
              a.push(0);
              const c = new Ig(s.targetPosition.root, a);
              o = o._getTransformedByMove(i, r, 1);
              const l = new Fk(o, e.howMany, c, 0);
              n.push(s);
              n.push(l);
              return n;
            }
          } else {
            if (t.howMany == 1) {
              if (!n.bWasUndone) {
                return [new Lk(0)];
              } else {
                t.sourcePosition = e.graveyardPosition.clone();
                t.targetPosition =
                  t.targetPosition._getTransformedByMergeOperation(e);
                return [t];
              }
            }
          }
        }
        const o = Fg._createFromPositionAndShift(
          t.sourcePosition,
          t.howMany
        );
        const r = o._getTransformedByMergeOperation(e);
        t.sourcePosition = r.start;
        t.howMany = r.end.offset - r.start.offset;
        t.targetPosition =
          t.targetPosition._getTransformedByMergeOperation(e);
        return [t];
      });
      qC(Vk, Nk, (t, e) => {
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      qC(Vk, jk, (t, e) => {
        if (t.position.isEqual(e.deletionPosition)) {
          t.position = e.graveyardPosition.clone();
          t.position.stickiness = 'toNext';
          return [t];
        }
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      qC(Vk, Fk, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      qC(Vk, Vk, (t, e, n) => {
        if (t.position.isEqual(e.position)) {
          if (n.aIsStrong) {
            t.oldName = e.newName;
          } else {
            return [new Lk(0)];
          }
        }
        return [t];
      });
      qC(Vk, qk, (t, e) => {
        const n = t.position.path;
        const i = e.splitPosition.getParentPath();
        if (Ha(n, i) == 'same' && !e.graveyardPosition) {
          const e = new Vk(
            t.position.getShiftedBy(1),
            t.oldName,
            t.newName,
            0
          );
          return [t, e];
        }
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      qC(Hk, Hk, (t, e, n) => {
        if (t.root === e.root && t.key === e.key) {
          if (!n.aIsStrong || t.newValue === e.newValue) {
            return [new Lk(0)];
          } else {
            t.oldValue = e.newValue;
          }
        }
        return [t];
      });
      qC(qk, Nk, (t, e) => {
        if (
          t.splitPosition.hasSameParentAs(e.position) &&
          t.splitPosition.offset < e.position.offset
        ) {
          t.howMany += e.howMany;
        }
        t.splitPosition =
          t.splitPosition._getTransformedByInsertOperation(e);
        t.insertionPosition =
          t.insertionPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      qC(qk, jk, (t, e, n) => {
        if (
          !t.graveyardPosition &&
          !n.bWasUndone &&
          t.splitPosition.hasSameParentAs(e.sourcePosition)
        ) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const i = new Ig(e.graveyardPosition.root, n);
          const o = qk.getInsertionPosition(
            new Ig(e.graveyardPosition.root, n)
          );
          const r = new qk(i, 0, o, null, 0);
          t.splitPosition =
            t.splitPosition._getTransformedByMergeOperation(e);
          t.insertionPosition = qk.getInsertionPosition(
            t.splitPosition
          );
          t.graveyardPosition = r.insertionPosition.clone();
          t.graveyardPosition.stickiness = 'toNext';
          return [r, t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.deletionPosition) &&
          !t.splitPosition.isAfter(e.deletionPosition)
        ) {
          t.howMany--;
        }
        if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.splitPosition =
          t.splitPosition._getTransformedByMergeOperation(e);
        t.insertionPosition = qk.getInsertionPosition(
          t.splitPosition
        );
        if (t.graveyardPosition) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      qC(qk, Fk, (t, e, n) => {
        const i = Fg._createFromPositionAndShift(
          e.sourcePosition,
          e.howMany
        );
        if (t.graveyardPosition) {
          const o =
            i.start.isEqual(t.graveyardPosition) ||
            i.containsPosition(t.graveyardPosition);
          if (!n.bWasUndone && o) {
            const n =
              t.splitPosition._getTransformedByMoveOperation(e);
            const i =
              t.graveyardPosition._getTransformedByMoveOperation(e);
            const o = i.path.slice();
            o.push(0);
            const r = new Ig(i.root, o);
            const s = new Fk(n, t.howMany, r, 0);
            return [s];
          }
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        const o = t.splitPosition.isEqual(e.targetPosition);
        if (
          o &&
          (n.baRelation == 'insertAtSource' ||
            n.abRelation == 'splitBefore')
        ) {
          t.howMany += e.howMany;
          t.splitPosition = t.splitPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
          t.insertionPosition = qk.getInsertionPosition(
            t.splitPosition
          );
          return [t];
        }
        if (o && n.abRelation && n.abRelation.howMany) {
          const { howMany: e, offset: i } = n.abRelation;
          t.howMany += e;
          t.splitPosition = t.splitPosition.getShiftedBy(i);
          return [t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.sourcePosition) &&
          i.containsPosition(t.splitPosition)
        ) {
          const n =
            e.howMany -
            (t.splitPosition.offset - e.sourcePosition.offset);
          t.howMany -= n;
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
          t.splitPosition = e.sourcePosition.clone();
          t.insertionPosition = qk.getInsertionPosition(
            t.splitPosition
          );
          return [t];
        }
        if (!e.sourcePosition.isEqual(e.targetPosition)) {
          if (
            t.splitPosition.hasSameParentAs(e.sourcePosition) &&
            t.splitPosition.offset <= e.sourcePosition.offset
          ) {
            t.howMany -= e.howMany;
          }
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
        }
        t.splitPosition.stickiness = 'toNone';
        t.splitPosition =
          t.splitPosition._getTransformedByMoveOperation(e);
        t.splitPosition.stickiness = 'toNext';
        if (t.graveyardPosition) {
          t.insertionPosition =
            t.insertionPosition._getTransformedByMoveOperation(e);
        } else {
          t.insertionPosition = qk.getInsertionPosition(
            t.splitPosition
          );
        }
        return [t];
      });
      qC(qk, qk, (t, e, n) => {
        if (t.splitPosition.isEqual(e.splitPosition)) {
          if (!t.graveyardPosition && !e.graveyardPosition) {
            return [new Lk(0)];
          }
          if (
            t.graveyardPosition &&
            e.graveyardPosition &&
            t.graveyardPosition.isEqual(e.graveyardPosition)
          ) {
            return [new Lk(0)];
          }
          if (n.abRelation == 'splitBefore') {
            t.howMany = 0;
            t.graveyardPosition =
              t.graveyardPosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (
          t.graveyardPosition &&
          e.graveyardPosition &&
          t.graveyardPosition.isEqual(e.graveyardPosition)
        ) {
          const i = t.splitPosition.root.rootName == '$graveyard';
          const o = e.splitPosition.root.rootName == '$graveyard';
          const r = i && !o;
          const s = o && !i;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = [];
            if (e.howMany) {
              n.push(
                new Fk(
                  e.moveTargetPosition,
                  e.howMany,
                  e.splitPosition,
                  0
                )
              );
            }
            if (t.howMany) {
              n.push(
                new Fk(
                  t.splitPosition,
                  t.howMany,
                  t.moveTargetPosition,
                  0
                )
              );
            }
            return n;
          } else {
            return [new Lk(0)];
          }
        }
        if (t.graveyardPosition) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedBySplitOperation(e);
        }
        if (
          t.splitPosition.isEqual(e.insertionPosition) &&
          n.abRelation == 'splitBefore'
        ) {
          t.howMany++;
          return [t];
        }
        if (
          e.splitPosition.isEqual(t.insertionPosition) &&
          n.baRelation == 'splitBefore'
        ) {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const i = new Ig(e.insertionPosition.root, n);
          const o = new Fk(t.insertionPosition, 1, i, 0);
          return [t, o];
        }
        if (
          t.splitPosition.hasSameParentAs(e.splitPosition) &&
          t.splitPosition.offset < e.splitPosition.offset
        ) {
          t.howMany -= e.howMany;
        }
        t.splitPosition =
          t.splitPosition._getTransformedBySplitOperation(e);
        t.insertionPosition = qk.getInsertionPosition(
          t.splitPosition
        );
        return [t];
      });
      function XC(t, e) {
        return (
          t.targetPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          ) === null
        );
      }
      function ty(t, e) {
        const n = [];
        for (let i = 0; i < t.length; i++) {
          const o = t[i];
          const r = new Fk(
            o.start,
            o.end.offset - o.start.offset,
            e,
            0
          );
          n.push(r);
          for (let e = i + 1; e < t.length; e++) {
            t[e] = t[e]._getTransformedByMove(
              r.sourcePosition,
              r.targetPosition,
              r.howMany
            )[0];
          }
          e = e._getTransformedByMove(
            r.sourcePosition,
            r.targetPosition,
            r.howMany
          );
        }
        return n;
      }
      class ey extends Af {
        constructor(t) {
          super(t);
          this.domEventType = 'click';
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class ny extends Af {
        constructor(t) {
          super(t);
          this.domEventType = [
            'mousedown',
            'mouseup',
            'mouseover',
            'mouseout',
          ];
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class iy {
        constructor(t) {
          this.document = t;
        }
        createDocumentFragment(t) {
          return new nh(this.document, t);
        }
        createElement(t, e, n) {
          return new Kl(this.document, t, e, n);
        }
        createText(t) {
          return new Ga(this.document, t);
        }
        clone(t, e = false) {
          return t._clone(e);
        }
        appendChild(t, e) {
          return e._appendChild(t);
        }
        insertChild(t, e, n) {
          return n._insertChild(t, e);
        }
        removeChildren(t, e, n) {
          return n._removeChildren(t, e);
        }
        remove(t) {
          const e = t.parent;
          if (e) {
            return this.removeChildren(e.getChildIndex(t), 1, e);
          }
          return [];
        }
        replace(t, e) {
          const n = t.parent;
          if (n) {
            const i = n.getChildIndex(t);
            this.removeChildren(i, 1, n);
            this.insertChild(i, e, n);
            return true;
          }
          return false;
        }
        unwrapElement(t) {
          const e = t.parent;
          if (e) {
            const n = e.getChildIndex(t);
            this.remove(t);
            this.insertChild(n, t.getChildren(), e);
          }
        }
        rename(t, e) {
          const n = new Kl(
            this.document,
            t,
            e.getAttributes(),
            e.getChildren()
          );
          return this.replace(e, n) ? n : null;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (jt(t) && n === undefined) {
            e._setStyle(t);
          } else {
            n._setStyle(t, e);
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        createPositionAt(t, e) {
          return od._createAt(t, e);
        }
        createPositionAfter(t) {
          return od._createAfter(t);
        }
        createPositionBefore(t) {
          return od._createBefore(t);
        }
        createRange(t, e) {
          return new rd(t, e);
        }
        createRangeOn(t) {
          return rd._createOn(t);
        }
        createRangeIn(t) {
          return rd._createIn(t);
        }
        createSelection(...t) {
          return new cd(...t);
        }
      }
      const oy = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
      const ry =
        /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
      const sy =
        /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
      const ay =
        /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
      const cy =
        /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
      const ly = new Set([
        'black',
        'silver',
        'gray',
        'white',
        'maroon',
        'red',
        'purple',
        'fuchsia',
        'green',
        'lime',
        'olive',
        'yellow',
        'navy',
        'blue',
        'teal',
        'aqua',
        'orange',
        'aliceblue',
        'antiquewhite',
        'aquamarine',
        'azure',
        'beige',
        'bisque',
        'blanchedalmond',
        'blueviolet',
        'brown',
        'burlywood',
        'cadetblue',
        'chartreuse',
        'chocolate',
        'coral',
        'cornflowerblue',
        'cornsilk',
        'crimson',
        'cyan',
        'darkblue',
        'darkcyan',
        'darkgoldenrod',
        'darkgray',
        'darkgreen',
        'darkgrey',
        'darkkhaki',
        'darkmagenta',
        'darkolivegreen',
        'darkorange',
        'darkorchid',
        'darkred',
        'darksalmon',
        'darkseagreen',
        'darkslateblue',
        'darkslategray',
        'darkslategrey',
        'darkturquoise',
        'darkviolet',
        'deeppink',
        'deepskyblue',
        'dimgray',
        'dimgrey',
        'dodgerblue',
        'firebrick',
        'floralwhite',
        'forestgreen',
        'gainsboro',
        'ghostwhite',
        'gold',
        'goldenrod',
        'greenyellow',
        'grey',
        'honeydew',
        'hotpink',
        'indianred',
        'indigo',
        'ivory',
        'khaki',
        'lavender',
        'lavenderblush',
        'lawngreen',
        'lemonchiffon',
        'lightblue',
        'lightcoral',
        'lightcyan',
        'lightgoldenrodyellow',
        'lightgray',
        'lightgreen',
        'lightgrey',
        'lightpink',
        'lightsalmon',
        'lightseagreen',
        'lightskyblue',
        'lightslategray',
        'lightslategrey',
        'lightsteelblue',
        'lightyellow',
        'limegreen',
        'linen',
        'magenta',
        'mediumaquamarine',
        'mediumblue',
        'mediumorchid',
        'mediumpurple',
        'mediumseagreen',
        'mediumslateblue',
        'mediumspringgreen',
        'mediumturquoise',
        'mediumvioletred',
        'midnightblue',
        'mintcream',
        'mistyrose',
        'moccasin',
        'navajowhite',
        'oldlace',
        'olivedrab',
        'orangered',
        'orchid',
        'palegoldenrod',
        'palegreen',
        'paleturquoise',
        'palevioletred',
        'papayawhip',
        'peachpuff',
        'peru',
        'pink',
        'plum',
        'powderblue',
        'rosybrown',
        'royalblue',
        'saddlebrown',
        'salmon',
        'sandybrown',
        'seagreen',
        'seashell',
        'sienna',
        'skyblue',
        'slateblue',
        'slategray',
        'slategrey',
        'snow',
        'springgreen',
        'steelblue',
        'tan',
        'thistle',
        'tomato',
        'turquoise',
        'violet',
        'wheat',
        'whitesmoke',
        'yellowgreen',
        'activeborder',
        'activecaption',
        'appworkspace',
        'background',
        'buttonface',
        'buttonhighlight',
        'buttonshadow',
        'buttontext',
        'captiontext',
        'graytext',
        'highlight',
        'highlighttext',
        'inactiveborder',
        'inactivecaption',
        'inactivecaptiontext',
        'infobackground',
        'infotext',
        'menu',
        'menutext',
        'scrollbar',
        'threeddarkshadow',
        'threedface',
        'threedhighlight',
        'threedlightshadow',
        'threedshadow',
        'window',
        'windowframe',
        'windowtext',
        'rebeccapurple',
        'currentcolor',
        'transparent',
      ]);
      function dy(t) {
        if (t.startsWith('#')) {
          return oy.test(t);
        }
        if (t.startsWith('rgb')) {
          return ry.test(t) || sy.test(t);
        }
        if (t.startsWith('hsl')) {
          return ay.test(t) || cy.test(t);
        }
        return ly.has(t.toLowerCase());
      }
      const hy = null && [
        'none',
        'hidden',
        'dotted',
        'dashed',
        'solid',
        'double',
        'groove',
        'ridge',
        'inset',
        'outset',
      ];
      function uy(t) {
        return hy.includes(t);
      }
      const fy =
        /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
      function gy(t) {
        return fy.test(t);
      }
      const my = /^[+-]?[0-9]*([.][0-9]+)?%$/;
      function py(t) {
        return my.test(t);
      }
      const ky = [
        'repeat-x',
        'repeat-y',
        'repeat',
        'space',
        'round',
        'no-repeat',
      ];
      function by(t) {
        return ky.includes(t);
      }
      const wy = ['center', 'top', 'bottom', 'left', 'right'];
      function _y(t) {
        return wy.includes(t);
      }
      const vy = ['fixed', 'scroll', 'local'];
      function Ay(t) {
        return vy.includes(t);
      }
      const Cy = /^url\(/;
      function yy(t) {
        return Cy.test(t);
      }
      function xy(t = '') {
        if (t === '') {
          return {
            top: undefined,
            right: undefined,
            bottom: undefined,
            left: undefined,
          };
        }
        const e = Ty(t);
        const n = e[0];
        const i = e[2] || n;
        const o = e[1] || n;
        const r = e[3] || o;
        return { top: n, bottom: i, right: o, left: r };
      }
      function Ey(t) {
        return (e) => {
          const { top: n, right: i, bottom: o, left: r } = e;
          const s = [];
          if (![n, i, r, o].every((t) => !!t)) {
            if (n) {
              s.push([t + '-top', n]);
            }
            if (i) {
              s.push([t + '-right', i]);
            }
            if (o) {
              s.push([t + '-bottom', o]);
            }
            if (r) {
              s.push([t + '-left', r]);
            }
          } else {
            s.push([t, Dy(e)]);
          }
          return s;
        };
      }
      function Dy({ top: t, right: e, bottom: n, left: i }) {
        const o = [];
        if (i !== e) {
          o.push(t, e, n, i);
        } else if (n !== t) {
          o.push(t, e, n);
        } else if (e !== t) {
          o.push(t, e);
        } else {
          o.push(t);
        }
        return o.join(' ');
      }
      function Sy(t) {
        return (e) => ({ path: t, value: xy(e) });
      }
      function Ty(t) {
        return t
          .replace(/, /g, ',')
          .split(' ')
          .map((t) => t.replace(/,/g, ', '));
      }
      function By(t) {
        t.setNormalizer('background', Py());
        t.setNormalizer('background-color', Iy());
        t.setReducer('background', Ry());
        t.setStyleRelation('background', ['background-color']);
      }
      function Py() {
        return (t) => {
          const e = {};
          const n = Ty(t);
          for (const t of n) {
            if (by(t)) {
              e.repeat = e.repeat || [];
              e.repeat.push(t);
            } else if (_y(t)) {
              e.position = e.position || [];
              e.position.push(t);
            } else if (Ay(t)) {
              e.attachment = t;
            } else if (dy(t)) {
              e.color = t;
            } else if (yy(t)) {
              e.image = t;
            }
          }
          return { path: 'background', value: e };
        };
      }
      function Iy() {
        return (t) => ({ path: 'background.color', value: t });
      }
      function Ry() {
        return (t) => {
          const e = [];
          e.push(['background-color', t.color]);
          return e;
        };
      }
      function zy(t) {
        t.setNormalizer('border', Oy());
        t.setNormalizer('border-top', Fy('top'));
        t.setNormalizer('border-right', Fy('right'));
        t.setNormalizer('border-bottom', Fy('bottom'));
        t.setNormalizer('border-left', Fy('left'));
        t.setNormalizer('border-color', Ny('color'));
        t.setNormalizer('border-width', Ny('width'));
        t.setNormalizer('border-style', Ny('style'));
        t.setNormalizer('border-top-color', Ly('color', 'top'));
        t.setNormalizer('border-top-style', Ly('style', 'top'));
        t.setNormalizer('border-top-width', Ly('width', 'top'));
        t.setNormalizer('border-right-color', Ly('color', 'right'));
        t.setNormalizer('border-right-style', Ly('style', 'right'));
        t.setNormalizer('border-right-width', Ly('width', 'right'));
        t.setNormalizer('border-bottom-color', Ly('color', 'bottom'));
        t.setNormalizer('border-bottom-style', Ly('style', 'bottom'));
        t.setNormalizer('border-bottom-width', Ly('width', 'bottom'));
        t.setNormalizer('border-left-color', Ly('color', 'left'));
        t.setNormalizer('border-left-style', Ly('style', 'left'));
        t.setNormalizer('border-left-width', Ly('width', 'left'));
        t.setExtractor('border-top', Vy('top'));
        t.setExtractor('border-right', Vy('right'));
        t.setExtractor('border-bottom', Vy('bottom'));
        t.setExtractor('border-left', Vy('left'));
        t.setExtractor('border-top-color', 'border.color.top');
        t.setExtractor('border-right-color', 'border.color.right');
        t.setExtractor('border-bottom-color', 'border.color.bottom');
        t.setExtractor('border-left-color', 'border.color.left');
        t.setExtractor('border-top-width', 'border.width.top');
        t.setExtractor('border-right-width', 'border.width.right');
        t.setExtractor('border-bottom-width', 'border.width.bottom');
        t.setExtractor('border-left-width', 'border.width.left');
        t.setExtractor('border-top-style', 'border.style.top');
        t.setExtractor('border-right-style', 'border.style.right');
        t.setExtractor('border-bottom-style', 'border.style.bottom');
        t.setExtractor('border-left-style', 'border.style.left');
        t.setReducer(
          'border-color',
          getBoxSidesValueReducer('border-color')
        );
        t.setReducer(
          'border-style',
          getBoxSidesValueReducer('border-style')
        );
        t.setReducer(
          'border-width',
          getBoxSidesValueReducer('border-width')
        );
        t.setReducer('border-top', Wy('top'));
        t.setReducer('border-right', Wy('right'));
        t.setReducer('border-bottom', Wy('bottom'));
        t.setReducer('border-left', Wy('left'));
        t.setReducer('border', qy());
        t.setStyleRelation('border', [
          'border-color',
          'border-style',
          'border-width',
          'border-top',
          'border-right',
          'border-bottom',
          'border-left',
          'border-top-color',
          'border-right-color',
          'border-bottom-color',
          'border-left-color',
          'border-top-style',
          'border-right-style',
          'border-bottom-style',
          'border-left-style',
          'border-top-width',
          'border-right-width',
          'border-bottom-width',
          'border-left-width',
        ]);
        t.setStyleRelation('border-color', [
          'border-top-color',
          'border-right-color',
          'border-bottom-color',
          'border-left-color',
        ]);
        t.setStyleRelation('border-style', [
          'border-top-style',
          'border-right-style',
          'border-bottom-style',
          'border-left-style',
        ]);
        t.setStyleRelation('border-width', [
          'border-top-width',
          'border-right-width',
          'border-bottom-width',
          'border-left-width',
        ]);
        t.setStyleRelation('border-top', [
          'border-top-color',
          'border-top-style',
          'border-top-width',
        ]);
        t.setStyleRelation('border-right', [
          'border-right-color',
          'border-right-style',
          'border-right-width',
        ]);
        t.setStyleRelation('border-bottom', [
          'border-bottom-color',
          'border-bottom-style',
          'border-bottom-width',
        ]);
        t.setStyleRelation('border-left', [
          'border-left-color',
          'border-left-style',
          'border-left-width',
        ]);
      }
      function Oy() {
        return (t) => {
          const { color: e, style: n, width: i } = jy(t);
          return {
            path: 'border',
            value: {
              color: getBoxSidesValues(e),
              style: getBoxSidesValues(n),
              width: getBoxSidesValues(i),
            },
          };
        };
      }
      function Fy(t) {
        return (e) => {
          const { color: n, style: i, width: o } = jy(e);
          const r = {};
          if (n !== undefined) {
            r.color = { [t]: n };
          }
          if (i !== undefined) {
            r.style = { [t]: i };
          }
          if (o !== undefined) {
            r.width = { [t]: o };
          }
          return { path: 'border', value: r };
        };
      }
      function Ny(t) {
        return (e) => ({ path: 'border', value: My(e, t) });
      }
      function My(t, e) {
        return { [e]: getBoxSidesValues(t) };
      }
      function Ly(t, e) {
        return (n) => ({
          path: 'border',
          value: { [t]: { [e]: n } },
        });
      }
      function Vy(t) {
        return (e, n) => {
          if (n.border) {
            return Hy(n.border, t);
          }
        };
      }
      function Hy(t, e) {
        const n = {};
        if (t.width && t.width[e]) {
          n.width = t.width[e];
        }
        if (t.style && t.style[e]) {
          n.style = t.style[e];
        }
        if (t.color && t.color[e]) {
          n.color = t.color[e];
        }
        return n;
      }
      function jy(t) {
        const e = {};
        const n = getShorthandValues(t);
        for (const t of n) {
          if (isLength(t) || /thin|medium|thick/.test(t)) {
            e.width = t;
          } else if (isLineStyle(t)) {
            e.style = t;
          } else {
            e.color = t;
          }
        }
        return e;
      }
      function qy() {
        return (e) => {
          const n = Hy(e, 'top');
          const i = Hy(e, 'right');
          const o = Hy(e, 'bottom');
          const r = Hy(e, 'left');
          const s = [n, i, o, r];
          const a = {
            width: t(s, 'width'),
            style: t(s, 'style'),
            color: t(s, 'color'),
          };
          const c = Uy(a, 'all');
          if (c.length) {
            return c;
          }
          const l = Object.entries(a).reduce((t, [e, n]) => {
            if (n) {
              t.push([`border-${e}`, n]);
              s.forEach((t) => delete t[e]);
            }
            return t;
          }, []);
          return [
            ...l,
            ...Uy(n, 'top'),
            ...Uy(i, 'right'),
            ...Uy(o, 'bottom'),
            ...Uy(r, 'left'),
          ];
        };
        function t(t, e) {
          return t
            .map((t) => t[e])
            .reduce((t, e) => (t == e ? t : null));
        }
      }
      function Wy(t) {
        return (e) => Uy(e, t);
      }
      function Uy(t, e) {
        const n = [];
        if (t && t.width) {
          n.push('width');
        }
        if (t && t.style) {
          n.push('style');
        }
        if (t && t.color) {
          n.push('color');
        }
        if (n.length == 3) {
          const i = n.map((e) => t[e]).join(' ');
          return [e == 'all' ? ['border', i] : [`border-${e}`, i]];
        }
        if (e == 'all') {
          return [];
        }
        return n.map((n) => [`border-${e}-${n}`, t[n]]);
      }
      function Gy(t) {
        t.setNormalizer('margin', Sy('margin'));
        t.setNormalizer('margin-top', (t) => ({
          path: 'margin.top',
          value: t,
        }));
        t.setNormalizer('margin-right', (t) => ({
          path: 'margin.right',
          value: t,
        }));
        t.setNormalizer('margin-bottom', (t) => ({
          path: 'margin.bottom',
          value: t,
        }));
        t.setNormalizer('margin-left', (t) => ({
          path: 'margin.left',
          value: t,
        }));
        t.setReducer('margin', Ey('margin'));
        t.setStyleRelation('margin', [
          'margin-top',
          'margin-right',
          'margin-bottom',
          'margin-left',
        ]);
      }
      function $y(t) {
        t.setNormalizer(
          'padding',
          getPositionShorthandNormalizer('padding')
        );
        t.setNormalizer('padding-top', (t) => ({
          path: 'padding.top',
          value: t,
        }));
        t.setNormalizer('padding-right', (t) => ({
          path: 'padding.right',
          value: t,
        }));
        t.setNormalizer('padding-bottom', (t) => ({
          path: 'padding.bottom',
          value: t,
        }));
        t.setNormalizer('padding-left', (t) => ({
          path: 'padding.left',
          value: t,
        }));
        t.setReducer('padding', getBoxSidesValueReducer('padding'));
        t.setStyleRelation('padding', [
          'padding-top',
          'padding-right',
          'padding-bottom',
          'padding-left',
        ]);
      }
      class Ky extends Xw {
        constructor(t, e) {
          super(t);
          this.view = e;
          this._toolbarConfig = Nv(t.config.get('toolbar'));
          this._elementReplacer = new Zf();
        }
        get element() {
          return this.view.element;
        }
        init(t) {
          const e = this.editor;
          const n = this.view;
          const i = e.editing.view;
          const o = n.editable;
          const r = i.document.getRoot();
          o.name = r.rootName;
          n.render();
          const s = o.element;
          this.setEditableElement(o.name, s);
          n.editable.bind('isFocused').to(this.focusTracker);
          i.attachDomRoot(s);
          if (t) {
            this._elementReplacer.replace(t, this.element);
          }
          this._initPlaceholder();
          this._initToolbar();
          this.fire('ready');
        }
        destroy() {
          const t = this.view;
          const e = this.editor.editing.view;
          this._elementReplacer.restore();
          e.detachDomRoot(t.editable.name);
          t.destroy();
          super.destroy();
        }
        _initToolbar() {
          const t = this.view;
          t.stickyPanel
            .bind('isActive')
            .to(this.focusTracker, 'isFocused');
          t.stickyPanel.limiterElement = t.element;
          t.stickyPanel
            .bind('viewportTopOffset')
            .to(this, 'viewportOffset', ({ top: t }) => t);
          t.toolbar.fillFromConfig(
            this._toolbarConfig,
            this.componentFactory
          );
          this.addToolbar(t.toolbar);
        }
        _initPlaceholder() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document.getRoot();
          const i = t.sourceElement;
          const o =
            t.config.get('placeholder') ||
            (i &&
              i.tagName.toLowerCase() === 'textarea' &&
              i.getAttribute('placeholder'));
          if (o) {
            zC({
              view: e,
              element: n,
              text: o,
              isDirectHost: false,
              keepOnFocus: true,
            });
          }
        }
      }
      var Zy = n(3638);
      var Jy = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Jy.insert = 'head';
      Jy.singleton = true;
      var Yy = Lh()(Zy.Z, Jy);
      const Qy = Zy.Z.locals || {};
      class Xy extends xA {
        constructor(t, e, n = {}) {
          super(t);
          this.stickyPanel = new kC(t);
          this.toolbar = new jv(t, {
            shouldGroupWhenFull: n.shouldToolbarGroupWhenFull,
          });
          this.editable = new DA(t, e);
        }
        render() {
          super.render();
          this.stickyPanel.content.add(this.toolbar);
          this.top.add(this.stickyPanel);
          this.main.add(this.editable);
        }
      }
      class tx extends Ub {
        constructor(t, e = {}) {
          if (!wa(t) && e.initialData !== undefined) {
            throw new h('editor-create-initial-data', null);
          }
          super(e);
          if (this.config.get('initialData') === undefined) {
            this.config.set('initialData', ex(t));
          }
          if (wa(t)) {
            this.sourceElement = t;
          }
          this.model.document.createRoot();
          const n = !this.config.get(
            'toolbar.shouldNotGroupWhenFull'
          );
          const i = new Xy(this.locale, this.editing.view, {
            shouldToolbarGroupWhenFull: n,
          });
          this.ui = new Ky(this, i);
          e_(this);
        }
        destroy() {
          if (this.sourceElement) {
            this.updateSourceElement();
          }
          this.ui.destroy();
          return super.destroy();
        }
        static create(t, e = {}) {
          return new Promise((n) => {
            const i = new this(t, e);
            n(
              i
                .initPlugins()
                .then(() => i.ui.init(wa(t) ? t : null))
                .then(() => i.data.init(i.config.get('initialData')))
                .then(() => i.fire('ready'))
                .then(() => i)
            );
          });
        }
      }
      et(tx, i_);
      et(tx, s_);
      function ex(t) {
        return wa(t) ? Jf(t) : t;
      }
      const nx = ['left', 'right', 'center', 'justify'];
      function ix(t) {
        return nx.includes(t);
      }
      function ox(t, e) {
        if (e.contentLanguageDirection == 'rtl') {
          return t === 'right';
        } else {
          return t === 'left';
        }
      }
      function rx(t) {
        const e = t
          .map((t) => {
            let e;
            if (typeof t == 'string') {
              e = { name: t };
            } else {
              e = t;
            }
            return e;
          })
          .filter((t) => {
            const e = !!nx.includes(t.name);
            if (!e) {
              u('alignment-config-name-not-recognized', {
                option: t,
              });
            }
            return e;
          });
        const n = e.filter((t) => !!t.className).length;
        if (n && n < e.length) {
          throw new h('alignment-config-classnames-are-missing', {
            configuredOptions: t,
          });
        }
        e.forEach((e, n, i) => {
          const o = i.slice(n + 1);
          const r = o.some((t) => t.name == e.name);
          if (r) {
            throw new h('alignment-config-name-already-defined', {
              option: e,
              configuredOptions: t,
            });
          }
          if (e.className) {
            const n = o.some((t) => t.className == e.className);
            if (n) {
              throw new h(
                'alignment-config-classname-already-defined',
                { option: e, configuredOptions: t }
              );
            }
          }
        });
        return e;
      }
      const sx = 'alignment';
      class ax extends ot {
        refresh() {
          const t = this.editor;
          const e = t.locale;
          const n = Xf(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          this.isEnabled = !!n && this._canBeAligned(n);
          if (this.isEnabled && n.hasAttribute('alignment')) {
            this.value = n.getAttribute('alignment');
          } else {
            this.value =
              e.contentLanguageDirection === 'rtl' ? 'right' : 'left';
          }
        }
        execute(t = {}) {
          const e = this.editor;
          const n = e.locale;
          const i = e.model;
          const o = i.document;
          const r = t.value;
          i.change((t) => {
            const e = Array.from(
              o.selection.getSelectedBlocks()
            ).filter((t) => this._canBeAligned(t));
            const i = e[0].getAttribute('alignment');
            const s = ox(r, n) || i === r || !r;
            if (s) {
              cx(e, t);
            } else {
              lx(e, t, r);
            }
          });
        }
        _canBeAligned(t) {
          return this.editor.model.schema.checkAttribute(t, sx);
        }
      }
      function cx(t, e) {
        for (const n of t) {
          e.removeAttribute(sx, n);
        }
      }
      function lx(t, e, n) {
        for (const i of t) {
          e.setAttribute(sx, n, i);
        }
      }
      class dx extends nt {
        static get pluginName() {
          return 'AlignmentEditing';
        }
        constructor(t) {
          super(t);
          t.config.define('alignment', {
            options: [...nx.map((t) => ({ name: t }))],
          });
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.model.schema;
          const i = rx(t.config.get('alignment.options'));
          const o = i.filter((t) => ix(t.name) && !ox(t.name, e));
          const r = o.some((t) => !!t.className);
          n.extend('$block', { allowAttributes: 'alignment' });
          t.model.schema.setAttributeProperties('alignment', {
            isFormatting: true,
          });
          if (r) {
            t.conversion.attributeToAttribute(gx(o));
          } else {
            t.conversion.for('downcast').attributeToAttribute(hx(o));
          }
          const s = ux(o);
          for (const e of s) {
            t.conversion.for('upcast').attributeToAttribute(e);
          }
          const a = fx(o);
          for (const e of a) {
            t.conversion.for('upcast').attributeToAttribute(e);
          }
          t.commands.add('alignment', new ax(t));
        }
      }
      function hx(t) {
        const e = {
          model: { key: 'alignment', values: t.map((t) => t.name) },
          view: {},
        };
        for (const { name: n } of t) {
          e.view[n] = { key: 'style', value: { 'text-align': n } };
        }
        return e;
      }
      function ux(t) {
        const e = [];
        for (const { name: n } of t) {
          e.push({
            view: { key: 'style', value: { 'text-align': n } },
            model: { key: 'alignment', value: n },
          });
        }
        return e;
      }
      function fx(t) {
        const e = [];
        for (const { name: n } of t) {
          e.push({
            view: { key: 'align', value: n },
            model: { key: 'alignment', value: n },
          });
        }
        return e;
      }
      function gx(t) {
        const e = {
          model: { key: 'alignment', values: t.map((t) => t.name) },
          view: {},
        };
        for (const n of t) {
          e.view[n.name] = { key: 'class', value: n.className };
        }
        return e;
      }
      const mx = new Map([
        ['left', M_.alignLeft],
        ['right', M_.alignRight],
        ['center', M_.alignCenter],
        ['justify', M_.alignJustify],
      ]);
      class px extends nt {
        get localizedOptionTitles() {
          const t = this.editor.t;
          return {
            left: t('Align left'),
            right: t('Align right'),
            center: t('Align center'),
            justify: t('Justify'),
          };
        }
        static get pluginName() {
          return 'AlignmentUI';
        }
        init() {
          const t = this.editor;
          const e = t.ui.componentFactory;
          const n = t.t;
          const i = rx(t.config.get('alignment.options'));
          i.map((t) => t.name)
            .filter(ix)
            .forEach((t) => this._addButton(t));
          e.add('alignment', (o) => {
            const r = aA(o);
            const s = i.map((t) => e.create(`alignment:${t.name}`));
            cA(r, s, { enableActiveItemFocusOnDropdownOpen: true });
            r.buttonView.set({
              label: n('Text alignment'),
              tooltip: true,
            });
            r.toolbarView.isVertical = true;
            r.toolbarView.ariaLabel = n('Text alignment toolbar');
            r.extendTemplate({
              attributes: { class: 'ck-alignment-dropdown' },
            });
            const a =
              o.contentLanguageDirection === 'rtl'
                ? mx.get('right')
                : mx.get('left');
            r.buttonView.bind('icon').toMany(s, 'isOn', (...t) => {
              const e = t.findIndex((t) => t);
              if (e < 0) {
                return a;
              }
              return s[e].icon;
            });
            r.bind('isEnabled').toMany(s, 'isEnabled', (...t) =>
              t.some((t) => t)
            );
            this.listenTo(r, 'execute', () => {
              t.editing.view.focus();
            });
            return r;
          });
        }
        _addButton(t) {
          const e = this.editor;
          e.ui.componentFactory.add(`alignment:${t}`, (n) => {
            const i = e.commands.get('alignment');
            const o = new iv(n);
            o.set({
              label: this.localizedOptionTitles[t],
              icon: mx.get(t),
              tooltip: true,
              isToggleable: true,
            });
            o.bind('isEnabled').to(i);
            o.bind('isOn').to(i, 'value', (e) => e === t);
            this.listenTo(o, 'execute', () => {
              e.execute('alignment', { value: t });
              e.editing.view.focus();
            });
            return o;
          });
        }
      }
      class kx extends nt {
        static get requires() {
          return [dx, px];
        }
        static get pluginName() {
          return 'Alignment';
        }
      }
      class bx {
        constructor(t) {
          this.files = wx(t);
          this._native = t;
        }
        get types() {
          return this._native.types;
        }
        getData(t) {
          return this._native.getData(t);
        }
        setData(t, e) {
          this._native.setData(t, e);
        }
        set effectAllowed(t) {
          this._native.effectAllowed = t;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(t) {
          this._native.dropEffect = t;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        get isCanceled() {
          return (
            this._native.dropEffect == 'none' ||
            !!this._native.mozUserCancelled
          );
        }
      }
      function wx(t) {
        const e = Array.from(t.files || []);
        const n = Array.from(t.items || []);
        if (e.length) {
          return e;
        }
        return n
          .filter((t) => t.kind === 'file')
          .map((t) => t.getAsFile());
      }
      class _x extends Af {
        constructor(t) {
          super(t);
          const e = this.document;
          this.domEventType = [
            'paste',
            'copy',
            'cut',
            'drop',
            'dragover',
            'dragstart',
            'dragend',
            'dragenter',
            'dragleave',
          ];
          this.listenTo(e, 'paste', n('clipboardInput'), {
            priority: 'low',
          });
          this.listenTo(e, 'drop', n('clipboardInput'), {
            priority: 'low',
          });
          this.listenTo(e, 'dragover', n('dragging'), {
            priority: 'low',
          });
          function n(t) {
            return (n, i) => {
              i.preventDefault();
              const r = i.dropRange ? [i.dropRange] : null;
              const s = new o(e, t);
              e.fire(s, {
                dataTransfer: i.dataTransfer,
                method: n.name,
                targetRanges: r,
                target: i.target,
              });
              if (s.stop.called) {
                i.stopPropagation();
              }
            };
          }
        }
        onDomEvent(t) {
          const e = {
            dataTransfer: new bx(
              t.clipboardData ? t.clipboardData : t.dataTransfer
            ),
          };
          if (t.type == 'drop' || t.type == 'dragover') {
            e.dropRange = vx(this.view, t);
          }
          this.fire(t.type, t, e);
        }
      }
      function vx(t, e) {
        const n = e.target.ownerDocument;
        const i = e.clientX;
        const o = e.clientY;
        let r;
        if (n.caretRangeFromPoint && n.caretRangeFromPoint(i, o)) {
          r = n.caretRangeFromPoint(i, o);
        } else if (e.rangeParent) {
          r = n.createRange();
          r.setStart(e.rangeParent, e.rangeOffset);
          r.collapse(true);
        }
        if (r) {
          return t.domConverter.domRangeToView(r);
        }
        return null;
      }
      function Ax(t) {
        t = t
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/\r?\n\r?\n/g, '</p><p>')
          .replace(/\r?\n/g, '<br>')
          .replace(/^\s/, '&nbsp;')
          .replace(/\s$/, '&nbsp;')
          .replace(/\s\s/g, ' &nbsp;');
        if (t.includes('</p><p>') || t.includes('<br>')) {
          t = `<p>${t}</p>`;
        }
        return t;
      }
      function Cx(t) {
        return t
          .replace(
            /<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
            (t, e) => {
              if (e.length == 1) {
                return ' ';
              }
              return e;
            }
          )
          .replace(/<!--[\s\S]*?-->/g, '');
      }
      const yx = ['figcaption', 'li'];
      function xx(t) {
        let e = '';
        if (t.is('$text') || t.is('$textProxy')) {
          e = t.data;
        } else if (t.is('element', 'img') && t.hasAttribute('alt')) {
          e = t.getAttribute('alt');
        } else if (t.is('element', 'br')) {
          e = '\n';
        } else {
          let n = null;
          for (const i of t.getChildren()) {
            const t = xx(i);
            if (
              n &&
              (n.is('containerElement') || i.is('containerElement'))
            ) {
              if (yx.includes(n.name) || yx.includes(i.name)) {
                e += '\n';
              } else {
                e += '\n\n';
              }
            }
            e += t;
            n = i;
          }
        }
        return e;
      }
      class Ex extends nt {
        static get pluginName() {
          return 'ClipboardPipeline';
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          e.addObserver(_x);
          this._setupPasteDrop();
          this._setupCopyCut();
        }
        _setupPasteDrop() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = n.document;
          this.listenTo(
            i,
            'clipboardInput',
            (e) => {
              if (t.isReadOnly) {
                e.stop();
              }
            },
            { priority: 'highest' }
          );
          this.listenTo(
            i,
            'clipboardInput',
            (t, e) => {
              const i = e.dataTransfer;
              let r = e.content || '';
              if (!r) {
                if (i.getData('text/html')) {
                  r = Cx(i.getData('text/html'));
                } else if (i.getData('text/plain')) {
                  r = Ax(i.getData('text/plain'));
                }
                r = this.editor.data.htmlProcessor.toView(r);
              }
              const s = new o(this, 'inputTransformation');
              this.fire(s, {
                content: r,
                dataTransfer: i,
                targetRanges: e.targetRanges,
                method: e.method,
              });
              if (s.stop.called) {
                t.stop();
              }
              n.scrollToTheSelection();
            },
            { priority: 'low' }
          );
          this.listenTo(
            this,
            'inputTransformation',
            (t, n) => {
              if (n.content.isEmpty) {
                return;
              }
              const i = this.editor.data;
              const o = i.toModel(n.content, '$clipboardHolder');
              if (o.childCount == 0) {
                return;
              }
              t.stop();
              e.change(() => {
                this.fire('contentInsertion', {
                  content: o,
                  method: n.method,
                  dataTransfer: n.dataTransfer,
                  targetRanges: n.targetRanges,
                });
              });
            },
            { priority: 'low' }
          );
          this.listenTo(
            this,
            'contentInsertion',
            (t, n) => {
              n.resultRange = e.insertContent(n.content);
            },
            { priority: 'low' }
          );
        }
        _setupCopyCut() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.editing.view;
          const i = n.document;
          function o(n, o) {
            const r = o.dataTransfer;
            o.preventDefault();
            const s = t.data.toView(
              t.model.getSelectedContent(e.selection)
            );
            i.fire('clipboardOutput', {
              dataTransfer: r,
              content: s,
              method: n.name,
            });
          }
          this.listenTo(i, 'copy', o, { priority: 'low' });
          this.listenTo(
            i,
            'cut',
            (e, n) => {
              if (t.isReadOnly) {
                n.preventDefault();
              } else {
                o(e, n);
              }
            },
            { priority: 'low' }
          );
          this.listenTo(
            i,
            'clipboardOutput',
            (n, i) => {
              if (!i.content.isEmpty) {
                i.dataTransfer.setData(
                  'text/html',
                  this.editor.data.htmlProcessor.toData(i.content)
                );
                i.dataTransfer.setData('text/plain', xx(i.content));
              }
              if (i.method == 'cut') {
                t.model.deleteContent(e.selection);
              }
            },
            { priority: 'low' }
          );
        }
      }
      function* Dx(t, e) {
        for (const n of e) {
          if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
            yield n;
          }
        }
      }
      class Sx extends ot {
        execute() {
          const t = this.editor.model;
          const e = t.document;
          t.change((n) => {
            Tx(this.editor.model, n, e.selection, t.schema);
            this.fire('afterExecute', { writer: n });
          });
        }
      }
      function Tx(t, e, n, i) {
        const o = n.isCollapsed;
        const r = n.getFirstRange();
        const s = r.start.parent;
        const a = r.end.parent;
        if (i.isLimit(s) || i.isLimit(a)) {
          if (!o && s == a) {
            t.deleteContent(n);
          }
          return;
        }
        if (o) {
          const t = Dx(e.model.schema, n.getAttributes());
          Bx(e, r.start);
          e.setSelectionAttribute(t);
        } else {
          const i = !(r.start.isAtStart && r.end.isAtEnd);
          const o = s == a;
          t.deleteContent(n, { leaveUnmerged: i });
          if (i) {
            if (o) {
              Bx(e, n.focus);
            } else {
              e.setSelection(a, 0);
            }
          }
        }
      }
      function Bx(t, e) {
        t.split(e);
        t.setSelection(e.parent.nextSibling, 0);
      }
      class Px extends ku {
        constructor(t) {
          super(t);
          const e = this.document;
          e.on('keydown', (t, n) => {
            if (this.isEnabled && n.keyCode == Ld.enter) {
              const i = new dd(
                e,
                'enter',
                e.selection.getFirstRange()
              );
              e.fire(
                i,
                new vf(e, n.domEvent, { isSoft: n.shiftKey })
              );
              if (i.stop.called) {
                t.stop();
              }
            }
          });
        }
        observe() {}
      }
      class Ix extends nt {
        static get pluginName() {
          return 'Enter';
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          e.addObserver(Px);
          t.commands.add('enter', new Sx(t));
          this.listenTo(
            n,
            'enter',
            (n, i) => {
              i.preventDefault();
              if (i.isSoft) {
                return;
              }
              t.execute('enter');
              e.scrollToTheSelection();
            },
            { priority: 'low' }
          );
        }
      }
      class Rx {
        constructor(t, e = 20) {
          this.model = t;
          this.size = 0;
          this.limit = e;
          this.isLocked = false;
          this._changeCallback = (t, e) => {
            if (e.isLocal && e.isUndoable && e !== this._batch) {
              this._reset(true);
            }
          };
          this._selectionChangeCallback = () => {
            this._reset();
          };
          this.model.document.on('change', this._changeCallback);
          this.model.document.selection.on(
            'change:range',
            this._selectionChangeCallback
          );
          this.model.document.selection.on(
            'change:attribute',
            this._selectionChangeCallback
          );
        }
        get batch() {
          if (!this._batch) {
            this._batch = this.model.createBatch({ isTyping: true });
          }
          return this._batch;
        }
        input(t) {
          this.size += t;
          if (this.size >= this.limit) {
            this._reset(true);
          }
        }
        lock() {
          this.isLocked = true;
        }
        unlock() {
          this.isLocked = false;
        }
        destroy() {
          this.model.document.off('change', this._changeCallback);
          this.model.document.selection.off(
            'change:range',
            this._selectionChangeCallback
          );
          this.model.document.selection.off(
            'change:attribute',
            this._selectionChangeCallback
          );
        }
        _reset(t) {
          if (!this.isLocked || t) {
            this._batch = null;
            this.size = 0;
          }
        }
      }
      class zx extends ot {
        constructor(t, e) {
          super(t);
          this.direction = e;
          this._buffer = new Rx(
            t.model,
            t.config.get('typing.undoStep')
          );
        }
        get buffer() {
          return this._buffer;
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          e.enqueueChange(this._buffer.batch, (i) => {
            this._buffer.lock();
            const o = i.createSelection(t.selection || n.selection);
            const r = t.sequence || 1;
            const s = o.isCollapsed;
            if (o.isCollapsed) {
              e.modifySelection(o, {
                direction: this.direction,
                unit: t.unit,
                treatEmojiAsSingleUnit: true,
              });
            }
            if (this._shouldEntireContentBeReplacedWithParagraph(r)) {
              this._replaceEntireContentWithParagraph(i);
              return;
            }
            if (this._shouldReplaceFirstBlockWithParagraph(o, r)) {
              this.editor.execute('paragraph', { selection: o });
              return;
            }
            if (o.isCollapsed) {
              return;
            }
            let a = 0;
            o.getFirstRange()
              .getMinimalFlatRanges()
              .forEach((t) => {
                a += ad(
                  t.getWalker({
                    singleCharacters: true,
                    ignoreElementEnd: true,
                    shallow: true,
                  })
                );
              });
            e.deleteContent(o, {
              doNotResetEntireContent: s,
              direction: this.direction,
            });
            this._buffer.input(a);
            i.setSelection(o);
            this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(t) {
          if (t > 1) {
            return false;
          }
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = e.schema.getLimitElement(i);
          const r = i.isCollapsed && i.containsEntireContent(o);
          if (!r) {
            return false;
          }
          if (!e.schema.checkChild(o, 'paragraph')) {
            return false;
          }
          const s = o.getChild(0);
          if (s && s.name === 'paragraph') {
            return false;
          }
          return true;
        }
        _replaceEntireContentWithParagraph(t) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = e.schema.getLimitElement(i);
          const r = t.createElement('paragraph');
          t.remove(t.createRangeIn(o));
          t.insert(r, o);
          t.setSelection(r, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(t, e) {
          const n = this.editor.model;
          if (e > 1 || this.direction != 'backward') {
            return false;
          }
          if (!t.isCollapsed) {
            return false;
          }
          const i = t.getFirstPosition();
          const o = n.schema.getLimitElement(i);
          const r = o.getChild(0);
          if (i.parent != r) {
            return false;
          }
          if (!t.containsEntireContent(r)) {
            return false;
          }
          if (!n.schema.checkChild(o, 'paragraph')) {
            return false;
          }
          if (r.name == 'paragraph') {
            return false;
          }
          return true;
        }
      }
      function Ox(t, e) {
        const n = [];
        let i = 0;
        let o = null;
        t.forEach((t) => {
          if (t == 'equal') {
            r();
            i++;
          } else if (t == 'insert') {
            if (o && o.type == 'insert') {
              o.values.push(e[i]);
            } else {
              r();
              o = { type: 'insert', index: i, values: [e[i]] };
            }
            i++;
          } else {
            if (o && o.type == 'delete') {
              o.howMany++;
            } else {
              r();
              o = { type: 'delete', index: i, howMany: 1 };
            }
          }
        });
        r();
        return n;
        function r() {
          if (o) {
            n.push(o);
            o = null;
          }
        }
      }
      function Fx(t) {
        if (t.length == 0) {
          return false;
        }
        for (const e of t) {
          if (e.type === 'children' && !Nx(e)) {
            return true;
          }
        }
        return false;
      }
      function Nx(t) {
        if (t.newChildren.length - t.oldChildren.length != 1) {
          return;
        }
        const e = Rh(t.oldChildren, t.newChildren, Mx);
        const n = Ox(e, t.newChildren);
        if (n.length > 1) {
          return;
        }
        const i = n[0];
        if (!(!!i.values[0] && i.values[0].is('$text'))) {
          return;
        }
        return i;
      }
      function Mx(t, e) {
        if (!!t && t.is('$text') && !!e && e.is('$text')) {
          return t.data === e.data;
        } else {
          return t === e;
        }
      }
      function Lx(t, e) {
        const n = e.selection;
        const i = t.shiftKey && t.keyCode === Ld['delete'];
        const o = !n.isCollapsed;
        return i && o;
      }
      class Vx extends ku {
        constructor(t) {
          super(t);
          const e = t.document;
          let n = 0;
          e.on('keyup', (t, e) => {
            if (
              e.keyCode == Ld['delete'] ||
              e.keyCode == Ld.backspace
            ) {
              n = 0;
            }
          });
          e.on('keydown', (t, o) => {
            if (Sd.isWindows && Lx(o, e)) {
              return;
            }
            const r = {};
            if (o.keyCode == Ld['delete']) {
              r.direction = 'forward';
              r.unit = 'character';
            } else if (o.keyCode == Ld.backspace) {
              r.direction = 'backward';
              r.unit = 'codePoint';
            } else {
              return;
            }
            const s = Sd.isMac ? o.altKey : o.ctrlKey;
            r.unit = s ? 'word' : r.unit;
            r.sequence = ++n;
            i(t, o.domEvent, r);
          });
          if (Sd.isAndroid) {
            e.on('beforeinput', (e, n) => {
              if (n.domEvent.inputType != 'deleteContentBackward') {
                return;
              }
              const o = {
                unit: 'codepoint',
                direction: 'backward',
                sequence: 1,
              };
              const r =
                n.domTarget.ownerDocument.defaultView.getSelection();
              if (
                r.anchorNode == r.focusNode &&
                r.anchorOffset + 1 != r.focusOffset
              ) {
                o.selectionToRemove =
                  t.domConverter.domSelectionToView(r);
              }
              i(e, n.domEvent, o);
            });
          }
          function i(t, n, i) {
            const o = new dd(
              e,
              'delete',
              e.selection.getFirstRange()
            );
            e.fire(o, new vf(e, n, i));
            if (o.stop.called) {
              t.stop();
            }
          }
        }
        observe() {}
      }
      class Hx extends nt {
        static get pluginName() {
          return 'Delete';
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const i = t.model.document;
          e.addObserver(Vx);
          this._undoOnBackspace = false;
          const o = new zx(t, 'forward');
          t.commands.add('deleteForward', o);
          t.commands.add('forwardDelete', o);
          t.commands.add('delete', new zx(t, 'backward'));
          this.listenTo(
            n,
            'delete',
            (n, i) => {
              const o = { unit: i.unit, sequence: i.sequence };
              if (i.selectionToRemove) {
                const e = t.model.createSelection();
                const n = [];
                for (const e of i.selectionToRemove.getRanges()) {
                  n.push(t.editing.mapper.toModelRange(e));
                }
                e.setTo(n);
                o.selection = e;
              }
              t.execute(
                i.direction == 'forward' ? 'deleteForward' : 'delete',
                o
              );
              i.preventDefault();
              e.scrollToTheSelection();
            },
            { priority: 'low' }
          );
          if (Sd.isAndroid) {
            let t = null;
            this.listenTo(
              n,
              'delete',
              (e, n) => {
                const i =
                  n.domTarget.ownerDocument.defaultView.getSelection();
                t = {
                  anchorNode: i.anchorNode,
                  anchorOffset: i.anchorOffset,
                  focusNode: i.focusNode,
                  focusOffset: i.focusOffset,
                };
              },
              { priority: 'lowest' }
            );
            this.listenTo(n, 'keyup', (e, n) => {
              if (t) {
                const e =
                  n.domTarget.ownerDocument.defaultView.getSelection();
                e.collapse(t.anchorNode, t.anchorOffset);
                e.extend(t.focusNode, t.focusOffset);
                t = null;
              }
            });
          }
          if (this.editor.plugins.has('UndoEditing')) {
            this.listenTo(
              n,
              'delete',
              (e, n) => {
                if (
                  this._undoOnBackspace &&
                  n.direction == 'backward' &&
                  n.sequence == 1 &&
                  n.unit == 'codePoint'
                ) {
                  this._undoOnBackspace = false;
                  t.execute('undo');
                  n.preventDefault();
                  e.stop();
                }
              },
              { context: '$capture' }
            );
            this.listenTo(i, 'change', () => {
              this._undoOnBackspace = false;
            });
          }
        }
        requestUndoOnBackspace() {
          if (this.editor.plugins.has('UndoEditing')) {
            this._undoOnBackspace = true;
          }
        }
      }
      class jx {
        constructor() {
          this._stack = [];
        }
        add(t, e) {
          const n = this._stack;
          const i = n[0];
          this._insertDescriptor(t);
          const o = n[0];
          if (i !== o && !qx(i, o)) {
            this.fire('change:top', {
              oldDescriptor: i,
              newDescriptor: o,
              writer: e,
            });
          }
        }
        remove(t, e) {
          const n = this._stack;
          const i = n[0];
          this._removeDescriptor(t);
          const o = n[0];
          if (i !== o && !qx(i, o)) {
            this.fire('change:top', {
              oldDescriptor: i,
              newDescriptor: o,
              writer: e,
            });
          }
        }
        _insertDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex((e) => e.id === t.id);
          if (qx(t, e[n])) {
            return;
          }
          if (n > -1) {
            e.splice(n, 1);
          }
          let i = 0;
          while (e[i] && Wx(e[i], t)) {
            i++;
          }
          e.splice(i, 0, t);
        }
        _removeDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex((e) => e.id === t);
          if (n > -1) {
            e.splice(n, 1);
          }
        }
      }
      et(jx, C);
      function qx(t, e) {
        return (
          t &&
          e &&
          t.priority == e.priority &&
          Ux(t.classes) == Ux(e.classes)
        );
      }
      function Wx(t, e) {
        if (t.priority > e.priority) {
          return true;
        } else if (t.priority < e.priority) {
          return false;
        }
        return Ux(t.classes) > Ux(e.classes);
      }
      function Ux(t) {
        return Array.isArray(t) ? t.sort().join(',') : t;
      }
      const Gx =
        '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
      const $x = 'ck-widget';
      const Kx = 'ck-widget_selected';
      function Zx(t) {
        if (!t.is('element')) {
          return false;
        }
        return !!t.getCustomProperty('widget');
      }
      function Jx(t, e, n = {}) {
        if (!t.is('containerElement')) {
          throw new h('widget-to-widget-wrong-element-type', null, {
            element: t,
          });
        }
        e.setAttribute('contenteditable', 'false', t);
        e.addClass($x, t);
        e.setCustomProperty('widget', true, t);
        t.getFillerOffset = rE;
        if (n.label) {
          tE(t, n.label, e);
        }
        if (n.hasSelectionHandle) {
          sE(t, e);
        }
        Xx(t, e);
        return t;
      }
      function Yx(t, e, n) {
        if (e.classes) {
          n.addClass(Ea(e.classes), t);
        }
        if (e.attributes) {
          for (const i in e.attributes) {
            n.setAttribute(i, e.attributes[i], t);
          }
        }
      }
      function Qx(t, e, n) {
        if (e.classes) {
          n.removeClass(Ea(e.classes), t);
        }
        if (e.attributes) {
          for (const i in e.attributes) {
            n.removeAttribute(i, t);
          }
        }
      }
      function Xx(t, e, n = Yx, i = Qx) {
        const o = new jx();
        o.on('change:top', (e, o) => {
          if (o.oldDescriptor) {
            i(t, o.oldDescriptor, o.writer);
          }
          if (o.newDescriptor) {
            n(t, o.newDescriptor, o.writer);
          }
        });
        e.setCustomProperty(
          'addHighlight',
          (t, e, n) => o.add(e, n),
          t
        );
        e.setCustomProperty(
          'removeHighlight',
          (t, e, n) => o.remove(e, n),
          t
        );
      }
      function tE(t, e, n) {
        n.setCustomProperty('widgetLabel', e, t);
      }
      function eE(t) {
        const e = t.getCustomProperty('widgetLabel');
        if (!e) {
          return '';
        }
        return typeof e == 'function' ? e() : e;
      }
      function nE(t, e, n = {}) {
        e.addClass(
          ['ck-editor__editable', 'ck-editor__nested-editable'],
          t
        );
        e.setAttribute('role', 'textbox', t);
        if (n.label) {
          e.setAttribute('aria-label', n.label, t);
        }
        e.setAttribute(
          'contenteditable',
          t.isReadOnly ? 'false' : 'true',
          t
        );
        t.on('change:isReadOnly', (n, i, o) => {
          e.setAttribute('contenteditable', o ? 'false' : 'true', t);
        });
        t.on('change:isFocused', (n, i, o) => {
          if (o) {
            e.addClass('ck-editor__nested-editable_focused', t);
          } else {
            e.removeClass('ck-editor__nested-editable_focused', t);
          }
        });
        Xx(t, e);
        return t;
      }
      function iE(t, e) {
        const n = t.getSelectedElement();
        if (n) {
          const i = uE(t);
          if (i) {
            return e.createRange(e.createPositionAt(n, i));
          }
        }
        return Ib(t, e);
      }
      function oE(t, e) {
        return (n, i) => {
          const { mapper: o, viewPosition: r } = i;
          const s = o.findMappedViewAncestor(r);
          if (!e(s)) {
            return;
          }
          const a = o.toModelElement(s);
          i.modelPosition = t.createPositionAt(
            a,
            r.isAtStart ? 'before' : 'after'
          );
        };
      }
      function rE() {
        return null;
      }
      function sE(t, e) {
        const n = e.createUIElement(
          'div',
          { class: 'ck ck-widget__selection-handle' },
          function (t) {
            const e = this.toDomElement(t);
            const n = new Q_();
            n.set('content', Gx);
            n.render();
            e.appendChild(n.element);
            return e;
          }
        );
        e.insert(e.createPositionAt(t, 0), n);
        e.addClass(['ck-widget_with-selection-handle'], t);
      }
      const aE = 'widget-type-around';
      function cE(t, e, n) {
        return t && Zx(t) && !n.isInline(e);
      }
      function lE(t) {
        return t.closest('.ck-widget__type-around__button');
      }
      function dE(t) {
        return t.classList.contains(
          'ck-widget__type-around__button_before'
        )
          ? 'before'
          : 'after';
      }
      function hE(t, e) {
        const n = t.closest('.ck-widget');
        return e.mapDomToView(n);
      }
      function uE(t) {
        return t.getAttribute(aE);
      }
      function fE(t) {
        let e = null;
        const n = t.model;
        const i = t.editing.view;
        const o = t.commands.get('input');
        if (Sd.isAndroid) {
          i.document.on('beforeinput', (t, e) => r(e), {
            priority: 'lowest',
          });
        } else {
          i.document.on('keydown', (t, e) => r(e), {
            priority: 'lowest',
          });
        }
        i.document.on('compositionstart', s, { priority: 'lowest' });
        i.document.on(
          'compositionend',
          () => {
            e = n.createSelection(n.document.selection);
          },
          { priority: 'lowest' }
        );
        function r(t) {
          if (Sd.isWindows && Lx(t, i.document)) {
            return;
          }
          const r = n.document;
          const s = i.document.isComposing;
          const c = e && e.isEqual(r.selection);
          e = null;
          if (!o.isEnabled) {
            return;
          }
          if (mE(t) || r.selection.isCollapsed) {
            return;
          }
          if (s && t.keyCode === 229) {
            return;
          }
          if (!s && t.keyCode === 229 && c) {
            return;
          }
          a();
        }
        function s() {
          const t = n.document;
          const e =
            t.selection.rangeCount === 1
              ? t.selection.getFirstRange().isFlat
              : true;
          if (t.selection.isCollapsed || e) {
            return;
          }
          a();
        }
        function a() {
          const t = o.buffer;
          t.lock();
          const e = t.batch;
          n.enqueueChange(e, () => {
            n.deleteContent(n.document.selection);
          });
          t.unlock();
        }
      }
      const gE = [
        Hd('arrowUp'),
        Hd('arrowRight'),
        Hd('arrowDown'),
        Hd('arrowLeft'),
        9,
        16,
        17,
        18,
        19,
        20,
        27,
        33,
        34,
        35,
        36,
        45,
        91,
        93,
        144,
        145,
        173,
        174,
        175,
        176,
        177,
        178,
        179,
        255,
      ];
      for (let t = 112; t <= 135; t++) {
        gE.push(t);
      }
      function mE(t) {
        if (t.ctrlKey || t.metaKey) {
          return true;
        }
        return gE.includes(t.keyCode);
      }
      const pE =
        '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
      var kE = n(5137);
      var bE = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      bE.insert = 'head';
      bE.singleton = true;
      var wE = Lh()(kE.Z, bE);
      const _E = kE.Z.locals || {};
      const vE = ['before', 'after'];
      const AE = new DOMParser().parseFromString(
        pE,
        'image/svg+xml'
      ).firstChild;
      const CE = 'ck-widget__type-around_disabled';
      class yE extends nt {
        static get pluginName() {
          return 'WidgetTypeAround';
        }
        static get requires() {
          return [Ix, Hx];
        }
        constructor(t) {
          super(t);
          this._currentFakeCaretModelElement = null;
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this.on('change:isEnabled', (n, i, o) => {
            e.change((t) => {
              for (const n of e.document.roots) {
                if (o) {
                  t.removeClass(CE, n);
                } else {
                  t.addClass(CE, n);
                }
              }
            });
            if (!o) {
              t.model.change((t) => {
                t.removeSelectionAttribute(aE);
              });
            }
          });
          this._enableTypeAroundUIInjection();
          this._enableInsertingParagraphsOnButtonClick();
          this._enableInsertingParagraphsOnEnterKeypress();
          this._enableInsertingParagraphsOnTypingKeystroke();
          this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
          this._enableDeleteIntegration();
          this._enableInsertContentIntegration();
          this._enableInsertObjectIntegration();
          this._enableDeleteContentIntegration();
        }
        destroy() {
          this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(t, e) {
          const n = this.editor;
          const i = n.editing.view;
          const o = n.model.schema.getAttributesWithProperty(
            t,
            'copyOnReplace',
            true
          );
          n.execute('insertParagraph', {
            position: n.model.createPositionAt(t, e),
            attributes: o,
          });
          i.focus();
          i.scrollToTheSelection();
        }
        _listenToIfEnabled(t, e, n, i) {
          this.listenTo(
            t,
            e,
            (...t) => {
              if (this.isEnabled) {
                n(...t);
              }
            },
            i
          );
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const i = uE(n);
          if (!i) {
            return false;
          }
          const o = n.getSelectedElement();
          this._insertParagraph(o, i);
          return true;
        }
        _enableTypeAroundUIInjection() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.locale.t;
          const i = {
            before: n('Insert paragraph before block'),
            after: n('Insert paragraph after block'),
          };
          t.editing.downcastDispatcher.on(
            'insert',
            (t, n, o) => {
              const r = o.mapper.toViewElement(n.item);
              if (cE(r, n.item, e)) {
                xE(o.writer, i, r);
              }
            },
            { priority: 'low' }
          );
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const i = e.schema;
          const o = t.editing.view;
          this._listenToIfEnabled(
            o.document,
            'arrowKey',
            (t, e) => {
              this._handleArrowKeyPress(t, e);
            },
            { context: [Zx, '$text'], priority: 'high' }
          );
          this._listenToIfEnabled(n, 'change:range', (e, n) => {
            if (!n.directChange) {
              return;
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(aE);
            });
          });
          this._listenToIfEnabled(e.document, 'change:data', () => {
            const e = n.getSelectedElement();
            if (e) {
              const n = t.editing.mapper.toViewElement(e);
              if (cE(n, e, i)) {
                return;
              }
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(aE);
            });
          });
          this._listenToIfEnabled(
            t.editing.downcastDispatcher,
            'selection',
            (t, e, n) => {
              const o = n.writer;
              if (this._currentFakeCaretModelElement) {
                const t = n.mapper.toViewElement(
                  this._currentFakeCaretModelElement
                );
                if (t) {
                  o.removeClass(vE.map(r), t);
                  this._currentFakeCaretModelElement = null;
                }
              }
              const s = e.selection.getSelectedElement();
              if (!s) {
                return;
              }
              const a = n.mapper.toViewElement(s);
              if (!cE(a, s, i)) {
                return;
              }
              const c = uE(e.selection);
              if (!c) {
                return;
              }
              o.addClass(r(c), a);
              this._currentFakeCaretModelElement = s;
            }
          );
          this._listenToIfEnabled(
            t.ui.focusTracker,
            'change:isFocused',
            (e, n, i) => {
              if (!i) {
                t.model.change((t) => {
                  t.removeSelectionAttribute(aE);
                });
              }
            }
          );
          function r(t) {
            return `ck-widget_type-around_show-fake-caret_${t}`;
          }
        }
        _handleArrowKeyPress(t, e) {
          const n = this.editor;
          const i = n.model;
          const o = i.document.selection;
          const r = i.schema;
          const s = n.editing.view;
          const a = e.keyCode;
          const c = $d(a, n.locale.contentLanguageDirection);
          const l = s.document.selection.getSelectedElement();
          const d = n.editing.mapper.toModelElement(l);
          let h;
          if (cE(l, d, r)) {
            h = this._handleArrowKeyPressOnSelectedWidget(c);
          } else if (o.isCollapsed) {
            h =
              this._handleArrowKeyPressWhenSelectionNextToAWidget(c);
          } else if (!e.shiftKey) {
            h = this._handleArrowKeyPressWhenNonCollapsedSelection(c);
          }
          if (h) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleArrowKeyPressOnSelectedWidget(t) {
          const e = this.editor;
          const n = e.model;
          const i = n.document.selection;
          const o = uE(i);
          return n.change((e) => {
            if (o) {
              const n = o === (t ? 'after' : 'before');
              if (!n) {
                e.removeSelectionAttribute(aE);
                return true;
              }
            } else {
              e.setSelectionAttribute(aE, t ? 'after' : 'before');
              return true;
            }
            return false;
          });
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
          const e = this.editor;
          const n = e.model;
          const i = n.schema;
          const o = e.plugins.get('Widget');
          const r = o._getObjectElementNextToSelection(t);
          const s = e.editing.mapper.toViewElement(r);
          if (cE(s, r, i)) {
            n.change((e) => {
              o._setSelectionOverElement(r);
              e.setSelectionAttribute(aE, t ? 'before' : 'after');
            });
            return true;
          }
          return false;
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(t) {
          const e = this.editor;
          const n = e.model;
          const i = n.schema;
          const o = e.editing.mapper;
          const r = n.document.selection;
          const s = t
            ? r.getLastPosition().nodeBefore
            : r.getFirstPosition().nodeAfter;
          const a = o.toViewElement(s);
          if (cE(a, s, i)) {
            n.change((e) => {
              e.setSelection(s, 'on');
              e.setSelectionAttribute(aE, t ? 'after' : 'before');
            });
            return true;
          }
          return false;
        }
        _enableInsertingParagraphsOnButtonClick() {
          const t = this.editor;
          const e = t.editing.view;
          this._listenToIfEnabled(e.document, 'mousedown', (n, i) => {
            const o = lE(i.domTarget);
            if (!o) {
              return;
            }
            const r = dE(o);
            const s = hE(o, e.domConverter);
            const a = t.editing.mapper.toModelElement(s);
            this._insertParagraph(a, r);
            i.preventDefault();
            n.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const t = this.editor;
          const e = t.model.document.selection;
          const n = t.editing.view;
          this._listenToIfEnabled(
            n.document,
            'enter',
            (n, i) => {
              if (n.eventPhase != 'atTarget') {
                return;
              }
              const o = e.getSelectedElement();
              const r = t.editing.mapper.toViewElement(o);
              const s = t.model.schema;
              let a;
              if (
                this._insertParagraphAccordingToFakeCaretPosition()
              ) {
                a = true;
              } else if (cE(r, o, s)) {
                this._insertParagraph(
                  o,
                  i.isSoft ? 'before' : 'after'
                );
                a = true;
              }
              if (a) {
                i.preventDefault();
                n.stop();
              }
            },
            { context: Zx }
          );
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const t = this.editor;
          const e = t.editing.view;
          const n = [Ld.enter, Ld['delete'], Ld.backspace];
          this._listenToIfEnabled(
            e.document,
            'keydown',
            (t, e) => {
              if (!n.includes(e.keyCode) && !mE(e)) {
                this._insertParagraphAccordingToFakeCaretPosition();
              }
            },
            { priority: 'high' }
          );
        }
        _enableDeleteIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = t.model;
          const i = n.schema;
          this._listenToIfEnabled(
            e.document,
            'delete',
            (e, o) => {
              if (e.eventPhase != 'atTarget') {
                return;
              }
              const r = uE(n.document.selection);
              if (!r) {
                return;
              }
              const s = o.direction;
              const a = n.document.selection.getSelectedElement();
              const c = r === 'before';
              const l = s == 'forward';
              const d = c === l;
              if (d) {
                t.execute('delete', {
                  selection: n.createSelection(a, 'on'),
                });
              } else {
                const e = i.getNearestSelectionRange(
                  n.createPositionAt(a, r),
                  s
                );
                if (e) {
                  if (!e.isCollapsed) {
                    n.change((n) => {
                      n.setSelection(e);
                      t.execute(l ? 'deleteForward' : 'delete');
                    });
                  } else {
                    const o = n.createSelection(e.start);
                    n.modifySelection(o, { direction: s });
                    if (!o.focus.isEqual(e.start)) {
                      n.change((n) => {
                        n.setSelection(e);
                        t.execute(l ? 'deleteForward' : 'delete');
                      });
                    } else {
                      const t = SE(i, e.start.parent);
                      n.deleteContent(n.createSelection(t, 'on'), {
                        doNotAutoparagraph: true,
                      });
                    }
                  }
                }
              }
              o.preventDefault();
              e.stop();
            },
            { context: Zx }
          );
        }
        _enableInsertContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            'insertContent',
            (t, [i, o]) => {
              if (o && !o.is('documentSelection')) {
                return;
              }
              const r = uE(n);
              if (!r) {
                return;
              }
              t.stop();
              return e.change((t) => {
                const o = n.getSelectedElement();
                const s = e.createPositionAt(o, r);
                const a = t.createSelection(s);
                const c = e.insertContent(i, a);
                t.setSelection(a);
                return c;
              });
            },
            { priority: 'high' }
          );
        }
        _enableInsertObjectIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            'insertObject',
            (t, e) => {
              const [, i, , o = {}] = e;
              if (i && !i.is('documentSelection')) {
                return;
              }
              const r = uE(n);
              if (!r) {
                return;
              }
              o.findOptimalPosition = r;
              e[3] = o;
            },
            { priority: 'high' }
          );
        }
        _enableDeleteContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            'deleteContent',
            (t, [e]) => {
              if (e && !e.is('documentSelection')) {
                return;
              }
              const i = uE(n);
              if (i) {
                t.stop();
              }
            },
            { priority: 'high' }
          );
        }
      }
      function xE(t, e, n) {
        const i = t.createUIElement(
          'div',
          { class: 'ck ck-reset_all ck-widget__type-around' },
          function (t) {
            const n = this.toDomElement(t);
            EE(n, e);
            DE(n);
            return n;
          }
        );
        t.insert(t.createPositionAt(n, 'end'), i);
      }
      function EE(t, e) {
        for (const n of vE) {
          const i = new Yb({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-widget__type-around__button',
                `ck-widget__type-around__button_${n}`,
              ],
              title: e[n],
            },
            children: [t.ownerDocument.importNode(AE, true)],
          });
          t.appendChild(i.render());
        }
      }
      function DE(t) {
        const e = new Yb({
          tag: 'div',
          attributes: {
            class: ['ck', 'ck-widget__type-around__fake-caret'],
          },
        });
        t.appendChild(e.render());
      }
      function SE(t, e) {
        let n = e;
        for (const i of e.getAncestors({ parentFirst: true })) {
          if (i.childCount > 1 || t.isLimit(i)) {
            break;
          }
          n = i;
        }
        return n;
      }
      function TE(t) {
        const e = t.model;
        return (n, i) => {
          const o = i.keyCode == Ld.arrowup;
          const r = i.keyCode == Ld.arrowdown;
          const s = i.shiftKey;
          const a = e.document.selection;
          if (!o && !r) {
            return;
          }
          const c = r;
          if (s && zE(a, c)) {
            return;
          }
          const l = BE(t, a, c);
          if (!l) {
            return;
          }
          if (l.isCollapsed) {
            if (a.isCollapsed) {
              return;
            } else if (s) {
              return;
            }
          }
          if (l.isCollapsed || RE(t, l, c)) {
            e.change((t) => {
              const n = c ? l.end : l.start;
              if (s) {
                const i = e.createSelection(a.anchor);
                i.setFocus(n);
                t.setSelection(i);
              } else {
                t.setSelection(n);
              }
            });
            n.stop();
            i.preventDefault();
            i.stopPropagation();
          }
        };
      }
      function BE(t, e, n) {
        const i = t.model;
        if (n) {
          const t = e.isCollapsed ? e.focus : e.getLastPosition();
          const n = PE(i, t, 'forward');
          if (!n) {
            return null;
          }
          const o = i.createRange(t, n);
          const r = IE(i.schema, o, 'backward');
          if (r) {
            return i.createRange(t, r);
          }
          return null;
        } else {
          const t = e.isCollapsed ? e.focus : e.getFirstPosition();
          const n = PE(i, t, 'backward');
          if (!n) {
            return null;
          }
          const o = i.createRange(n, t);
          const r = IE(i.schema, o, 'forward');
          if (r) {
            return i.createRange(r, t);
          }
          return null;
        }
      }
      function PE(t, e, n) {
        const i = t.schema;
        const o = t.createRangeIn(e.root);
        const r = n == 'forward' ? 'elementStart' : 'elementEnd';
        for (const {
          previousPosition: t,
          item: s,
          type: a,
        } of o.getWalker({ startPosition: e, direction: n })) {
          if (i.isLimit(s) && !i.isInline(s)) {
            return t;
          }
          if (a == r && i.isBlock(s)) {
            return null;
          }
        }
        return null;
      }
      function IE(t, e, n) {
        const i = n == 'backward' ? e.end : e.start;
        if (t.checkChild(i, '$text')) {
          return i;
        }
        for (const { nextPosition: i } of e.getWalker({
          direction: n,
        })) {
          if (t.checkChild(i, '$text')) {
            return i;
          }
        }
        return null;
      }
      function RE(t, e, n) {
        const i = t.model;
        const o = t.view.domConverter;
        if (n) {
          const t = i.createSelection(e.start);
          i.modifySelection(t);
          if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
            e = i.createRange(t.focus, e.end);
          }
        }
        const r = t.mapper.toViewRange(e);
        const s = o.viewRangeToDom(r);
        const a = ag.getDomRangeRects(s);
        let c;
        for (const t of a) {
          if (c === undefined) {
            c = Math.round(t.bottom);
            continue;
          }
          if (Math.round(t.top) >= c) {
            return false;
          }
          c = Math.max(c, Math.round(t.bottom));
        }
        return true;
      }
      function zE(t, e) {
        return !t.isCollapsed && t.isBackward == e;
      }
      var OE = n(6507);
      var FE = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      FE.insert = 'head';
      FE.singleton = true;
      var NE = Lh()(OE.Z, FE);
      const ME = OE.Z.locals || {};
      class LE extends nt {
        static get pluginName() {
          return 'Widget';
        }
        static get requires() {
          return [yE, Hx];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this._previouslySelected = new Set();
          this.editor.editing.downcastDispatcher.on(
            'selection',
            (e, n, i) => {
              const o = i.writer;
              const r = n.selection;
              if (r.isCollapsed) {
                return;
              }
              const s = r.getSelectedElement();
              if (!s) {
                return;
              }
              const a = t.editing.mapper.toViewElement(s);
              if (!Zx(a)) {
                return;
              }
              if (!i.consumable.consume(r, 'selection')) {
                return;
              }
              o.setSelection(o.createRangeOn(a), {
                fake: true,
                label: eE(a),
              });
            }
          );
          this.editor.editing.downcastDispatcher.on(
            'selection',
            (t, e, n) => {
              this._clearPreviouslySelectedWidgets(n.writer);
              const i = n.writer;
              const o = i.document.selection;
              let r = null;
              for (const t of o.getRanges()) {
                for (const e of t) {
                  const t = e.item;
                  if (Zx(t) && !HE(t, r)) {
                    i.addClass(Kx, t);
                    this._previouslySelected.add(t);
                    r = t;
                  }
                }
              }
            },
            { priority: 'low' }
          );
          e.addObserver(ny);
          this.listenTo(n, 'mousedown', (...t) =>
            this._onMousedown(...t)
          );
          this.listenTo(
            n,
            'arrowKey',
            (...t) => {
              this._handleSelectionChangeOnArrowKeyPress(...t);
            },
            { context: [Zx, '$text'] }
          );
          this.listenTo(
            n,
            'arrowKey',
            (...t) => {
              this._preventDefaultOnArrowKeyPress(...t);
            },
            { context: '$root' }
          );
          this.listenTo(n, 'arrowKey', TE(this.editor.editing), {
            context: '$text',
          });
          this.listenTo(
            n,
            'delete',
            (t, e) => {
              if (this._handleDelete(e.direction == 'forward')) {
                e.preventDefault();
                t.stop();
              }
            },
            { context: '$root' }
          );
        }
        _onMousedown(t, e) {
          const n = this.editor;
          const i = n.editing.view;
          const o = i.document;
          let r = e.target;
          if (VE(r)) {
            if (
              (Sd.isSafari || Sd.isGecko) &&
              e.domEvent.detail >= 3
            ) {
              const t = n.editing.mapper;
              const i = r.is('attributeElement')
                ? r.findAncestor((t) => !t.is('attributeElement'))
                : r;
              const o = t.toModelElement(i);
              e.preventDefault();
              this.editor.model.change((t) => {
                t.setSelection(o, 'in');
              });
            }
            return;
          }
          if (!Zx(r)) {
            r = r.findAncestor(Zx);
            if (!r) {
              return;
            }
          }
          if (Sd.isAndroid) {
            e.preventDefault();
          }
          if (!o.isFocused) {
            i.focus();
          }
          const s = n.editing.mapper.toModelElement(r);
          this._setSelectionOverElement(s);
        }
        _handleSelectionChangeOnArrowKeyPress(t, e) {
          const n = e.keyCode;
          const i = this.editor.model;
          const o = i.schema;
          const r = i.document.selection;
          const s = r.getSelectedElement();
          const a = Ud(
            n,
            this.editor.locale.contentLanguageDirection
          );
          const c = a == 'down' || a == 'right';
          const l = a == 'up' || a == 'down';
          if (s && o.isObject(s)) {
            const n = c ? r.getLastPosition() : r.getFirstPosition();
            const s = o.getNearestSelectionRange(
              n,
              c ? 'forward' : 'backward'
            );
            if (s) {
              i.change((t) => {
                t.setSelection(s);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed && !e.shiftKey) {
            const n = r.getFirstPosition();
            const s = r.getLastPosition();
            const a = n.nodeAfter;
            const l = s.nodeBefore;
            if ((a && o.isObject(a)) || (l && o.isObject(l))) {
              i.change((t) => {
                t.setSelection(c ? s : n);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed) {
            return;
          }
          const d = this._getObjectElementNextToSelection(c);
          if (d && o.isObject(d)) {
            if (o.isInline(d) && l) {
              return;
            }
            this._setSelectionOverElement(d);
            e.preventDefault();
            t.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(t, e) {
          const n = this.editor.model;
          const i = n.schema;
          const o = n.document.selection.getSelectedElement();
          if (o && i.isObject(o)) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleDelete(t) {
          if (this.editor.isReadOnly) {
            return;
          }
          const e = this.editor.model.document;
          const n = e.selection;
          if (!n.isCollapsed) {
            return;
          }
          const i = this._getObjectElementNextToSelection(t);
          if (i) {
            this.editor.model.change((t) => {
              let e = n.anchor.parent;
              while (e.isEmpty) {
                const n = e;
                e = n.parent;
                t.remove(n);
              }
              this._setSelectionOverElement(i);
            });
            return true;
          }
        }
        _setSelectionOverElement(t) {
          this.editor.model.change((e) => {
            e.setSelection(e.createRangeOn(t));
          });
        }
        _getObjectElementNextToSelection(t) {
          const e = this.editor.model;
          const n = e.schema;
          const i = e.document.selection;
          const o = e.createSelection(i);
          e.modifySelection(o, {
            direction: t ? 'forward' : 'backward',
          });
          if (o.isEqual(i)) {
            return null;
          }
          const r = t ? o.focus.nodeBefore : o.focus.nodeAfter;
          if (!!r && n.isObject(r)) {
            return r;
          }
          return null;
        }
        _clearPreviouslySelectedWidgets(t) {
          for (const e of this._previouslySelected) {
            t.removeClass(Kx, e);
          }
          this._previouslySelected.clear();
        }
      }
      function VE(t) {
        while (t) {
          if (t.is('editableElement') && !t.is('rootElement')) {
            return true;
          }
          if (Zx(t)) {
            return false;
          }
          t = t.parent;
        }
        return false;
      }
      function HE(t, e) {
        if (!e) {
          return false;
        }
        return Array.from(t.getAncestors()).includes(e);
      }
      var jE = 'Expected a function';
      function qE(t, e, n) {
        var i = true,
          o = true;
        if (typeof t != 'function') {
          throw new TypeError(jE);
        }
        if (N(n)) {
          i = 'leading' in n ? !!n.leading : i;
          o = 'trailing' in n ? !!n.trailing : o;
        }
        return qf(t, e, { leading: i, maxWait: e, trailing: o });
      }
      const WE = qE;
      var UE = n(390);
      var GE = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      GE.insert = 'head';
      GE.singleton = true;
      var $E = Lh()(UE.Z, GE);
      const KE = UE.Z.locals || {};
      class ZE extends nt {
        static get pluginName() {
          return 'DragDrop';
        }
        static get requires() {
          return [Ex, LE];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this._draggedRange = null;
          this._draggingUid = '';
          this._draggableElement = null;
          this._updateDropMarkerThrottled = WE(
            (t) => this._updateDropMarker(t),
            40
          );
          this._removeDropMarkerDelayed = iD(
            () => this._removeDropMarker(),
            40
          );
          this._clearDraggableAttributesDelayed = iD(
            () => this._clearDraggableAttributes(),
            40
          );
          e.addObserver(_x);
          e.addObserver(ny);
          this._setupDragging();
          this._setupContentInsertionIntegration();
          this._setupClipboardInputIntegration();
          this._setupDropMarker();
          this._setupDraggableAttributeHandling();
          this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
            if (n) {
              this.forceDisabled('readOnlyMode');
            } else {
              this.clearForceDisabled('readOnlyMode');
            }
          });
          this.on('change:isEnabled', (t, e, n) => {
            if (!n) {
              this._finalizeDragging(false);
            }
          });
          if (Sd.isAndroid) {
            this.forceDisabled('noAndroidSupport');
          }
        }
        destroy() {
          if (this._draggedRange) {
            this._draggedRange.detach();
            this._draggedRange = null;
          }
          this._updateDropMarkerThrottled.cancel();
          this._removeDropMarkerDelayed.cancel();
          this._clearDraggableAttributesDelayed.cancel();
          return super.destroy();
        }
        _setupDragging() {
          const t = this.editor;
          const e = t.model;
          const n = e.document;
          const i = t.editing.view;
          const o = i.document;
          this.listenTo(
            o,
            'dragstart',
            (i, r) => {
              const a = n.selection;
              if (r.target && r.target.is('editableElement')) {
                r.preventDefault();
                return;
              }
              const c = r.target ? oD(r.target) : null;
              if (c) {
                const n = t.editing.mapper.toModelElement(c);
                this._draggedRange = Jg.fromRange(e.createRangeOn(n));
                if (t.plugins.has('WidgetToolbarRepository')) {
                  t.plugins
                    .get('WidgetToolbarRepository')
                    .forceDisabled('dragDrop');
                }
              } else if (!o.selection.isCollapsed) {
                const t = o.selection.getSelectedElement();
                if (!t || !Zx(t)) {
                  this._draggedRange = Jg.fromRange(
                    a.getFirstRange()
                  );
                }
              }
              if (!this._draggedRange) {
                r.preventDefault();
                return;
              }
              this._draggingUid = s();
              r.dataTransfer.effectAllowed = this.isEnabled
                ? 'copyMove'
                : 'copy';
              r.dataTransfer.setData(
                'application/ckeditor5-dragging-uid',
                this._draggingUid
              );
              const l = e.createSelection(
                this._draggedRange.toRange()
              );
              const d = t.data.toView(e.getSelectedContent(l));
              o.fire('clipboardOutput', {
                dataTransfer: r.dataTransfer,
                content: d,
                method: i.name,
              });
              if (!this.isEnabled) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = '';
              }
            },
            { priority: 'low' }
          );
          this.listenTo(
            o,
            'dragend',
            (t, e) => {
              this._finalizeDragging(
                !e.dataTransfer.isCanceled &&
                  e.dataTransfer.dropEffect == 'move'
              );
            },
            { priority: 'low' }
          );
          this.listenTo(o, 'dragenter', () => {
            if (!this.isEnabled) {
              return;
            }
            i.focus();
          });
          this.listenTo(o, 'dragleave', () => {
            this._removeDropMarkerDelayed();
          });
          this.listenTo(
            o,
            'dragging',
            (e, n) => {
              if (!this.isEnabled) {
                n.dataTransfer.dropEffect = 'none';
                return;
              }
              this._removeDropMarkerDelayed.cancel();
              const i = JE(t, n.targetRanges, n.target);
              if (!this._draggedRange) {
                n.dataTransfer.dropEffect = 'copy';
              }
              if (!Sd.isGecko) {
                if (n.dataTransfer.effectAllowed == 'copy') {
                  n.dataTransfer.dropEffect = 'copy';
                } else if (
                  ['all', 'copyMove'].includes(
                    n.dataTransfer.effectAllowed
                  )
                ) {
                  n.dataTransfer.dropEffect = 'move';
                }
              }
              if (i) {
                this._updateDropMarkerThrottled(i);
              }
            },
            { priority: 'low' }
          );
        }
        _setupClipboardInputIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.listenTo(
            n,
            'clipboardInput',
            (e, n) => {
              if (n.method != 'drop') {
                return;
              }
              const i = JE(t, n.targetRanges, n.target);
              this._removeDropMarker();
              if (!i) {
                this._finalizeDragging(false);
                e.stop();
                return;
              }
              if (
                this._draggedRange &&
                this._draggingUid !=
                  n.dataTransfer.getData(
                    'application/ckeditor5-dragging-uid'
                  )
              ) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = '';
              }
              const o = nD(n.dataTransfer) == 'move';
              if (
                o &&
                this._draggedRange &&
                this._draggedRange.containsRange(i, true)
              ) {
                this._finalizeDragging(false);
                e.stop();
                return;
              }
              n.targetRanges = [t.editing.mapper.toViewRange(i)];
            },
            { priority: 'high' }
          );
        }
        _setupContentInsertionIntegration() {
          const t = this.editor.plugins.get(Ex);
          t.on(
            'contentInsertion',
            (t, e) => {
              if (!this.isEnabled || e.method !== 'drop') {
                return;
              }
              const n = e.targetRanges.map((t) =>
                this.editor.editing.mapper.toModelRange(t)
              );
              this.editor.model.change((t) => t.setSelection(n));
            },
            { priority: 'high' }
          );
          t.on(
            'contentInsertion',
            (t, e) => {
              if (!this.isEnabled || e.method !== 'drop') {
                return;
              }
              const n = nD(e.dataTransfer) == 'move';
              const i = !e.resultRange || !e.resultRange.isCollapsed;
              this._finalizeDragging(i && n);
            },
            { priority: 'lowest' }
          );
        }
        _setupDraggableAttributeHandling() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.listenTo(n, 'mousedown', (i, o) => {
            if (Sd.isAndroid || !o) {
              return;
            }
            this._clearDraggableAttributesDelayed.cancel();
            let r = oD(o.target);
            if (
              Sd.isBlink &&
              !t.isReadOnly &&
              !r &&
              !n.selection.isCollapsed
            ) {
              const t = n.selection.getSelectedElement();
              if (!t || !Zx(t)) {
                r = n.selection.editableElement;
              }
            }
            if (r) {
              e.change((t) => {
                t.setAttribute('draggable', 'true', r);
              });
              this._draggableElement =
                t.editing.mapper.toModelElement(r);
            }
          });
          this.listenTo(n, 'mouseup', () => {
            if (!Sd.isAndroid) {
              this._clearDraggableAttributesDelayed();
            }
          });
        }
        _clearDraggableAttributes() {
          const t = this.editor.editing;
          t.view.change((e) => {
            if (
              this._draggableElement &&
              this._draggableElement.root.rootName != '$graveyard'
            ) {
              e.removeAttribute(
                'draggable',
                t.mapper.toViewElement(this._draggableElement)
              );
            }
            this._draggableElement = null;
          });
        }
        _setupDropMarker() {
          const t = this.editor;
          t.conversion
            .for('editingDowncast')
            .markerToHighlight({
              model: 'drop-target',
              view: { classes: ['ck-clipboard-drop-target-range'] },
            });
          t.conversion.for('editingDowncast').markerToElement({
            model: 'drop-target',
            view: (e, { writer: n }) => {
              const i = t.model.schema.checkChild(
                e.markerRange.start,
                '$text'
              );
              if (!i) {
                return;
              }
              return n.createUIElement(
                'span',
                { class: 'ck ck-clipboard-drop-target-position' },
                function (t) {
                  const e = this.toDomElement(t);
                  e.append('⁠', t.createElement('span'), '⁠');
                  return e;
                }
              );
            },
          });
        }
        _updateDropMarker(t) {
          const e = this.editor;
          const n = e.model.markers;
          e.model.change((e) => {
            if (n.has('drop-target')) {
              if (!n.get('drop-target').getRange().isEqual(t)) {
                e.updateMarker('drop-target', { range: t });
              }
            } else {
              e.addMarker('drop-target', {
                range: t,
                usingOperation: false,
                affectsData: false,
              });
            }
          });
        }
        _removeDropMarker() {
          const t = this.editor.model;
          this._removeDropMarkerDelayed.cancel();
          this._updateDropMarkerThrottled.cancel();
          if (t.markers.has('drop-target')) {
            t.change((t) => {
              t.removeMarker('drop-target');
            });
          }
        }
        _finalizeDragging(t) {
          const e = this.editor;
          const n = e.model;
          this._removeDropMarker();
          this._clearDraggableAttributes();
          if (e.plugins.has('WidgetToolbarRepository')) {
            e.plugins
              .get('WidgetToolbarRepository')
              .clearForceDisabled('dragDrop');
          }
          this._draggingUid = '';
          if (!this._draggedRange) {
            return;
          }
          if (t && this.isEnabled) {
            n.deleteContent(n.createSelection(this._draggedRange), {
              doNotAutoparagraph: true,
            });
          }
          this._draggedRange.detach();
          this._draggedRange = null;
        }
      }
      function JE(t, e, n) {
        const i = t.model;
        const o = t.editing.mapper;
        let r = null;
        const s = e ? e[0].start : null;
        if (n.is('uiElement')) {
          n = n.parent;
        }
        r = YE(t, n);
        if (r) {
          return r;
        }
        const a = eD(t, n);
        const c = s ? o.toModelPosition(s) : null;
        if (!c) {
          return QE(t, a);
        }
        r = XE(t, c, a);
        if (r) {
          return r;
        }
        r = i.schema.getNearestSelectionRange(
          c,
          Sd.isGecko ? 'forward' : 'backward'
        );
        if (r) {
          return r;
        }
        return tD(t, c.parent);
      }
      function YE(t, e) {
        const n = t.model;
        const i = t.editing.mapper;
        if (Zx(e)) {
          return n.createRangeOn(i.toModelElement(e));
        }
        if (!e.is('editableElement')) {
          const t = e.findAncestor(
            (t) => Zx(t) || t.is('editableElement')
          );
          if (Zx(t)) {
            return n.createRangeOn(i.toModelElement(t));
          }
        }
        return null;
      }
      function QE(t, e) {
        const n = t.model;
        const i = n.schema;
        const o = n.createPositionAt(e, 0);
        return i.getNearestSelectionRange(o, 'forward');
      }
      function XE(t, e, n) {
        const i = t.model;
        if (!i.schema.checkChild(n, '$block')) {
          return null;
        }
        const o = i.createPositionAt(n, 0);
        const r = e.path.slice(0, o.path.length);
        const s = i.createPositionFromPath(e.root, r);
        const a = s.nodeAfter;
        if (a && i.schema.isObject(a)) {
          return i.createRangeOn(a);
        }
        return null;
      }
      function tD(t, e) {
        const n = t.model;
        while (e) {
          if (n.schema.isObject(e)) {
            return n.createRangeOn(e);
          }
          e = e.parent;
        }
      }
      function eD(t, e) {
        const n = t.editing.mapper;
        const i = t.editing.view;
        const o = n.toModelElement(e);
        if (o) {
          return o;
        }
        const r = i.createPositionBefore(e);
        const s = n.findMappedViewAncestor(r);
        return n.toModelElement(s);
      }
      function nD(t) {
        if (Sd.isGecko) {
          return t.dropEffect;
        }
        return ['all', 'copyMove'].includes(t.effectAllowed)
          ? 'move'
          : 'copy';
      }
      function iD(t, e) {
        let n;
        function i(...o) {
          i.cancel();
          n = setTimeout(() => t(...o), e);
        }
        i.cancel = () => {
          clearTimeout(n);
        };
        return i;
      }
      function oD(t) {
        if (t.is('editableElement')) {
          return null;
        }
        if (t.hasClass('ck-widget__selection-handle')) {
          return t.findAncestor(Zx);
        }
        if (Zx(t)) {
          return t;
        }
        const e = t.findAncestor(
          (t) => Zx(t) || t.is('editableElement')
        );
        if (Zx(e)) {
          return e;
        }
        return null;
      }
      class rD extends nt {
        static get pluginName() {
          return 'PastePlainText';
        }
        static get requires() {
          return [Ex];
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = n.document;
          const o = e.document.selection;
          let r = false;
          n.addObserver(_x);
          this.listenTo(i, 'keydown', (t, e) => {
            r = e.shiftKey;
          });
          t.plugins.get(Ex).on('contentInsertion', (t, n) => {
            if (!r && !sD(n.content, e.schema)) {
              return;
            }
            e.change((t) => {
              const i = Array.from(o.getAttributes()).filter(
                ([t]) =>
                  e.schema.getAttributeProperties(t).isFormatting
              );
              if (!o.isCollapsed) {
                e.deleteContent(o, { doNotAutoparagraph: true });
              }
              i.push(...o.getAttributes());
              const r = t.createRangeIn(n.content);
              for (const e of r.getItems()) {
                if (e.is('$textProxy')) {
                  t.setAttributes(i, e);
                }
              }
            });
          });
        }
      }
      function sD(t, e) {
        if (t.childCount > 1) {
          return false;
        }
        const n = t.getChild(0);
        if (e.isObject(n)) {
          return false;
        }
        return [...n.getAttributeKeys()].length == 0;
      }
      class aD extends nt {
        static get pluginName() {
          return 'Clipboard';
        }
        static get requires() {
          return [Ex, ZE, rD];
        }
      }
      class cD extends ot {
        constructor(t) {
          super(t);
          this._stack = [];
          this._createdBatches = new WeakSet();
          this.refresh();
          this.listenTo(
            t.data,
            'set',
            (t, e) => {
              e[1] = { ...e[1] };
              const n = e[1];
              if (!n.batchType) {
                n.batchType = { isUndoable: false };
              }
            },
            { priority: 'high' }
          );
          this.listenTo(t.data, 'set', (t, e) => {
            const n = e[1];
            if (!n.batchType.isUndoable) {
              this.clearStack();
            }
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        addBatch(t) {
          const e = this.editor.model.document.selection;
          const n = {
            ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
            isBackward: e.isBackward,
          };
          this._stack.push({ batch: t, selection: n });
          this.refresh();
        }
        clearStack() {
          this._stack = [];
          this.refresh();
        }
        _restoreSelection(t, e, n) {
          const i = this.editor.model;
          const o = i.document;
          const r = [];
          const s = t.map((t) => t.getTransformedByOperations(n));
          const a = s.flat();
          for (const t of s) {
            const e = t
              .filter((t) => t.root != o.graveyard)
              .filter((t) => !dD(t, a));
            if (!e.length) {
              continue;
            }
            lD(e);
            r.push(e[0]);
          }
          if (r.length) {
            i.change((t) => {
              t.setSelection(r, { backward: e });
            });
          }
        }
        _undo(t, e) {
          const n = this.editor.model;
          const i = n.document;
          this._createdBatches.add(e);
          const o = t.operations
            .slice()
            .filter((t) => t.isDocumentOperation);
          o.reverse();
          for (const t of o) {
            const o = t.baseVersion + 1;
            const r = Array.from(i.history.getOperations(o));
            const s = $C([t.getReversed()], r, {
              useRelations: true,
              document: this.editor.model.document,
              padWithNoOps: false,
              forceWeakRemove: true,
            });
            const a = s.operationsA;
            for (const o of a) {
              e.addOperation(o);
              n.applyOperation(o);
              i.history.setOperationAsUndone(t, o);
            }
          }
        }
      }
      function lD(t) {
        t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
        for (let e = 1; e < t.length; e++) {
          const n = t[e - 1];
          const i = n.getJoined(t[e], true);
          if (i) {
            e--;
            t.splice(e, 2, i);
          }
        }
      }
      function dD(t, e) {
        return e.some((e) => e !== t && e.containsRange(t, true));
      }
      class hD extends cD {
        execute(t = null) {
          const e = t
            ? this._stack.findIndex((e) => e.batch == t)
            : this._stack.length - 1;
          const n = this._stack.splice(e, 1)[0];
          const i = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(i, () => {
            this._undo(n.batch, i);
            const t =
              this.editor.model.document.history.getOperations(
                n.batch.baseVersion
              );
            this._restoreSelection(
              n.selection.ranges,
              n.selection.isBackward,
              t
            );
            this.fire('revert', n.batch, i);
          });
          this.refresh();
        }
      }
      class uD extends cD {
        execute() {
          const t = this._stack.pop();
          const e = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(e, () => {
            const n =
              t.batch.operations[t.batch.operations.length - 1];
            const i = n.baseVersion + 1;
            const o =
              this.editor.model.document.history.getOperations(i);
            this._restoreSelection(
              t.selection.ranges,
              t.selection.isBackward,
              o
            );
            this._undo(t.batch, e);
          });
          this.refresh();
        }
      }
      class fD extends nt {
        static get pluginName() {
          return 'UndoEditing';
        }
        constructor(t) {
          super(t);
          this._batchRegistry = new WeakSet();
        }
        init() {
          const t = this.editor;
          this._undoCommand = new hD(t);
          this._redoCommand = new uD(t);
          t.commands.add('undo', this._undoCommand);
          t.commands.add('redo', this._redoCommand);
          this.listenTo(
            t.model,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              if (!n.isDocumentOperation) {
                return;
              }
              const i = n.batch;
              const o = this._redoCommand._createdBatches.has(i);
              const r = this._undoCommand._createdBatches.has(i);
              const s = this._batchRegistry.has(i);
              if (s) {
                return;
              }
              this._batchRegistry.add(i);
              if (!i.isUndoable) {
                return;
              }
              if (o) {
                this._undoCommand.addBatch(i);
              } else if (!r) {
                this._undoCommand.addBatch(i);
                this._redoCommand.clearStack();
              }
            },
            { priority: 'highest' }
          );
          this.listenTo(this._undoCommand, 'revert', (t, e, n) => {
            this._redoCommand.addBatch(n);
          });
          t.keystrokes.set('CTRL+Z', 'undo');
          t.keystrokes.set('CTRL+Y', 'redo');
          t.keystrokes.set('CTRL+SHIFT+Z', 'redo');
        }
      }
      const gD =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
      const mD =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class pD extends nt {
        static get pluginName() {
          return 'UndoUI';
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.t;
          const i = e.uiLanguageDirection == 'ltr' ? gD : mD;
          const o = e.uiLanguageDirection == 'ltr' ? mD : gD;
          this._addButton('undo', n('Undo'), 'CTRL+Z', i);
          this._addButton('redo', n('Redo'), 'CTRL+Y', o);
        }
        _addButton(t, e, n, i) {
          const o = this.editor;
          o.ui.componentFactory.add(t, (r) => {
            const s = o.commands.get(t);
            const a = new iv(r);
            a.set({ label: e, icon: i, keystroke: n, tooltip: true });
            a.bind('isEnabled').to(s, 'isEnabled');
            this.listenTo(a, 'execute', () => {
              o.execute(t);
              o.editing.view.focus();
            });
            return a;
          });
        }
      }
      class kD extends nt {
        static get requires() {
          return [fD, pD];
        }
        static get pluginName() {
          return 'Undo';
        }
      }
      class bD extends ot {
        constructor(t, e) {
          super(t);
          this._buffer = new Rx(t.model, e);
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy();
          this._buffer.destroy();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = t.text || '';
          const o = i.length;
          const r = t.range
            ? e.createSelection(t.range)
            : n.selection;
          const s = t.resultRange;
          e.enqueueChange(this._buffer.batch, (t) => {
            this._buffer.lock();
            e.deleteContent(r);
            if (i) {
              e.insertContent(
                t.createText(i, n.selection.getAttributes()),
                r
              );
            }
            if (s) {
              t.setSelection(s);
            } else if (!r.is('documentSelection')) {
              t.setSelection(r);
            }
            this._buffer.unlock();
            this._buffer.input(o);
          });
        }
      }
      function wD(t) {
        t.editing.view.document.on('mutations', (e, n, i) => {
          new _D(t).handle(n, i);
        });
      }
      class _D {
        constructor(t) {
          this.editor = t;
          this.editing = this.editor.editing;
        }
        handle(t, e) {
          if (Fx(t)) {
            this._handleContainerChildrenMutations(t, e);
          } else {
            for (const n of t) {
              this._handleTextMutation(n, e);
              this._handleTextNodeInsertion(n);
            }
          }
        }
        _handleContainerChildrenMutations(t, e) {
          const n = vD(t);
          if (!n) {
            return;
          }
          const i = this.editor.editing.view.domConverter;
          const o = i.mapViewToDom(n);
          const r = new ru(this.editor.editing.view.document);
          const s = this.editor.data
            .toModel(r.domToView(o))
            .getChild(0);
          const a = this.editor.editing.mapper.toModelElement(n);
          if (!a) {
            return;
          }
          const c = Array.from(s.getChildren());
          const l = Array.from(a.getChildren());
          const d = c[c.length - 1];
          const h = l[l.length - 1];
          const u = d && d.is('element', 'softBreak');
          const f = h && !h.is('element', 'softBreak');
          if (u && f) {
            c.pop();
          }
          const g = this.editor.model.schema;
          if (!AD(c, g) || !AD(l, g)) {
            return;
          }
          const m = c
            .map((t) => (t.is('$text') ? t.data : '@'))
            .join('')
            .replace(/\u00A0/g, ' ');
          const p = l
            .map((t) => (t.is('$text') ? t.data : '@'))
            .join('')
            .replace(/\u00A0/g, ' ');
          if (p === m) {
            return;
          }
          const k = Rh(p, m);
          const {
            firstChangeAt: b,
            insertions: w,
            deletions: _,
          } = CD(k);
          let v = null;
          if (e) {
            v = this.editing.mapper.toModelRange(e.getFirstRange());
          }
          const A = m.substr(b, w);
          const C = this.editor.model.createRange(
            this.editor.model.createPositionAt(a, b),
            this.editor.model.createPositionAt(a, b + _)
          );
          this.editor.execute('input', {
            text: A,
            range: C,
            resultRange: v,
          });
        }
        _handleTextMutation(t, e) {
          if (t.type != 'text') {
            return;
          }
          const n = t.newText.replace(/\u00A0/g, ' ');
          const i = t.oldText.replace(/\u00A0/g, ' ');
          if (i === n) {
            return;
          }
          const o = Rh(i, n);
          const {
            firstChangeAt: r,
            insertions: s,
            deletions: a,
          } = CD(o);
          let c = null;
          if (e) {
            c = this.editing.mapper.toModelRange(e.getFirstRange());
          }
          const l = this.editing.view.createPositionAt(t.node, r);
          const d = this.editing.mapper.toModelPosition(l);
          const h = this.editor.model.createRange(
            d,
            d.getShiftedBy(a)
          );
          const u = n.substr(r, s);
          this.editor.execute('input', {
            text: u,
            range: h,
            resultRange: c,
          });
        }
        _handleTextNodeInsertion(t) {
          if (t.type != 'children') {
            return;
          }
          const e = Nx(t);
          const n = this.editing.view.createPositionAt(
            t.node,
            e.index
          );
          const i = this.editing.mapper.toModelPosition(n);
          const o = e.values[0].data;
          this.editor.execute('input', {
            text: o.replace(/\u00A0/g, ' '),
            range: this.editor.model.createRange(i),
          });
        }
      }
      function vD(t) {
        const e = t
          .map((t) => t.node)
          .reduce((t, e) =>
            t.getCommonAncestor(e, { includeSelf: true })
          );
        if (!e) {
          return;
        }
        return e
          .getAncestors({ includeSelf: true, parentFirst: true })
          .find(
            (t) => t.is('containerElement') || t.is('rootElement')
          );
      }
      function AD(t, e) {
        return t.every((t) => e.isInline(t));
      }
      function CD(t) {
        let e = null;
        let n = null;
        for (let i = 0; i < t.length; i++) {
          const o = t[i];
          if (o != 'equal') {
            e = e === null ? i : e;
            n = i;
          }
        }
        let i = 0;
        let o = 0;
        for (let r = e; r <= n; r++) {
          if (t[r] != 'insert') {
            i++;
          }
          if (t[r] != 'delete') {
            o++;
          }
        }
        return { insertions: o, deletions: i, firstChangeAt: e };
      }
      class yD extends nt {
        static get pluginName() {
          return 'Input';
        }
        init() {
          const t = this.editor;
          const e = new bD(t, t.config.get('typing.undoStep') || 20);
          t.commands.add('input', e);
          fE(t);
          wD(t);
        }
      }
      class xD extends nt {
        static get requires() {
          return [yD, Hx];
        }
        static get pluginName() {
          return 'Typing';
        }
      }
      function ED(t, e) {
        let n = t.start;
        const i = Array.from(t.getItems()).reduce((t, i) => {
          if (!(i.is('$text') || i.is('$textProxy'))) {
            n = e.createPositionAfter(i);
            return '';
          }
          return t + i.data;
        }, '');
        return { text: i, range: e.createRange(n, t.end) };
      }
      class DD {
        constructor(t, e) {
          this.model = t;
          this.testCallback = e;
          this.hasMatch = false;
          this.set('isEnabled', true);
          this.on('change:isEnabled', () => {
            if (this.isEnabled) {
              this._startListening();
            } else {
              this.stopListening(t.document.selection);
              this.stopListening(t.document);
            }
          });
          this._startListening();
        }
        _startListening() {
          const t = this.model;
          const e = t.document;
          this.listenTo(
            e.selection,
            'change:range',
            (t, { directChange: n }) => {
              if (!n) {
                return;
              }
              if (!e.selection.isCollapsed) {
                if (this.hasMatch) {
                  this.fire('unmatched');
                  this.hasMatch = false;
                }
                return;
              }
              this._evaluateTextBeforeSelection('selection');
            }
          );
          this.listenTo(e, 'change:data', (t, e) => {
            if (e.isUndo || !e.isLocal) {
              return;
            }
            this._evaluateTextBeforeSelection('data', { batch: e });
          });
        }
        _evaluateTextBeforeSelection(t, e = {}) {
          const n = this.model;
          const i = n.document;
          const o = i.selection;
          const r = n.createRange(
            n.createPositionAt(o.focus.parent, 0),
            o.focus
          );
          const { text: s, range: a } = ED(r, n);
          const c = this.testCallback(s);
          if (!c && this.hasMatch) {
            this.fire('unmatched');
          }
          this.hasMatch = !!c;
          if (c) {
            const n = Object.assign(e, { text: s, range: a });
            if (typeof c == 'object') {
              Object.assign(n, c);
            }
            this.fire(`matched:${t}`, n);
          }
        }
      }
      et(DD, q);
      class SD extends nt {
        static get pluginName() {
          return 'TwoStepCaretMovement';
        }
        constructor(t) {
          super(t);
          this.attributes = new Set();
          this._overrideUid = null;
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = t.locale;
          const o = e.document.selection;
          this.listenTo(
            n.document,
            'arrowKey',
            (t, e) => {
              if (!o.isCollapsed) {
                return;
              }
              if (e.shiftKey || e.altKey || e.ctrlKey) {
                return;
              }
              const n = e.keyCode == Ld.arrowright;
              const r = e.keyCode == Ld.arrowleft;
              if (!n && !r) {
                return;
              }
              const s = i.contentLanguageDirection;
              let a = false;
              if ((s === 'ltr' && n) || (s === 'rtl' && r)) {
                a = this._handleForwardMovement(e);
              } else {
                a = this._handleBackwardMovement(e);
              }
              if (a === true) {
                t.stop();
              }
            },
            { context: '$text', priority: 'highest' }
          );
          this._isNextGravityRestorationSkipped = false;
          this.listenTo(o, 'change:range', (t, e) => {
            if (this._isNextGravityRestorationSkipped) {
              this._isNextGravityRestorationSkipped = false;
              return;
            }
            if (!this._isGravityOverridden) {
              return;
            }
            if (
              !e.directChange &&
              RD(o.getFirstPosition(), this.attributes)
            ) {
              return;
            }
            this._restoreGravity();
          });
        }
        registerAttribute(t) {
          this.attributes.add(t);
        }
        _handleForwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const i = n.document.selection;
          const o = i.getFirstPosition();
          if (this._isGravityOverridden) {
            return false;
          }
          if (o.isAtStart && TD(i, e)) {
            return false;
          }
          if (RD(o, e)) {
            PD(t);
            this._overrideGravity();
            return true;
          }
        }
        _handleBackwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const i = n.document.selection;
          const o = i.getFirstPosition();
          if (this._isGravityOverridden) {
            PD(t);
            this._restoreGravity();
            BD(n, e, o);
            return true;
          } else {
            if (o.isAtStart) {
              if (TD(i, e)) {
                PD(t);
                BD(n, e, o);
                return true;
              }
              return false;
            }
            if (ID(o, e)) {
              if (o.isAtEnd && !TD(i, e) && RD(o, e)) {
                PD(t);
                BD(n, e, o);
                return true;
              }
              this._isNextGravityRestorationSkipped = true;
              this._overrideGravity();
              return false;
            }
          }
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((t) =>
            t.overrideSelectionGravity()
          );
        }
        _restoreGravity() {
          this.editor.model.change((t) => {
            t.restoreSelectionGravity(this._overrideUid);
            this._overrideUid = null;
          });
        }
      }
      function TD(t, e) {
        for (const n of e) {
          if (t.hasAttribute(n)) {
            return true;
          }
        }
        return false;
      }
      function BD(t, e, n) {
        const i = n.nodeBefore;
        t.change((t) => {
          if (i) {
            t.setSelectionAttribute(i.getAttributes());
          } else {
            t.removeSelectionAttribute(e);
          }
        });
      }
      function PD(t) {
        t.preventDefault();
      }
      function ID(t, e) {
        const n = t.getShiftedBy(-1);
        return RD(n, e);
      }
      function RD(t, e) {
        const { nodeBefore: n, nodeAfter: i } = t;
        for (const t of e) {
          const e = n ? n.getAttribute(t) : undefined;
          const o = i ? i.getAttribute(t) : undefined;
          if (o !== e) {
            return true;
          }
        }
        return false;
      }
      const zD = {
        copyright: { from: '(c)', to: '©' },
        registeredTrademark: { from: '(r)', to: '®' },
        trademark: { from: '(tm)', to: '™' },
        oneHalf: {
          from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
          to: [null, '½', null],
        },
        oneThird: {
          from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
          to: [null, '⅓', null],
        },
        twoThirds: {
          from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
          to: [null, '⅔', null],
        },
        oneForth: {
          from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
          to: [null, '¼', null],
        },
        threeQuarters: {
          from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
          to: [null, '¾', null],
        },
        lessThanOrEqual: { from: '<=', to: '≤' },
        greaterThanOrEqual: { from: '>=', to: '≥' },
        notEqual: { from: '!=', to: '≠' },
        arrowLeft: { from: '<-', to: '←' },
        arrowRight: { from: '->', to: '→' },
        horizontalEllipsis: { from: '...', to: '…' },
        enDash: { from: /(^| )(--)( )$/, to: [null, '–', null] },
        emDash: { from: /(^| )(---)( )$/, to: [null, '—', null] },
        quotesPrimary: { from: HD('"'), to: [null, '“', null, '”'] },
        quotesSecondary: {
          from: HD("'"),
          to: [null, '‘', null, '’'],
        },
        quotesPrimaryEnGb: {
          from: HD("'"),
          to: [null, '‘', null, '’'],
        },
        quotesSecondaryEnGb: {
          from: HD('"'),
          to: [null, '“', null, '”'],
        },
        quotesPrimaryPl: {
          from: HD('"'),
          to: [null, '„', null, '”'],
        },
        quotesSecondaryPl: {
          from: HD("'"),
          to: [null, '‚', null, '’'],
        },
      };
      const OD = {
        symbols: ['copyright', 'registeredTrademark', 'trademark'],
        mathematical: [
          'oneHalf',
          'oneThird',
          'twoThirds',
          'oneForth',
          'threeQuarters',
          'lessThanOrEqual',
          'greaterThanOrEqual',
          'notEqual',
          'arrowLeft',
          'arrowRight',
        ],
        typography: ['horizontalEllipsis', 'enDash', 'emDash'],
        quotes: ['quotesPrimary', 'quotesSecondary'],
      };
      const FD = null && [
        'symbols',
        'mathematical',
        'typography',
        'quotes',
      ];
      class ND extends (null && Plugin) {
        static get requires() {
          return ['Delete', 'Input'];
        }
        static get pluginName() {
          return 'TextTransformation';
        }
        constructor(t) {
          super(t);
          t.config.define('typing', {
            transformations: { include: FD },
          });
        }
        init() {
          const t = this.editor.model;
          const e = t.document.selection;
          e.on('change:range', () => {
            this.isEnabled = !e.anchor.parent.is(
              'element',
              'codeBlock'
            );
          });
          this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const t = this.editor;
          const e = t.model;
          const n = t.plugins.get('Delete');
          const i = jD(t.config.get('typing.transformations'));
          const o = (t) => {
            for (const e of i) {
              const n = e.from;
              const i = n.test(t);
              if (i) {
                return { normalizedTransformation: e };
              }
            }
          };
          const r = (t, i) => {
            if (!i.batch.isTyping) {
              return;
            }
            const { from: o, to: r } = i.normalizedTransformation;
            const s = o.exec(i.text);
            const a = r(s.slice(1));
            const c = i.range;
            let l = s.index;
            e.enqueueChange((t) => {
              for (let n = 1; n < s.length; n++) {
                const i = s[n];
                const o = a[n - 1];
                if (o == null) {
                  l += i.length;
                  continue;
                }
                const r = c.start.getShiftedBy(l);
                const d = e.createRange(r, r.getShiftedBy(i.length));
                const h = VD(r);
                e.insertContent(t.createText(o, h), d);
                l += o.length;
              }
              e.enqueueChange(() => {
                n.requestUndoOnBackspace();
              });
            });
          };
          const s = new TextWatcher(t.model, o);
          s.on('matched:data', r);
          s.bind('isEnabled').to(this);
        }
      }
      function MD(t) {
        if (typeof t == 'string') {
          return new RegExp(`(${escapeRegExp(t)})$`);
        }
        return t;
      }
      function LD(t) {
        if (typeof t == 'string') {
          return () => [t];
        } else if (t instanceof Array) {
          return () => t;
        }
        return t;
      }
      function VD(t) {
        const e = t.textNode ? t.textNode : t.nodeAfter;
        return e.getAttributes();
      }
      function HD(t) {
        return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`);
      }
      function jD(t) {
        const e = t.extra || [];
        const n = t.remove || [];
        const i = (t) => !n.includes(t);
        const o = t.include.concat(e).filter(i);
        return qD(o)
          .filter(i)
          .map((t) => zD[t] || t)
          .filter((t) => typeof t === 'object')
          .map((t) => ({ from: MD(t.from), to: LD(t.to) }));
      }
      function qD(t) {
        const e = new Set();
        for (const n of t) {
          if (OD[n]) {
            for (const t of OD[n]) {
              e.add(t);
            }
          } else {
            e.add(n);
          }
        }
        return Array.from(e);
      }
      function WD(t, e, n, i) {
        return i.createRange(
          UD(t, e, n, true, i),
          UD(t, e, n, false, i)
        );
      }
      function UD(t, e, n, i, o) {
        let r = t.textNode || (i ? t.nodeBefore : t.nodeAfter);
        let s = null;
        while (r && r.getAttribute(e) == n) {
          s = r;
          r = i ? r.previousSibling : r.nextSibling;
        }
        return s ? o.createPositionAt(s, i ? 'before' : 'after') : t;
      }
      function GD(t, e, n, i) {
        const o = t.editing.view;
        const r = new Set();
        o.document.registerPostFixer((o) => {
          const s = t.model.document.selection;
          let a = false;
          if (s.hasAttribute(e)) {
            const c = WD(
              s.getFirstPosition(),
              e,
              s.getAttribute(e),
              t.model
            );
            const l = t.editing.mapper.toViewRange(c);
            for (const t of l.getItems()) {
              if (t.is('element', n) && !t.hasClass(i)) {
                o.addClass(i, t);
                r.add(t);
                a = true;
              }
            }
          }
          return a;
        });
        t.conversion.for('editingDowncast').add((t) => {
          t.on('insert', e, { priority: 'highest' });
          t.on('remove', e, { priority: 'highest' });
          t.on('attribute', e, { priority: 'highest' });
          t.on('selection', e, { priority: 'highest' });
          function e() {
            o.change((t) => {
              for (const e of r.values()) {
                t.removeClass(i, e);
                r.delete(e);
              }
            });
          }
        });
      }
      class $D extends (null && Plugin) {
        static get requires() {
          return [ContextualBalloon];
        }
        static get pluginName() {
          return 'WidgetToolbarRepository';
        }
        init() {
          const t = this.editor;
          if (t.plugins.has('BalloonToolbar')) {
            const e = t.plugins.get('BalloonToolbar');
            this.listenTo(
              e,
              'show',
              (e) => {
                if (JD(t.editing.view.document.selection)) {
                  e.stop();
                }
              },
              { priority: 'high' }
            );
          }
          this._toolbarDefinitions = new Map();
          this._balloon = this.editor.plugins.get(
            'ContextualBalloon'
          );
          this.on('change:isEnabled', () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(t.ui, 'update', () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(
            t.ui.focusTracker,
            'change:isFocused',
            () => {
              this._updateToolbarsVisibility();
            },
            { priority: 'low' }
          );
        }
        destroy() {
          super.destroy();
          for (const t of this._toolbarDefinitions.values()) {
            t.view.destroy();
          }
        }
        register(
          t,
          {
            ariaLabel: e,
            items: n,
            getRelatedElement: i,
            balloonClassName: o = 'ck-toolbar-container',
          }
        ) {
          if (!n.length) {
            logWarning('widget-toolbar-no-items', { toolbarId: t });
            return;
          }
          const r = this.editor;
          const s = r.t;
          const a = new ToolbarView(r.locale);
          a.ariaLabel = e || s('Widget toolbar');
          if (this._toolbarDefinitions.has(t)) {
            throw new CKEditorError(
              'widget-toolbar-duplicated',
              this,
              { toolbarId: t }
            );
          }
          a.fillFromConfig(n, r.ui.componentFactory);
          const c = {
            view: a,
            getRelatedElement: i,
            balloonClassName: o,
          };
          r.ui.addToolbar(a, {
            isContextual: true,
            beforeFocus: () => {
              const t = i(r.editing.view.document.selection);
              if (t) {
                this._showToolbar(c, t);
              }
            },
            afterBlur: () => {
              this._hideToolbar(c);
            },
          });
          this._toolbarDefinitions.set(t, c);
        }
        _updateToolbarsVisibility() {
          let t = 0;
          let e = null;
          let n = null;
          for (const i of this._toolbarDefinitions.values()) {
            const o = i.getRelatedElement(
              this.editor.editing.view.document.selection
            );
            if (!this.isEnabled || !o) {
              if (this._isToolbarInBalloon(i)) {
                this._hideToolbar(i);
              }
            } else if (!this.editor.ui.focusTracker.isFocused) {
              if (this._isToolbarVisible(i)) {
                this._hideToolbar(i);
              }
            } else {
              const r = o.getAncestors().length;
              if (r > t) {
                t = r;
                e = o;
                n = i;
              }
            }
          }
          if (n) {
            this._showToolbar(n, e);
          }
        }
        _hideToolbar(t) {
          this._balloon.remove(t.view);
          this.stopListening(this._balloon, 'change:visibleView');
        }
        _showToolbar(t, e) {
          if (this._isToolbarVisible(t)) {
            KD(this.editor, e);
          } else if (!this._isToolbarInBalloon(t)) {
            this._balloon.add({
              view: t.view,
              position: ZD(this.editor, e),
              balloonClassName: t.balloonClassName,
            });
            this.listenTo(this._balloon, 'change:visibleView', () => {
              for (const t of this._toolbarDefinitions.values()) {
                if (this._isToolbarVisible(t)) {
                  const e = t.getRelatedElement(
                    this.editor.editing.view.document.selection
                  );
                  KD(this.editor, e);
                }
              }
            });
          }
        }
        _isToolbarVisible(t) {
          return this._balloon.visibleView === t.view;
        }
        _isToolbarInBalloon(t) {
          return this._balloon.hasView(t.view);
        }
      }
      function KD(t, e) {
        const n = t.plugins.get('ContextualBalloon');
        const i = ZD(t, e);
        n.updatePosition(i);
      }
      function ZD(t, e) {
        const n = t.editing.view;
        const i = BalloonPanelView.defaultPositions;
        return {
          target: n.domConverter.mapViewToDom(e),
          positions: [
            i.northArrowSouth,
            i.northArrowSouthWest,
            i.northArrowSouthEast,
            i.southArrowNorth,
            i.southArrowNorthWest,
            i.southArrowNorthEast,
            i.viewportStickyNorth,
          ],
        };
      }
      function JD(t) {
        const e = t.getSelectedElement();
        return !!(e && isWidget(e));
      }
      class YD {
        constructor(t) {
          this.set('activeHandlePosition', null);
          this.set('proposedWidthPercents', null);
          this.set('proposedWidth', null);
          this.set('proposedHeight', null);
          this.set('proposedHandleHostWidth', null);
          this.set('proposedHandleHostHeight', null);
          this._options = t;
          this._referenceCoordinates = null;
        }
        begin(t, e, n) {
          const i = new ag(e);
          this.activeHandlePosition = eS(t);
          this._referenceCoordinates = XD(
            e,
            nS(this.activeHandlePosition)
          );
          this.originalWidth = i.width;
          this.originalHeight = i.height;
          this.aspectRatio = i.width / i.height;
          const o = n.style.width;
          if (o && o.match(/^\d+(\.\d*)?%$/)) {
            this.originalWidthPercents = parseFloat(o);
          } else {
            this.originalWidthPercents = QD(n, i);
          }
        }
        update(t) {
          this.proposedWidth = t.width;
          this.proposedHeight = t.height;
          this.proposedWidthPercents = t.widthPercents;
          this.proposedHandleHostWidth = t.handleHostWidth;
          this.proposedHandleHostHeight = t.handleHostHeight;
        }
      }
      et(YD, q);
      function QD(t, e) {
        const n = t.parentElement;
        const i = parseFloat(
          n.ownerDocument.defaultView.getComputedStyle(n).width
        );
        return (e.width / i) * 100;
      }
      function XD(t, e) {
        const n = new ag(t);
        const i = e.split('-');
        const o = {
          x: i[1] == 'right' ? n.right : n.left,
          y: i[0] == 'bottom' ? n.bottom : n.top,
        };
        o.x += t.ownerDocument.defaultView.scrollX;
        o.y += t.ownerDocument.defaultView.scrollY;
        return o;
      }
      function tS(t) {
        return `ck-widget__resizer__handle-${t}`;
      }
      function eS(t) {
        const e = [
          'top-left',
          'top-right',
          'bottom-right',
          'bottom-left',
        ];
        for (const n of e) {
          if (t.classList.contains(tS(n))) {
            return n;
          }
        }
      }
      function nS(t) {
        const e = t.split('-');
        const n = {
          top: 'bottom',
          bottom: 'top',
          left: 'right',
          right: 'left',
        };
        return `${n[e[0]]}-${n[e[1]]}`;
      }
      class iS extends Dw {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-size-view',
                t.to('_viewPosition', (t) =>
                  t ? `ck-orientation-${t}` : ''
                ),
              ],
              style: {
                display: t.if('_isVisible', 'none', (t) => !t),
              },
            },
            children: [{ text: t.to('_label') }],
          });
        }
        _bindToState(t, e) {
          this.bind('_isVisible').to(
            e,
            'proposedWidth',
            e,
            'proposedHeight',
            (t, e) => t !== null && e !== null
          );
          this.bind('_label').to(
            e,
            'proposedHandleHostWidth',
            e,
            'proposedHandleHostHeight',
            e,
            'proposedWidthPercents',
            (e, n, i) => {
              if (t.unit === 'px') {
                return `${e}×${n}`;
              } else {
                return `${i}%`;
              }
            }
          );
          this.bind('_viewPosition').to(
            e,
            'activeHandlePosition',
            e,
            'proposedHandleHostWidth',
            e,
            'proposedHandleHostHeight',
            (t, e, n) => (e < 50 || n < 50 ? 'above-center' : t)
          );
        }
        _dismiss() {
          this.unbind();
          this._isVisible = false;
        }
      }
      class oS {
        constructor(t) {
          this._options = t;
          this._viewResizerWrapper = null;
          this.set('isEnabled', true);
          this.decorate('begin');
          this.decorate('cancel');
          this.decorate('commit');
          this.decorate('updateSize');
          this.on(
            'commit',
            (t) => {
              if (
                !this.state.proposedWidth &&
                !this.state.proposedWidthPercents
              ) {
                this._cleanup();
                t.stop();
              }
            },
            { priority: 'high' }
          );
          this.on('change:isEnabled', () => {
            if (this.isEnabled) {
              this.redraw();
            }
          });
        }
        attach() {
          const t = this;
          const e = this._options.viewElement;
          const n = this._options.editor.editing.view;
          n.change((n) => {
            const i = n.createUIElement(
              'div',
              { class: 'ck ck-reset_all ck-widget__resizer' },
              function (e) {
                const n = this.toDomElement(e);
                t._appendHandles(n);
                t._appendSizeUI(n);
                t.on('change:isEnabled', (t, e, i) => {
                  n.style.display = i ? '' : 'none';
                });
                n.style.display = t.isEnabled ? '' : 'none';
                return n;
              }
            );
            n.insert(n.createPositionAt(e, 'end'), i);
            n.addClass('ck-widget_with-resizer', e);
            this._viewResizerWrapper = i;
          });
        }
        begin(t) {
          this.state = new YD(this._options);
          this._sizeView._bindToState(this._options, this.state);
          this._initialViewWidth =
            this._options.viewElement.getStyle('width');
          this.state.begin(
            t,
            this._getHandleHost(),
            this._getResizeHost()
          );
        }
        updateSize(t) {
          const e = this._proposeNewSize(t);
          const n = this._options.editor.editing.view;
          n.change((t) => {
            const n = this._options.unit || '%';
            const i = (n === '%' ? e.widthPercents : e.width) + n;
            t.setStyle('width', i, this._options.viewElement);
          });
          const i = this._getHandleHost();
          const o = new ag(i);
          e.handleHostWidth = Math.round(o.width);
          e.handleHostHeight = Math.round(o.height);
          const r = new ag(i);
          e.width = Math.round(r.width);
          e.height = Math.round(r.height);
          this.redraw(o);
          this.state.update(e);
        }
        commit() {
          const t = this._options.unit || '%';
          const e =
            (t === '%'
              ? this.state.proposedWidthPercents
              : this.state.proposedWidth) + t;
          this._options.editor.editing.view.change(() => {
            this._cleanup();
            this._options.onCommit(e);
          });
        }
        cancel() {
          this._cleanup();
        }
        destroy() {
          this.cancel();
        }
        redraw(t) {
          const e = this._domResizerWrapper;
          if (!aS(e)) {
            return;
          }
          const n = e.parentElement;
          const i = this._getHandleHost();
          const o = this._viewResizerWrapper;
          const r = [
            o.getStyle('width'),
            o.getStyle('height'),
            o.getStyle('left'),
            o.getStyle('top'),
          ];
          let s;
          if (n.isSameNode(i)) {
            const e = t || new ag(i);
            s = [
              e.width + 'px',
              e.height + 'px',
              undefined,
              undefined,
            ];
          } else {
            s = [
              i.offsetWidth + 'px',
              i.offsetHeight + 'px',
              i.offsetLeft + 'px',
              i.offsetTop + 'px',
            ];
          }
          if (Ha(r, s) !== 'same') {
            this._options.editor.editing.view.change((t) => {
              t.setStyle(
                { width: s[0], height: s[1], left: s[2], top: s[3] },
                o
              );
            });
          }
        }
        containsHandle(t) {
          return this._domResizerWrapper.contains(t);
        }
        static isResizeHandle(t) {
          return t.classList.contains('ck-widget__resizer__handle');
        }
        _cleanup() {
          this._sizeView._dismiss();
          const t = this._options.editor.editing.view;
          t.change((t) => {
            t.setStyle(
              'width',
              this._initialViewWidth,
              this._options.viewElement
            );
          });
        }
        _proposeNewSize(t) {
          const e = this.state;
          const n = sS(t);
          const i = this._options.isCentered
            ? this._options.isCentered(this)
            : true;
          const o = {
            x: e._referenceCoordinates.x - (n.x + e.originalWidth),
            y: n.y - e.originalHeight - e._referenceCoordinates.y,
          };
          if (i && e.activeHandlePosition.endsWith('-right')) {
            o.x = n.x - (e._referenceCoordinates.x + e.originalWidth);
          }
          if (i) {
            o.x *= 2;
          }
          const r = {
            width: Math.abs(e.originalWidth + o.x),
            height: Math.abs(e.originalHeight + o.y),
          };
          r.dominant =
            r.width / e.aspectRatio > r.height ? 'width' : 'height';
          r.max = r[r.dominant];
          const s = { width: r.width, height: r.height };
          if (r.dominant == 'width') {
            s.height = s.width / e.aspectRatio;
          } else {
            s.width = s.height * e.aspectRatio;
          }
          return {
            width: Math.round(s.width),
            height: Math.round(s.height),
            widthPercents: Math.min(
              Math.round(
                (e.originalWidthPercents / e.originalWidth) *
                  s.width *
                  100
              ) / 100,
              100
            ),
          };
        }
        _getResizeHost() {
          const t = this._domResizerWrapper.parentElement;
          return this._options.getResizeHost(t);
        }
        _getHandleHost() {
          const t = this._domResizerWrapper.parentElement;
          return this._options.getHandleHost(t);
        }
        get _domResizerWrapper() {
          return this._options.editor.editing.view.domConverter.mapViewToDom(
            this._viewResizerWrapper
          );
        }
        _appendHandles(t) {
          const e = [
            'top-left',
            'top-right',
            'bottom-right',
            'bottom-left',
          ];
          for (const n of e) {
            t.appendChild(
              new Yb({
                tag: 'div',
                attributes: {
                  class: `ck-widget__resizer__handle ${rS(n)}`,
                },
              }).render()
            );
          }
        }
        _appendSizeUI(t) {
          this._sizeView = new iS();
          this._sizeView.render();
          t.appendChild(this._sizeView.element);
        }
      }
      et(oS, q);
      function rS(t) {
        return `ck-widget__resizer__handle-${t}`;
      }
      function sS(t) {
        return { x: t.pageX, y: t.pageY };
      }
      function aS(t) {
        return t && t.ownerDocument && t.ownerDocument.contains(t);
      }
      var cS = n(2263);
      var lS = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      lS.insert = 'head';
      lS.singleton = true;
      var dS = Lh()(cS.Z, lS);
      const hS = cS.Z.locals || {};
      class uS extends nt {
        static get pluginName() {
          return 'WidgetResize';
        }
        init() {
          const t = this.editor.editing;
          const e = Sa.window.document;
          this.set('visibleResizer', null);
          this.set('_activeResizer', null);
          this._resizers = new Map();
          t.view.addObserver(ny);
          this._observer = Object.create(uu);
          this.listenTo(
            t.view.document,
            'mousedown',
            this._mouseDownListener.bind(this),
            { priority: 'high' }
          );
          this._observer.listenTo(
            e,
            'mousemove',
            this._mouseMoveListener.bind(this)
          );
          this._observer.listenTo(
            e,
            'mouseup',
            this._mouseUpListener.bind(this)
          );
          const n = () => {
            if (this.visibleResizer) {
              this.visibleResizer.redraw();
            }
          };
          this._redrawFocusedResizerThrottled = WE(n, 200);
          this.on('change:visibleResizer', n);
          this.editor.ui.on(
            'update',
            this._redrawFocusedResizerThrottled
          );
          this.editor.model.document.on(
            'change',
            () => {
              for (const [t, e] of this._resizers) {
                if (!t.isAttached()) {
                  this._resizers.delete(t);
                  e.destroy();
                }
              }
            },
            { priority: 'lowest' }
          );
          this._observer.listenTo(
            Sa.window,
            'resize',
            this._redrawFocusedResizerThrottled
          );
          const i = this.editor.editing.view.document.selection;
          i.on('change', () => {
            const t = i.getSelectedElement();
            this.visibleResizer =
              this.getResizerByViewElement(t) || null;
          });
        }
        destroy() {
          this._observer.stopListening();
          for (const t of this._resizers.values()) {
            t.destroy();
          }
          this._redrawFocusedResizerThrottled.cancel();
        }
        attachTo(t) {
          const e = new oS(t);
          const n = this.editor.plugins;
          e.attach();
          if (n.has('WidgetToolbarRepository')) {
            const t = n.get('WidgetToolbarRepository');
            e.on(
              'begin',
              () => {
                t.forceDisabled('resize');
              },
              { priority: 'lowest' }
            );
            e.on(
              'cancel',
              () => {
                t.clearForceDisabled('resize');
              },
              { priority: 'highest' }
            );
            e.on(
              'commit',
              () => {
                t.clearForceDisabled('resize');
              },
              { priority: 'highest' }
            );
          }
          this._resizers.set(t.viewElement, e);
          const i = this.editor.editing.view.document.selection;
          const o = i.getSelectedElement();
          if (this.getResizerByViewElement(o) == e) {
            this.visibleResizer = e;
          }
          return e;
        }
        getResizerByViewElement(t) {
          return this._resizers.get(t);
        }
        _getResizerByHandle(t) {
          for (const e of this._resizers.values()) {
            if (e.containsHandle(t)) {
              return e;
            }
          }
        }
        _mouseDownListener(t, e) {
          const n = e.domTarget;
          if (!oS.isResizeHandle(n)) {
            return;
          }
          this._activeResizer = this._getResizerByHandle(n);
          if (this._activeResizer) {
            this._activeResizer.begin(n);
            t.stop();
            e.preventDefault();
          }
        }
        _mouseMoveListener(t, e) {
          if (this._activeResizer) {
            this._activeResizer.updateSize(e);
          }
        }
        _mouseUpListener() {
          if (this._activeResizer) {
            this._activeResizer.commit();
            this._activeResizer = null;
          }
        }
      }
      et(uS, q);
      function fS(t) {
        return t.createContainerElement(
          'span',
          { class: 'image-inline' },
          t.createEmptyElement('img')
        );
      }
      function gS(t) {
        return t.createContainerElement(
          'figure',
          { class: 'image' },
          [t.createEmptyElement('img'), t.createSlot()]
        );
      }
      function mS(t, e) {
        const n = t.plugins.get('ImageUtils');
        const i =
          t.plugins.has('ImageInlineEditing') &&
          t.plugins.has('ImageBlockEditing');
        return (t) => {
          if (!n.isInlineImageView(t)) {
            return null;
          }
          if (!i) {
            return o(t);
          }
          const r = t.findAncestor(n.isBlockImageView)
            ? 'imageBlock'
            : 'imageInline';
          if (r !== e) {
            return null;
          }
          return o(t);
        };
        function o(t) {
          const e = { name: true };
          if (t.hasAttribute('src')) {
            e.attributes = ['src'];
          }
          return e;
        }
      }
      function pS(t, e) {
        const n = Xf(e.getSelectedBlocks());
        if (!n || t.isObject(n)) {
          return 'imageBlock';
        }
        if (n.isEmpty && n.name != 'listItem') {
          return 'imageBlock';
        }
        return 'imageInline';
      }
      class kS extends nt {
        static get pluginName() {
          return 'ImageUtils';
        }
        isImage(t) {
          return this.isInlineImage(t) || this.isBlockImage(t);
        }
        isInlineImageView(t) {
          return !!t && t.is('element', 'img');
        }
        isBlockImageView(t) {
          return (
            !!t && t.is('element', 'figure') && t.hasClass('image')
          );
        }
        insertImage(t = {}, e = null, n = null) {
          const i = this.editor;
          const o = i.model;
          const r = o.document.selection;
          n = vS(i, e || r, n);
          t = { ...Object.fromEntries(r.getAttributes()), ...t };
          for (const e in t) {
            if (!o.schema.checkAttribute(n, e)) {
              delete t[e];
            }
          }
          return o.change((i) => {
            const r = i.createElement(n, t);
            o.insertObject(r, e, null, {
              setSelection: 'on',
              findOptimalPosition: !e && n != 'imageInline',
            });
            if (r.parent) {
              return r;
            }
            return null;
          });
        }
        getClosestSelectedImageWidget(t) {
          const e = t.getFirstPosition();
          if (!e) {
            return null;
          }
          const n = t.getSelectedElement();
          if (n && this.isImageWidget(n)) {
            return n;
          }
          let i = e.parent;
          while (i) {
            if (i.is('element') && this.isImageWidget(i)) {
              return i;
            }
            i = i.parent;
          }
          return null;
        }
        getClosestSelectedImageElement(t) {
          const e = t.getSelectedElement();
          return this.isImage(e)
            ? e
            : t.getFirstPosition().findAncestor('imageBlock');
        }
        isImageAllowed() {
          const t = this.editor.model;
          const e = t.document.selection;
          return bS(this.editor, e) && wS(e);
        }
        toImageWidget(t, e, n) {
          e.setCustomProperty('image', true, t);
          const i = () => {
            const e = this.findViewImgElement(t);
            const i = e.getAttribute('alt');
            return i ? `${i} ${n}` : n;
          };
          return Jx(t, e, { label: i });
        }
        isImageWidget(t) {
          return !!t.getCustomProperty('image') && Zx(t);
        }
        isBlockImage(t) {
          return !!t && t.is('element', 'imageBlock');
        }
        isInlineImage(t) {
          return !!t && t.is('element', 'imageInline');
        }
        findViewImgElement(t) {
          if (this.isInlineImageView(t)) {
            return t;
          }
          const e = this.editor.editing.view;
          for (const { item: n } of e.createRangeIn(t)) {
            if (this.isInlineImageView(n)) {
              return n;
            }
          }
        }
      }
      function bS(t, e) {
        const n = vS(t, e);
        if (n == 'imageBlock') {
          const n = _S(e, t.model);
          if (t.model.schema.checkChild(n, 'imageBlock')) {
            return true;
          }
        } else if (
          t.model.schema.checkChild(e.focus, 'imageInline')
        ) {
          return true;
        }
        return false;
      }
      function wS(t) {
        return [...t.focus.getAncestors()].every(
          (t) => !t.is('element', 'imageBlock')
        );
      }
      function _S(t, e) {
        const n = iE(t, e);
        const i = n.start.parent;
        if (i.isEmpty && !i.is('element', '$root')) {
          return i.parent;
        }
        return i;
      }
      function vS(t, e, n) {
        const i = t.model.schema;
        const o = t.config.get('image.insert.type');
        if (!t.plugins.has('ImageBlockEditing')) {
          return 'imageInline';
        }
        if (!t.plugins.has('ImageInlineEditing')) {
          return 'imageBlock';
        }
        if (n) {
          return n;
        }
        if (o === 'inline') {
          return 'imageInline';
        }
        if (o === 'block') {
          return 'imageBlock';
        }
        if (e.is('selection')) {
          return pS(i, e);
        }
        return i.checkChild(e, 'imageInline')
          ? 'imageInline'
          : 'imageBlock';
      }
      const AS = new RegExp(
        String(
          /^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/
            .source +
            /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/
              .source +
            /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source +
            /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source
        )
      );
      class CS extends nt {
        static get requires() {
          return [aD, kS, kD, Hx];
        }
        static get pluginName() {
          return 'AutoImage';
        }
        constructor(t) {
          super(t);
          this._timeoutId = null;
          this._positionToInsert = null;
        }
        init() {
          const t = this.editor;
          const e = t.model.document;
          this.listenTo(
            t.plugins.get('ClipboardPipeline'),
            'inputTransformation',
            () => {
              const t = e.selection.getFirstRange();
              const n = db.fromPosition(t.start);
              n.stickiness = 'toPrevious';
              const i = db.fromPosition(t.end);
              i.stickiness = 'toNext';
              e.once(
                'change:data',
                () => {
                  this._embedImageBetweenPositions(n, i);
                  n.detach();
                  i.detach();
                },
                { priority: 'high' }
              );
            }
          );
          t.commands.get('undo').on(
            'execute',
            () => {
              if (this._timeoutId) {
                Sa.window.clearTimeout(this._timeoutId);
                this._positionToInsert.detach();
                this._timeoutId = null;
                this._positionToInsert = null;
              }
            },
            { priority: 'high' }
          );
        }
        _embedImageBetweenPositions(t, e) {
          const n = this.editor;
          const i = new Jg(t, e);
          const o = i.getWalker({ ignoreElementEnd: true });
          const r = Object.fromEntries(
            n.model.document.selection.getAttributes()
          );
          const s = this.editor.plugins.get('ImageUtils');
          let a = '';
          for (const t of o) {
            if (t.item.is('$textProxy')) {
              a += t.item.data;
            }
          }
          a = a.trim();
          if (!a.match(AS)) {
            i.detach();
            return;
          }
          this._positionToInsert = db.fromPosition(t);
          this._timeoutId = Sa.window.setTimeout(() => {
            const t = n.commands.get('insertImage');
            if (!t.isEnabled) {
              i.detach();
              return;
            }
            n.model.change((t) => {
              this._timeoutId = null;
              t.remove(i);
              i.detach();
              let e;
              if (
                this._positionToInsert.root.rootName !== '$graveyard'
              ) {
                e = this._positionToInsert.toPosition();
              }
              s.insertImage({ ...r, src: a }, e);
              this._positionToInsert.detach();
              this._positionToInsert = null;
            });
            n.plugins.get('Delete').requestUndoOnBackspace();
          }, 100);
        }
      }
      function yS(t, e, n) {
        var i = t.length;
        n = n === undefined ? i : n;
        return !e && n >= i ? t : jc(t, e, n);
      }
      const xS = yS;
      var ES = '\\ud800-\\udfff',
        DS = '\\u0300-\\u036f',
        SS = '\\ufe20-\\ufe2f',
        TS = '\\u20d0-\\u20ff',
        BS = DS + SS + TS,
        PS = '\\ufe0e\\ufe0f';
      var IS = '\\u200d';
      var RS = RegExp('[' + IS + ES + BS + PS + ']');
      function zS(t) {
        return RS.test(t);
      }
      const OS = zS;
      function FS(t) {
        return t.split('');
      }
      const NS = FS;
      var MS = '\\ud800-\\udfff',
        LS = '\\u0300-\\u036f',
        VS = '\\ufe20-\\ufe2f',
        HS = '\\u20d0-\\u20ff',
        jS = LS + VS + HS,
        qS = '\\ufe0e\\ufe0f';
      var WS = '[' + MS + ']',
        US = '[' + jS + ']',
        GS = '\\ud83c[\\udffb-\\udfff]',
        $S = '(?:' + US + '|' + GS + ')',
        KS = '[^' + MS + ']',
        ZS = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        JS = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        YS = '\\u200d';
      var QS = $S + '?',
        XS = '[' + qS + ']?',
        tT =
          '(?:' +
          YS +
          '(?:' +
          [KS, ZS, JS].join('|') +
          ')' +
          XS +
          QS +
          ')*',
        eT = XS + QS + tT,
        nT = '(?:' + [KS + US + '?', US, ZS, JS, WS].join('|') + ')';
      var iT = RegExp(GS + '(?=' + GS + ')|' + nT + eT, 'g');
      function oT(t) {
        return t.match(iT) || [];
      }
      const rT = oT;
      function sT(t) {
        return OS(t) ? rT(t) : NS(t);
      }
      const aT = sT;
      function cT(t) {
        return function (e) {
          e = Pc(e);
          var n = OS(e) ? aT(e) : undefined;
          var i = n ? n[0] : e.charAt(0);
          var o = n ? xS(n, 1).join('') : e.slice(1);
          return i[t]() + o;
        };
      }
      const lT = cT;
      var dT = lT('toUpperCase');
      const hT = dT;
      const uT =
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
      const fT =
        /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
      const gT =
        /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
      const mT = /^((\w+:(\/{2,})?)|(\W))/i;
      const pT = 'Ctrl+K';
      function kT(t) {
        return (
          t.is('attributeElement') && !!t.getCustomProperty('link')
        );
      }
      function bT(t, { writer: e }) {
        const n = e.createAttributeElement(
          'a',
          { href: t },
          { priority: 5 }
        );
        e.setCustomProperty('link', true, n);
        return n;
      }
      function wT(t) {
        t = String(t);
        return _T(t) ? t : '#';
      }
      function _T(t) {
        const e = t.replace(uT, '');
        return e.match(fT);
      }
      function vT(t, e) {
        const n = {
          'Open in a new tab': t('Open in a new tab'),
          Downloadable: t('Downloadable'),
        };
        e.forEach((t) => {
          if (t.label && n[t.label]) {
            t.label = n[t.label];
          }
          return t;
        });
        return e;
      }
      function AT(t) {
        const e = [];
        if (t) {
          for (const [n, i] of Object.entries(t)) {
            const t = Object.assign({}, i, { id: `link${hT(n)}` });
            e.push(t);
          }
        }
        return e;
      }
      function CT(t, e) {
        if (!t) {
          return false;
        }
        return e.checkAttribute(t.name, 'linkHref');
      }
      function yT(t) {
        return gT.test(t);
      }
      function xT(t, e) {
        const n = yT(t) ? 'mailto:' : e;
        const i = !!n && !mT.test(t);
        return t && i ? n + t : t;
      }
      function ET(t) {
        window.open(t, '_blank', 'noopener');
      }
      const DT = 4;
      const ST = new RegExp(
        '(^|\\s)' +
          '(' +
          '(' +
          '(?:(?:(?:https?|ftp):)?\\/\\/)' +
          '(?:\\S+(?::\\S*)?@)?' +
          '(?:' +
          '(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' +
          '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' +
          '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))' +
          '|' +
          '(' +
          '((?!www\\.)|(www\\.))' +
          '(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+' +
          '(?:[a-z\\u00a1-\\uffff]{2,63})' +
          ')' +
          ')' +
          '(?::\\d{2,5})?' +
          '(?:[/?#]\\S*)?' +
          ')' +
          '|' +
          '(' +
          '(www.|(\\S+@))' +
          '((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+' +
          '(?:[a-z\\u00a1-\\uffff]{2,63})' +
          ')' +
          ')$',
        'i'
      );
      const TT = 2;
      class BT extends nt {
        static get requires() {
          return [Hx];
        }
        static get pluginName() {
          return 'AutoLink';
        }
        init() {
          const t = this.editor;
          const e = t.model.document.selection;
          e.on('change:range', () => {
            this.isEnabled = !e.anchor.parent.is(
              'element',
              'codeBlock'
            );
          });
          this._enableTypingHandling();
        }
        afterInit() {
          this._enableEnterHandling();
          this._enableShiftEnterHandling();
        }
        _enableTypingHandling() {
          const t = this.editor;
          const e = new DD(t.model, (t) => {
            if (!PT(t)) {
              return;
            }
            const e = IT(t.substr(0, t.length - 1));
            if (e) {
              return { url: e };
            }
          });
          e.on('matched:data', (e, n) => {
            const { batch: i, range: o, url: r } = n;
            if (!i.isTyping) {
              return;
            }
            const s = o.end.getShiftedBy(-1);
            const a = s.getShiftedBy(-r.length);
            const c = t.model.createRange(a, s);
            this._applyAutoLink(r, c);
          });
          e.bind('isEnabled').to(this);
        }
        _enableEnterHandling() {
          const t = this.editor;
          const e = t.model;
          const n = t.commands.get('enter');
          if (!n) {
            return;
          }
          n.on('execute', () => {
            const t = e.document.selection.getFirstPosition();
            if (!t.parent.previousSibling) {
              return;
            }
            const n = e.createRangeIn(t.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(n);
          });
        }
        _enableShiftEnterHandling() {
          const t = this.editor;
          const e = t.model;
          const n = t.commands.get('shiftEnter');
          if (!n) {
            return;
          }
          n.on('execute', () => {
            const t = e.document.selection.getFirstPosition();
            const n = e.createRange(
              e.createPositionAt(t.parent, 0),
              t.getShiftedBy(-1)
            );
            this._checkAndApplyAutoLinkOnRange(n);
          });
        }
        _checkAndApplyAutoLinkOnRange(t) {
          const e = this.editor.model;
          const { text: n, range: i } = ED(t, e);
          const o = IT(n);
          if (o) {
            const t = e.createRange(
              i.end.getShiftedBy(-o.length),
              i.end
            );
            this._applyAutoLink(o, t);
          }
        }
        _applyAutoLink(t, e) {
          const n = this.editor.model;
          const i = this.editor.plugins.get('Delete');
          if (!this.isEnabled || !RT(e, n)) {
            return;
          }
          n.enqueueChange((o) => {
            const r = this.editor.config.get('link.defaultProtocol');
            const s = xT(t, r);
            o.setAttribute('linkHref', s, e);
            n.enqueueChange(() => {
              i.requestUndoOnBackspace();
            });
          });
        }
      }
      function PT(t) {
        return (
          t.length > DT &&
          t[t.length - 1] === ' ' &&
          t[t.length - 2] !== ' '
        );
      }
      function IT(t) {
        const e = ST.exec(t);
        return e ? e[TT] : null;
      }
      function RT(t, e) {
        return e.schema.checkAttributeInSelection(
          e.createSelection(t),
          'linkHref'
        );
      }
      class zT extends ot {
        constructor(t, e) {
          super(t);
          this.attributeKey = e;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = this._getValueFromFirstAllowedNode();
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            this.attributeKey
          );
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o =
            t.forceValue === undefined ? !this.value : t.forceValue;
          e.change((t) => {
            if (i.isCollapsed) {
              if (o) {
                t.setSelectionAttribute(this.attributeKey, true);
              } else {
                t.removeSelectionAttribute(this.attributeKey);
              }
            } else {
              const n = e.schema.getValidRanges(
                i.getRanges(),
                this.attributeKey
              );
              for (const e of n) {
                if (o) {
                  t.setAttribute(this.attributeKey, o, e);
                } else {
                  t.removeAttribute(this.attributeKey, e);
                }
              }
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const t = this.editor.model;
          const e = t.schema;
          const n = t.document.selection;
          if (n.isCollapsed) {
            return n.hasAttribute(this.attributeKey);
          }
          for (const t of n.getRanges()) {
            for (const n of t.getItems()) {
              if (e.checkAttribute(n, this.attributeKey)) {
                return n.hasAttribute(this.attributeKey);
              }
            }
          }
          return false;
        }
      }
      const OT = 'bold';
      class FT extends nt {
        static get pluginName() {
          return 'BoldEditing';
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', { allowAttributes: OT });
          t.model.schema.setAttributeProperties(OT, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: OT,
            view: 'strong',
            upcastAlso: [
              'b',
              (t) => {
                const e = t.getStyle('font-weight');
                if (!e) {
                  return null;
                }
                if (e == 'bold' || Number(e) >= 600) {
                  return { name: true, styles: ['font-weight'] };
                }
              },
            ],
          });
          t.commands.add(OT, new zT(t, OT));
          t.keystrokes.set('CTRL+B', OT);
        }
      }
      const NT =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
      const MT = 'bold';
      class LT extends nt {
        static get pluginName() {
          return 'BoldUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(MT, (n) => {
            const i = t.commands.get(MT);
            const o = new iv(n);
            o.set({
              label: e('Bold'),
              icon: NT,
              keystroke: 'CTRL+B',
              tooltip: true,
              isToggleable: true,
            });
            o.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled');
            this.listenTo(o, 'execute', () => {
              t.execute(MT);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class VT extends nt {
        static get requires() {
          return [FT, LT];
        }
        static get pluginName() {
          return 'Bold';
        }
      }
      class HT extends ot {
        execute() {
          const t = this.editor.model;
          const e = t.document;
          t.change((n) => {
            qT(t, n, e.selection);
            this.fire('afterExecute', { writer: n });
          });
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.isEnabled = jT(t.schema, e.selection);
        }
      }
      function jT(t, e) {
        if (e.rangeCount > 1) {
          return false;
        }
        const n = e.anchor;
        if (!n || !t.checkChild(n, 'softBreak')) {
          return false;
        }
        const i = e.getFirstRange();
        const o = i.start.parent;
        const r = i.end.parent;
        if ((UT(o, t) || UT(r, t)) && o !== r) {
          return false;
        }
        return true;
      }
      function qT(t, e, n) {
        const i = n.isCollapsed;
        const o = n.getFirstRange();
        const r = o.start.parent;
        const s = o.end.parent;
        const a = r == s;
        if (i) {
          const i = Dx(t.schema, n.getAttributes());
          WT(t, e, o.end);
          e.removeSelectionAttribute(n.getAttributeKeys());
          e.setSelectionAttribute(i);
        } else {
          const i = !(o.start.isAtStart && o.end.isAtEnd);
          t.deleteContent(n, { leaveUnmerged: i });
          if (a) {
            WT(t, e, n.focus);
          } else {
            if (i) {
              e.setSelection(s, 0);
            }
          }
        }
      }
      function WT(t, e, n) {
        const i = e.createElement('softBreak');
        t.insertContent(i, n);
        e.setSelection(i, 'after');
      }
      function UT(t, e) {
        if (t.is('rootElement')) {
          return false;
        }
        return e.isLimit(t) || UT(t.parent, e);
      }
      class GT extends nt {
        static get pluginName() {
          return 'ShiftEnter';
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.conversion;
          const i = t.editing.view;
          const o = i.document;
          e.register('softBreak', {
            allowWhere: '$text',
            isInline: true,
          });
          n.for('upcast').elementToElement({
            model: 'softBreak',
            view: 'br',
          });
          n.for('downcast').elementToElement({
            model: 'softBreak',
            view: (t, { writer: e }) => e.createEmptyElement('br'),
          });
          i.addObserver(Px);
          t.commands.add('shiftEnter', new HT(t));
          this.listenTo(
            o,
            'enter',
            (e, n) => {
              n.preventDefault();
              if (!n.isSoft) {
                return;
              }
              t.execute('shiftEnter');
              i.scrollToTheSelection();
            },
            { priority: 'low' }
          );
        }
      }
      class $T extends ot {
        constructor(t) {
          super(t);
          this.affectsData = false;
        }
        execute() {
          const t = this.editor.model;
          const e = t.document.selection;
          let n = t.schema.getLimitElement(e);
          if (e.containsEntireContent(n) || !KT(t.schema, n)) {
            do {
              n = n.parent;
              if (!n) {
                return;
              }
            } while (!KT(t.schema, n));
          }
          t.change((t) => {
            t.setSelection(n, 'in');
          });
        }
      }
      function KT(t, e) {
        return (
          t.isLimit(e) &&
          (t.checkChild(e, '$text') || t.checkChild(e, 'paragraph'))
        );
      }
      const ZT = jd('Ctrl+A');
      class JT extends nt {
        static get pluginName() {
          return 'SelectAllEditing';
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          t.commands.add('selectAll', new $T(t));
          this.listenTo(n, 'keydown', (e, n) => {
            if (Hd(n) === ZT) {
              t.execute('selectAll');
              n.preventDefault();
            }
          });
        }
      }
      const YT =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
      class QT extends nt {
        static get pluginName() {
          return 'SelectAllUI';
        }
        init() {
          const t = this.editor;
          t.ui.componentFactory.add('selectAll', (e) => {
            const n = t.commands.get('selectAll');
            const i = new iv(e);
            const o = e.t;
            i.set({
              label: o('Select all'),
              icon: YT,
              keystroke: 'Ctrl+A',
              tooltip: true,
            });
            i.bind('isOn', 'isEnabled').to(n, 'value', 'isEnabled');
            this.listenTo(i, 'execute', () => {
              t.execute('selectAll');
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class XT extends nt {
        static get requires() {
          return [JT, QT];
        }
        static get pluginName() {
          return 'SelectAll';
        }
      }
      class tB extends nt {
        static get requires() {
          return [aD, Ix, XT, GT, xD, kD];
        }
        static get pluginName() {
          return 'Essentials';
        }
      }
      class eB extends ot {
        constructor(t, e) {
          super(t);
          this.attributeKey = e;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = e.selection.getAttribute(this.attributeKey);
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            this.attributeKey
          );
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = t.value;
          e.change((t) => {
            if (i.isCollapsed) {
              if (o) {
                t.setSelectionAttribute(this.attributeKey, o);
              } else {
                t.removeSelectionAttribute(this.attributeKey);
              }
            } else {
              const n = e.schema.getValidRanges(
                i.getRanges(),
                this.attributeKey
              );
              for (const e of n) {
                if (o) {
                  t.setAttribute(this.attributeKey, o, e);
                } else {
                  t.removeAttribute(this.attributeKey, e);
                }
              }
            }
          });
        }
      }
      class nB extends ya {
        constructor(t) {
          super(t);
          this.set('isEmpty', true);
          this.on('change', () => {
            this.set('isEmpty', this.length === 0);
          });
        }
        add(t, e) {
          if (this.find((e) => e.color === t.color)) {
            return;
          }
          super.add(t, e);
        }
        hasColor(t) {
          return !!this.find((e) => e.color === t);
        }
      }
      et(nB, q);
      var iB = n(2585);
      var oB = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      oB.insert = 'head';
      oB.singleton = true;
      var rB = Lh()(iB.Z, oB);
      const sB = iB.Z.locals || {};
      class aB extends Dw {
        constructor(
          t,
          {
            colors: e,
            columns: n,
            removeButtonLabel: i,
            documentColorsLabel: o,
            documentColorsCount: r,
          }
        ) {
          super(t);
          this.items = this.createCollection();
          this.colorDefinitions = e;
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this.set('selectedColor');
          this.removeButtonLabel = i;
          this.columns = n;
          this.documentColors = new nB();
          this.documentColorsCount = r;
          this._focusables = new Kb();
          this._focusCycler = new Iv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: 'shift + tab',
              focusNext: 'tab',
            },
          });
          this._documentColorsLabel = o;
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-color-table'] },
            children: this.items,
          });
          this.items.add(this._createRemoveColorButton());
        }
        updateDocumentColors(t, e) {
          const n = t.document;
          const i = this.documentColorsCount;
          this.documentColors.clear();
          for (const o of n.getRootNames()) {
            const r = n.getRoot(o);
            const s = t.createRangeIn(r);
            for (const t of s.getItems()) {
              if (t.is('$textProxy') && t.hasAttribute(e)) {
                this._addColorToDocumentColors(t.getAttribute(e));
                if (this.documentColors.length >= i) {
                  return;
                }
              }
            }
          }
        }
        updateSelectedColors() {
          const t = this.documentColorsGrid;
          const e = this.staticColorsGrid;
          const n = this.selectedColor;
          e.selectedColor = n;
          if (t) {
            t.selectedColor = n;
          }
        }
        render() {
          super.render();
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        appendGrids() {
          if (this.staticColorsGrid) {
            return;
          }
          this.staticColorsGrid = this._createStaticColorsGrid();
          this.items.add(this.staticColorsGrid);
          this.focusTracker.add(this.staticColorsGrid.element);
          this._focusables.add(this.staticColorsGrid);
          if (this.documentColorsCount) {
            const t = Yb.bind(
              this.documentColors,
              this.documentColors
            );
            const e = new yA(this.locale);
            e.text = this._documentColorsLabel;
            e.extendTemplate({
              attributes: {
                class: [
                  'ck',
                  'ck-color-grid__label',
                  t.if('isEmpty', 'ck-hidden'),
                ],
              },
            });
            this.items.add(e);
            this.documentColorsGrid =
              this._createDocumentColorsGrid();
            this.items.add(this.documentColorsGrid);
            this.focusTracker.add(this.documentColorsGrid.element);
            this._focusables.add(this.documentColorsGrid);
          }
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        _createRemoveColorButton() {
          const t = new iv();
          t.set({
            withText: true,
            icon: M_.eraser,
            label: this.removeButtonLabel,
          });
          t.class = 'ck-color-table__remove-color';
          t.on('execute', () => {
            this.fire('execute', { value: null });
          });
          t.render();
          this.focusTracker.add(t.element);
          this._focusables.add(t);
          return t;
        }
        _createStaticColorsGrid() {
          const t = new bv(this.locale, {
            colorDefinitions: this.colorDefinitions,
            columns: this.columns,
          });
          t.delegate('execute').to(this);
          return t;
        }
        _createDocumentColorsGrid() {
          const t = Yb.bind(this.documentColors, this.documentColors);
          const e = new bv(this.locale, { columns: this.columns });
          e.delegate('execute').to(this);
          e.extendTemplate({
            attributes: { class: t.if('isEmpty', 'ck-hidden') },
          });
          e.items.bindTo(this.documentColors).using((t) => {
            const e = new fv();
            e.set({
              color: t.color,
              hasBorder: t.options && t.options.hasBorder,
            });
            if (t.label) {
              e.set({ label: t.label, tooltip: true });
            }
            e.on('execute', () => {
              this.fire('execute', { value: t.color });
            });
            return e;
          });
          this.documentColors.on('change:isEmpty', (t, n, i) => {
            if (i) {
              e.selectedColor = null;
            }
          });
          return e;
        }
        _addColorToDocumentColors(t) {
          const e = this.colorDefinitions.find((e) => e.color === t);
          if (!e) {
            this.documentColors.add({
              color: t,
              label: t,
              options: { hasBorder: false },
            });
          } else {
            this.documentColors.add(Object.assign({}, e));
          }
        }
      }
      const cB = 'fontSize';
      const lB = 'fontFamily';
      const dB = 'fontColor';
      const hB = 'fontBackgroundColor';
      function uB(t, e) {
        const n = {
          model: { key: t, values: [] },
          view: {},
          upcastAlso: {},
        };
        for (const t of e) {
          n.model.values.push(t.model);
          n.view[t.model] = t.view;
          if (t.upcastAlso) {
            n.upcastAlso[t.model] = t.upcastAlso;
          }
        }
        return n;
      }
      function fB(t) {
        return (e) => pB(e.getStyle(t));
      }
      function gB(t) {
        return (e, { writer: n }) =>
          n.createAttributeElement(
            'span',
            { style: `${t}:${e}` },
            { priority: 7 }
          );
      }
      function mB({
        dropdownView: t,
        colors: e,
        columns: n,
        removeButtonLabel: i,
        documentColorsLabel: o,
        documentColorsCount: r,
      }) {
        const s = t.locale;
        const a = new aB(s, {
          colors: e,
          columns: n,
          removeButtonLabel: i,
          documentColorsLabel: o,
          documentColorsCount: r,
        });
        t.colorTableView = a;
        t.panelView.children.add(a);
        a.delegate('execute').to(t, 'execute');
        return a;
      }
      function pB(t) {
        return t.replace(/\s/g, '');
      }
      class kB extends eB {
        constructor(t) {
          super(t, hB);
        }
      }
      class bB extends nt {
        static get pluginName() {
          return 'FontBackgroundColorEditing';
        }
        constructor(t) {
          super(t);
          t.config.define(hB, {
            colors: [
              { color: 'hsl(0, 0%, 0%)', label: 'Black' },
              { color: 'hsl(0, 0%, 30%)', label: 'Dim grey' },
              { color: 'hsl(0, 0%, 60%)', label: 'Grey' },
              { color: 'hsl(0, 0%, 90%)', label: 'Light grey' },
              {
                color: 'hsl(0, 0%, 100%)',
                label: 'White',
                hasBorder: true,
              },
              { color: 'hsl(0, 75%, 60%)', label: 'Red' },
              { color: 'hsl(30, 75%, 60%)', label: 'Orange' },
              { color: 'hsl(60, 75%, 60%)', label: 'Yellow' },
              { color: 'hsl(90, 75%, 60%)', label: 'Light green' },
              { color: 'hsl(120, 75%, 60%)', label: 'Green' },
              { color: 'hsl(150, 75%, 60%)', label: 'Aquamarine' },
              { color: 'hsl(180, 75%, 60%)', label: 'Turquoise' },
              { color: 'hsl(210, 75%, 60%)', label: 'Light blue' },
              { color: 'hsl(240, 75%, 60%)', label: 'Blue' },
              { color: 'hsl(270, 75%, 60%)', label: 'Purple' },
            ],
            columns: 5,
          });
          t.data.addStyleProcessorRules(By);
          t.conversion
            .for('upcast')
            .elementToAttribute({
              view: {
                name: 'span',
                styles: { 'background-color': /[\s\S]+/ },
              },
              model: { key: hB, value: fB('background-color') },
            });
          t.conversion
            .for('downcast')
            .attributeToElement({
              model: hB,
              view: gB('background-color'),
            });
          t.commands.add(hB, new kB(t));
          t.model.schema.extend('$text', { allowAttributes: hB });
          t.model.schema.setAttributeProperties(hB, {
            isFormatting: true,
            copyOnEnter: true,
          });
        }
      }
      class wB extends nt {
        constructor(
          t,
          {
            commandName: e,
            icon: n,
            componentName: i,
            dropdownLabel: o,
          }
        ) {
          super(t);
          this.commandName = e;
          this.componentName = i;
          this.icon = n;
          this.dropdownLabel = o;
          this.columns = t.config.get(
            `${this.componentName}.columns`
          );
          this.colorTableView = undefined;
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = e.t;
          const i = t.commands.get(this.commandName);
          const o = dv(t.config.get(this.componentName).colors);
          const r = lv(e, o);
          const s = t.config.get(
            `${this.componentName}.documentColors`
          );
          t.ui.componentFactory.add(this.componentName, (e) => {
            const o = aA(e);
            this.colorTableView = mB({
              dropdownView: o,
              colors: r.map((t) => ({
                label: t.label,
                color: t.model,
                options: { hasBorder: t.hasBorder },
              })),
              columns: this.columns,
              removeButtonLabel: n('Remove color'),
              documentColorsLabel:
                s !== 0 ? n('Document colors') : undefined,
              documentColorsCount: s === undefined ? this.columns : s,
            });
            this.colorTableView.bind('selectedColor').to(i, 'value');
            o.buttonView.set({
              label: this.dropdownLabel,
              icon: this.icon,
              tooltip: true,
            });
            o.extendTemplate({
              attributes: { class: 'ck-color-ui-dropdown' },
            });
            o.bind('isEnabled').to(i);
            o.on('execute', (e, n) => {
              t.execute(this.commandName, n);
              t.editing.view.focus();
            });
            o.on('change:isOpen', (e, n, i) => {
              o.colorTableView.appendGrids();
              if (i) {
                if (s !== 0) {
                  this.colorTableView.updateDocumentColors(
                    t.model,
                    this.componentName
                  );
                }
                this.colorTableView.updateSelectedColors();
              }
            });
            dA(o, () =>
              o.colorTableView.staticColorsGrid.items.find(
                (t) => t.isOn
              )
            );
            return o;
          });
        }
      }
      const _B =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';
      class vB extends wB {
        constructor(t) {
          const e = t.locale.t;
          super(t, {
            commandName: hB,
            componentName: hB,
            icon: _B,
            dropdownLabel: e('Font Background Color'),
          });
        }
        static get pluginName() {
          return 'FontBackgroundColorUI';
        }
      }
      class AB extends nt {
        static get requires() {
          return [bB, vB];
        }
        static get pluginName() {
          return 'FontBackgroundColor';
        }
      }
      class CB extends eB {
        constructor(t) {
          super(t, dB);
        }
      }
      class yB extends nt {
        static get pluginName() {
          return 'FontColorEditing';
        }
        constructor(t) {
          super(t);
          t.config.define(dB, {
            colors: [
              { color: 'hsl(0, 0%, 0%)', label: 'Black' },
              { color: 'hsl(0, 0%, 30%)', label: 'Dim grey' },
              { color: 'hsl(0, 0%, 60%)', label: 'Grey' },
              { color: 'hsl(0, 0%, 90%)', label: 'Light grey' },
              {
                color: 'hsl(0, 0%, 100%)',
                label: 'White',
                hasBorder: true,
              },
              { color: 'hsl(0, 75%, 60%)', label: 'Red' },
              { color: 'hsl(30, 75%, 60%)', label: 'Orange' },
              { color: 'hsl(60, 75%, 60%)', label: 'Yellow' },
              { color: 'hsl(90, 75%, 60%)', label: 'Light green' },
              { color: 'hsl(120, 75%, 60%)', label: 'Green' },
              { color: 'hsl(150, 75%, 60%)', label: 'Aquamarine' },
              { color: 'hsl(180, 75%, 60%)', label: 'Turquoise' },
              { color: 'hsl(210, 75%, 60%)', label: 'Light blue' },
              { color: 'hsl(240, 75%, 60%)', label: 'Blue' },
              { color: 'hsl(270, 75%, 60%)', label: 'Purple' },
            ],
            columns: 5,
          });
          t.conversion
            .for('upcast')
            .elementToAttribute({
              view: { name: 'span', styles: { color: /[\s\S]+/ } },
              model: { key: dB, value: fB('color') },
            });
          t.conversion
            .for('upcast')
            .elementToAttribute({
              view: {
                name: 'font',
                attributes: { color: /^#?\w+$/ },
              },
              model: {
                key: dB,
                value: (t) => t.getAttribute('color'),
              },
            });
          t.conversion
            .for('downcast')
            .attributeToElement({ model: dB, view: gB('color') });
          t.commands.add(dB, new CB(t));
          t.model.schema.extend('$text', { allowAttributes: dB });
          t.model.schema.setAttributeProperties(dB, {
            isFormatting: true,
            copyOnEnter: true,
          });
        }
      }
      const xB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
      class EB extends wB {
        constructor(t) {
          const e = t.locale.t;
          super(t, {
            commandName: dB,
            componentName: dB,
            icon: xB,
            dropdownLabel: e('Font Color'),
          });
        }
        static get pluginName() {
          return 'FontColorUI';
        }
      }
      class DB extends nt {
        static get requires() {
          return [yB, EB];
        }
        static get pluginName() {
          return 'FontColor';
        }
      }
      class SB extends eB {
        constructor(t) {
          super(t, cB);
        }
      }
      function TB(t) {
        return t.map((t) => PB(t)).filter((t) => !!t);
      }
      const BB = {
        get tiny() {
          return {
            title: 'Tiny',
            model: 'tiny',
            view: { name: 'span', classes: 'text-tiny', priority: 7 },
          };
        },
        get small() {
          return {
            title: 'Small',
            model: 'small',
            view: {
              name: 'span',
              classes: 'text-small',
              priority: 7,
            },
          };
        },
        get big() {
          return {
            title: 'Big',
            model: 'big',
            view: { name: 'span', classes: 'text-big', priority: 7 },
          };
        },
        get huge() {
          return {
            title: 'Huge',
            model: 'huge',
            view: { name: 'span', classes: 'text-huge', priority: 7 },
          };
        },
      };
      function PB(t) {
        if (OB(t)) {
          return RB(t);
        }
        const e = zB(t);
        if (e) {
          return RB(e);
        }
        if (t === 'default') {
          return { model: undefined, title: 'Default' };
        }
        if (FB(t)) {
          return;
        }
        return IB(t);
      }
      function IB(t) {
        if (typeof t === 'number' || typeof t === 'string') {
          t = { title: String(t), model: `${parseFloat(t)}px` };
        }
        t.view = { name: 'span', styles: { 'font-size': t.model } };
        return RB(t);
      }
      function RB(t) {
        if (!t.view.priority) {
          t.view.priority = 7;
        }
        return t;
      }
      function zB(t) {
        return BB[t] || BB[t.model];
      }
      function OB(t) {
        return typeof t === 'object' && t.title && t.model && t.view;
      }
      function FB(t) {
        let e;
        if (typeof t === 'object') {
          if (!t.model) {
            throw new h('font-size-invalid-definition', null, t);
          } else {
            e = parseFloat(t.model);
          }
        } else {
          e = parseFloat(t);
        }
        return isNaN(e);
      }
      const NB = [
        'x-small',
        'x-small',
        'small',
        'medium',
        'large',
        'x-large',
        'xx-large',
        'xxx-large',
      ];
      class MB extends nt {
        static get pluginName() {
          return 'FontSizeEditing';
        }
        constructor(t) {
          super(t);
          t.config.define(cB, {
            options: ['tiny', 'small', 'default', 'big', 'huge'],
            supportAllValues: false,
          });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', { allowAttributes: cB });
          t.model.schema.setAttributeProperties(cB, {
            isFormatting: true,
            copyOnEnter: true,
          });
          const e = t.config.get('fontSize.supportAllValues');
          const n = TB(
            this.editor.config.get('fontSize.options')
          ).filter((t) => t.model);
          const i = uB(cB, n);
          if (e) {
            this._prepareAnyValueConverters(i);
            this._prepareCompatibilityConverter();
          } else {
            t.conversion.attributeToElement(i);
          }
          t.commands.add(cB, new SB(t));
        }
        _prepareAnyValueConverters(t) {
          const e = this.editor;
          const n = t.model.values.filter(
            (t) => !gy(String(t)) && !py(String(t))
          );
          if (n.length) {
            throw new h(
              'font-size-invalid-use-of-named-presets',
              null,
              { presets: n }
            );
          }
          e.conversion.for('downcast').attributeToElement({
            model: cB,
            view: (t, { writer: e }) => {
              if (!t) {
                return;
              }
              return e.createAttributeElement(
                'span',
                { style: 'font-size:' + t },
                { priority: 7 }
              );
            },
          });
          e.conversion
            .for('upcast')
            .elementToAttribute({
              model: {
                key: cB,
                value: (t) => t.getStyle('font-size'),
              },
              view: { name: 'span', styles: { 'font-size': /.*/ } },
            });
        }
        _prepareCompatibilityConverter() {
          const t = this.editor;
          t.conversion.for('upcast').elementToAttribute({
            view: {
              name: 'font',
              attributes: { size: /^[+-]?\d{1,3}$/ },
            },
            model: {
              key: cB,
              value: (t) => {
                const e = t.getAttribute('size');
                const n = e[0] === '-' || e[0] === '+';
                let i = parseInt(e, 10);
                if (n) {
                  i = 3 + i;
                }
                const o = NB.length - 1;
                const r = Math.min(Math.max(i, 0), o);
                return NB[r];
              },
            },
          });
        }
      }
      const LB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
      var VB = n(6203);
      var HB = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      HB.insert = 'head';
      HB.singleton = true;
      var jB = Lh()(VB.Z, HB);
      const qB = VB.Z.locals || {};
      class WB extends nt {
        static get pluginName() {
          return 'FontSizeUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = this._getLocalizedOptions();
          const i = t.commands.get(cB);
          t.ui.componentFactory.add(cB, (o) => {
            const r = aA(o);
            lA(r, UB(n, i));
            r.buttonView.set({
              label: e('Font Size'),
              icon: LB,
              tooltip: true,
            });
            r.extendTemplate({
              attributes: { class: ['ck-font-size-dropdown'] },
            });
            r.bind('isEnabled').to(i);
            this.listenTo(r, 'execute', (e) => {
              t.execute(e.source.commandName, {
                value: e.source.commandParam,
              });
              t.editing.view.focus();
            });
            return r;
          });
        }
        _getLocalizedOptions() {
          const t = this.editor;
          const e = t.t;
          const n = {
            Default: e('Default'),
            Tiny: e('Tiny'),
            Small: e('Small'),
            Big: e('Big'),
            Huge: e('Huge'),
          };
          const i = TB(t.config.get(cB).options);
          return i.map((t) => {
            const e = n[t.title];
            if (e && e != t.title) {
              t = Object.assign({}, t, { title: e });
            }
            return t;
          });
        }
      }
      function UB(t, e) {
        const n = new ya();
        for (const i of t) {
          const t = {
            type: 'button',
            model: new YA({
              commandName: cB,
              commandParam: i.model,
              label: i.title,
              class: 'ck-fontsize-option',
              withText: true,
            }),
          };
          if (i.view && i.view.styles) {
            t.model.set(
              'labelStyle',
              `font-size:${i.view.styles['font-size']}`
            );
          }
          if (i.view && i.view.classes) {
            t.model.set(
              'class',
              `${t.model.class} ${i.view.classes}`
            );
          }
          t.model.bind('isOn').to(e, 'value', (t) => t === i.model);
          n.add(t);
        }
        return n;
      }
      class GB extends nt {
        static get requires() {
          return [MB, WB];
        }
        static get pluginName() {
          return 'FontSize';
        }
        normalizeSizeOptions(t) {
          return TB(t);
        }
      }
      class $B extends ot {
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = e.selection.getAttribute('highlight');
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            'highlight'
          );
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = n.selection;
          const o = t.value;
          e.change((t) => {
            if (i.isCollapsed) {
              const e = i.getFirstPosition();
              if (i.hasAttribute('highlight')) {
                const n = (t) =>
                  t.item.hasAttribute('highlight') &&
                  t.item.getAttribute('highlight') === this.value;
                const i = e.getLastMatchingPosition(n, {
                  direction: 'backward',
                });
                const r = e.getLastMatchingPosition(n);
                const s = t.createRange(i, r);
                if (!o || this.value === o) {
                  if (!e.isEqual(r)) {
                    t.removeAttribute('highlight', s);
                  }
                  t.removeSelectionAttribute('highlight');
                } else {
                  if (!e.isEqual(r)) {
                    t.setAttribute('highlight', o, s);
                  }
                  t.setSelectionAttribute('highlight', o);
                }
              } else if (o) {
                t.setSelectionAttribute('highlight', o);
              }
            } else {
              const n = e.schema.getValidRanges(
                i.getRanges(),
                'highlight'
              );
              for (const e of n) {
                if (o) {
                  t.setAttribute('highlight', o, e);
                } else {
                  t.removeAttribute('highlight', e);
                }
              }
            }
          });
        }
      }
      class KB extends nt {
        static get pluginName() {
          return 'HighlightEditing';
        }
        constructor(t) {
          super(t);
          t.config.define('highlight', {
            options: [
              {
                model: 'yellowMarker',
                class: 'marker-yellow',
                title: 'Yellow marker',
                color: 'var(--ck-highlight-marker-yellow)',
                type: 'marker',
              },
              {
                model: 'greenMarker',
                class: 'marker-green',
                title: 'Green marker',
                color: 'var(--ck-highlight-marker-green)',
                type: 'marker',
              },
              {
                model: 'pinkMarker',
                class: 'marker-pink',
                title: 'Pink marker',
                color: 'var(--ck-highlight-marker-pink)',
                type: 'marker',
              },
              {
                model: 'blueMarker',
                class: 'marker-blue',
                title: 'Blue marker',
                color: 'var(--ck-highlight-marker-blue)',
                type: 'marker',
              },
              {
                model: 'redPen',
                class: 'pen-red',
                title: 'Red pen',
                color: 'var(--ck-highlight-pen-red)',
                type: 'pen',
              },
              {
                model: 'greenPen',
                class: 'pen-green',
                title: 'Green pen',
                color: 'var(--ck-highlight-pen-green)',
                type: 'pen',
              },
            ],
          });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', {
            allowAttributes: 'highlight',
          });
          const e = t.config.get('highlight.options');
          t.conversion.attributeToElement(ZB(e));
          t.commands.add('highlight', new $B(t));
        }
      }
      function ZB(t) {
        const e = {
          model: { key: 'highlight', values: [] },
          view: {},
        };
        for (const n of t) {
          e.model.values.push(n.model);
          e.view[n.model] = { name: 'mark', classes: n.class };
        }
        return e;
      }
      const JB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
      const YB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
      var QB = n(713);
      var XB = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      XB.insert = 'head';
      XB.singleton = true;
      var tP = Lh()(QB.Z, XB);
      const eP = QB.Z.locals || {};
      class nP extends nt {
        get localizedOptionTitles() {
          const t = this.editor.t;
          return {
            'Yellow marker': t('Yellow marker'),
            'Green marker': t('Green marker'),
            'Pink marker': t('Pink marker'),
            'Blue marker': t('Blue marker'),
            'Red pen': t('Red pen'),
            'Green pen': t('Green pen'),
          };
        }
        static get pluginName() {
          return 'HighlightUI';
        }
        init() {
          const t = this.editor.config.get('highlight.options');
          for (const e of t) {
            this._addHighlighterButton(e);
          }
          this._addRemoveHighlightButton();
          this._addDropdown(t);
        }
        _addRemoveHighlightButton() {
          const t = this.editor.t;
          const e = this.editor.commands.get('highlight');
          this._addButton(
            'removeHighlight',
            t('Remove highlight'),
            M_.eraser,
            null,
            (t) => {
              t.bind('isEnabled').to(e, 'isEnabled');
            }
          );
        }
        _addHighlighterButton(t) {
          const e = this.editor.commands.get('highlight');
          this._addButton(
            'highlight:' + t.model,
            t.title,
            oP(t.type),
            t.model,
            n
          );
          function n(n) {
            n.bind('isEnabled').to(e, 'isEnabled');
            n.bind('isOn').to(e, 'value', (e) => e === t.model);
            n.iconView.fillColor = t.color;
            n.isToggleable = true;
          }
        }
        _addButton(t, e, n, i, o) {
          const r = this.editor;
          r.ui.componentFactory.add(t, (t) => {
            const s = new iv(t);
            const a = this.localizedOptionTitles[e]
              ? this.localizedOptionTitles[e]
              : e;
            s.set({ label: a, icon: n, tooltip: true });
            s.on('execute', () => {
              r.execute('highlight', { value: i });
              r.editing.view.focus();
            });
            o(s);
            return s;
          });
        }
        _addDropdown(t) {
          const e = this.editor;
          const n = e.t;
          const i = e.ui.componentFactory;
          const o = t[0];
          const r = t.reduce((t, e) => {
            t[e.model] = e;
            return t;
          }, {});
          i.add('highlight', (s) => {
            const a = e.commands.get('highlight');
            const c = aA(s, xv);
            const l = c.buttonView;
            l.set({
              label: n('Highlight'),
              tooltip: true,
              lastExecuted: o.model,
              commandValue: o.model,
              isToggleable: true,
            });
            l.bind('icon').to(a, 'value', (t) => oP(h(t, 'type')));
            l.bind('color').to(a, 'value', (t) => h(t, 'color'));
            l.bind('commandValue').to(a, 'value', (t) =>
              h(t, 'model')
            );
            l.bind('isOn').to(a, 'value', (t) => !!t);
            l.delegate('execute').to(c);
            const d = t.map((t) => {
              const e = i.create('highlight:' + t.model);
              this.listenTo(e, 'execute', () => {
                c.buttonView.set({ lastExecuted: t.model });
              });
              return e;
            });
            c.bind('isEnabled').toMany(d, 'isEnabled', (...t) =>
              t.some((t) => t)
            );
            d.push(new zv());
            d.push(i.create('removeHighlight'));
            cA(c, d, { enableActiveItemFocusOnDropdownOpen: true });
            iP(c);
            c.toolbarView.ariaLabel = n('Text highlight toolbar');
            l.on('execute', () => {
              e.execute('highlight', { value: l.commandValue });
            });
            this.listenTo(c, 'execute', () => {
              e.editing.view.focus();
            });
            function h(t, e) {
              const n =
                !t || t === l.lastExecuted ? l.lastExecuted : t;
              return r[n][e];
            }
            return c;
          });
        }
      }
      function iP(t) {
        const e = t.buttonView.actionView;
        e.iconView.bind('fillColor').to(t.buttonView, 'color');
      }
      function oP(t) {
        return t === 'marker' ? JB : YB;
      }
      class rP extends nt {
        static get requires() {
          return [KB, nP];
        }
        static get pluginName() {
          return 'Highlight';
        }
      }
      class sP extends ot {
        refresh() {
          const t = this.editor;
          const e = t.plugins.get('ImageUtils');
          const n = e.getClosestSelectedImageElement(
            this.editor.model.document.selection
          );
          this.isEnabled = !!n;
          if (this.isEnabled && n.hasAttribute('alt')) {
            this.value = n.getAttribute('alt');
          } else {
            this.value = false;
          }
        }
        execute(t) {
          const e = this.editor;
          const n = e.plugins.get('ImageUtils');
          const i = e.model;
          const o = n.getClosestSelectedImageElement(
            i.document.selection
          );
          i.change((e) => {
            e.setAttribute('alt', t.newValue, o);
          });
        }
      }
      class aP extends nt {
        static get requires() {
          return [kS];
        }
        static get pluginName() {
          return 'ImageTextAlternativeEditing';
        }
        init() {
          this.editor.commands.add(
            'imageTextAlternative',
            new sP(this.editor)
          );
        }
      }
      var cP = n(6831);
      var lP = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      lP.insert = 'head';
      lP.singleton = true;
      var dP = Lh()(cP.Z, lP);
      const hP = cP.Z.locals || {};
      var uP = n(1590);
      var fP = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      fP.insert = 'head';
      fP.singleton = true;
      var gP = Lh()(uP.Z, fP);
      const mP = uP.Z.locals || {};
      class pP extends Dw {
        constructor(t) {
          super(t);
          const e = this.locale.t;
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this.labeledInput = this._createLabeledInputView();
          this.saveButtonView = this._createButton(
            e('Save'),
            M_.check,
            'ck-button-save'
          );
          this.saveButtonView.type = 'submit';
          this.cancelButtonView = this._createButton(
            e('Cancel'),
            M_.cancel,
            'ck-button-cancel',
            'cancel'
          );
          this._focusables = new Kb();
          this._focusCycler = new Iv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: 'shift + tab',
              focusNext: 'tab',
            },
          });
          this.setTemplate({
            tag: 'form',
            attributes: {
              class: [
                'ck',
                'ck-text-alternative-form',
                'ck-responsive-form',
              ],
              tabindex: '-1',
            },
            children: [
              this.labeledInput,
              this.saveButtonView,
              this.cancelButtonView,
            ],
          });
          V_(this);
        }
        render() {
          super.render();
          this.keystrokes.listenTo(this.element);
          H_({ view: this });
          [
            this.labeledInput,
            this.saveButtonView,
            this.cancelButtonView,
          ].forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        _createButton(t, e, n, i) {
          const o = new iv(this.locale);
          o.set({ label: t, icon: e, tooltip: true });
          o.extendTemplate({ attributes: { class: n } });
          if (i) {
            o.delegate('execute').to(this, i);
          }
          return o;
        }
        _createLabeledInputView() {
          const t = this.locale.t;
          const e = new GA(this.locale, $A);
          e.label = t('Text alternative');
          return e;
        }
      }
      function kP(t) {
        const e = t.plugins.get('ContextualBalloon');
        if (
          t.plugins
            .get('ImageUtils')
            .getClosestSelectedImageWidget(
              t.editing.view.document.selection
            )
        ) {
          const n = bP(t);
          e.updatePosition(n);
        }
      }
      function bP(t) {
        const e = t.editing.view;
        const n = jw.defaultPositions;
        const i = t.plugins.get('ImageUtils');
        return {
          target: e.domConverter.mapViewToDom(
            i.getClosestSelectedImageWidget(e.document.selection)
          ),
          positions: [
            n.northArrowSouth,
            n.northArrowSouthWest,
            n.northArrowSouthEast,
            n.southArrowNorth,
            n.southArrowNorthWest,
            n.southArrowNorthEast,
            n.viewportStickyNorth,
          ],
        };
      }
      class wP extends nt {
        static get requires() {
          return [lC];
        }
        static get pluginName() {
          return 'ImageTextAlternativeUI';
        }
        init() {
          this._createButton();
          this._createForm();
        }
        destroy() {
          super.destroy();
          this._form.destroy();
        }
        _createButton() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add('imageTextAlternative', (n) => {
            const i = t.commands.get('imageTextAlternative');
            const o = new iv(n);
            o.set({
              label: e('Change image text alternative'),
              icon: M_.lowVision,
              tooltip: true,
            });
            o.bind('isEnabled').to(i, 'isEnabled');
            this.listenTo(o, 'execute', () => {
              this._showForm();
            });
            return o;
          });
        }
        _createForm() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const i = t.plugins.get('ImageUtils');
          this._balloon = this.editor.plugins.get(
            'ContextualBalloon'
          );
          this._form = new pP(t.locale);
          this._form.render();
          this.listenTo(this._form, 'submit', () => {
            t.execute('imageTextAlternative', {
              newValue:
                this._form.labeledInput.fieldView.element.value,
            });
            this._hideForm(true);
          });
          this.listenTo(this._form, 'cancel', () => {
            this._hideForm(true);
          });
          this._form.keystrokes.set('Esc', (t, e) => {
            this._hideForm(true);
            e();
          });
          this.listenTo(t.ui, 'update', () => {
            if (!i.getClosestSelectedImageWidget(n.selection)) {
              this._hideForm(true);
            } else if (this._isVisible) {
              kP(t);
            }
          });
          L_({
            emitter: this._form,
            activator: () => this._isVisible,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideForm(),
          });
        }
        _showForm() {
          if (this._isVisible) {
            return;
          }
          const t = this.editor;
          const e = t.commands.get('imageTextAlternative');
          const n = this._form.labeledInput;
          this._form.disableCssTransitions();
          if (!this._isInBalloon) {
            this._balloon.add({ view: this._form, position: bP(t) });
          }
          n.fieldView.value = n.fieldView.element.value =
            e.value || '';
          this._form.labeledInput.fieldView.select();
          this._form.enableCssTransitions();
        }
        _hideForm(t) {
          if (!this._isInBalloon) {
            return;
          }
          if (this._form.focusTracker.isFocused) {
            this._form.saveButtonView.focus();
          }
          this._balloon.remove(this._form);
          if (t) {
            this.editor.editing.view.focus();
          }
        }
        get _isVisible() {
          return this._balloon.visibleView === this._form;
        }
        get _isInBalloon() {
          return this._balloon.hasView(this._form);
        }
      }
      class _P extends nt {
        static get requires() {
          return [aP, wP];
        }
        static get pluginName() {
          return 'ImageTextAlternative';
        }
      }
      function vP(t) {
        return (t) => {
          t.on('element:figure', e);
        };
        function e(e, n, i) {
          if (
            !i.consumable.test(n.viewItem, {
              name: true,
              classes: 'image',
            })
          ) {
            return;
          }
          const o = t.findViewImgElement(n.viewItem);
          if (!o || !i.consumable.test(o, { name: true })) {
            return;
          }
          i.consumable.consume(n.viewItem, {
            name: true,
            classes: 'image',
          });
          const r = i.convertItem(o, n.modelCursor);
          const s = Xf(r.modelRange.getItems());
          if (!s) {
            i.consumable.revert(n.viewItem, {
              name: true,
              classes: 'image',
            });
            return;
          }
          i.convertChildren(n.viewItem, s);
          i.updateConversionResult(s, n);
        }
      }
      function AP(t) {
        const e = ['srcset', 'media', 'type', 'sizes'];
        return (t) => {
          t.on('element:picture', n);
        };
        function n(n, i, o) {
          const r = i.viewItem;
          if (!o.consumable.test(r, { name: true })) {
            return;
          }
          const s = new Map();
          for (const t of r.getChildren()) {
            if (t.is('element', 'source')) {
              const n = {};
              for (const i of e) {
                if (t.hasAttribute(i)) {
                  if (o.consumable.test(t, { attributes: i })) {
                    n[i] = t.getAttribute(i);
                  }
                }
              }
              if (Object.keys(n).length) {
                s.set(t, n);
              }
            }
          }
          const a = t.findViewImgElement(r);
          if (!a) {
            return;
          }
          let c = i.modelCursor.parent;
          if (!c.is('element', 'imageBlock')) {
            const t = o.convertItem(a, i.modelCursor);
            i.modelRange = t.modelRange;
            i.modelCursor = t.modelCursor;
            c = first(t.modelRange.getItems());
          }
          o.consumable.consume(r, { name: true });
          for (const [t, e] of s) {
            o.consumable.consume(t, { attributes: Object.keys(e) });
          }
          if (s.size) {
            o.writer.setAttribute(
              'sources',
              Array.from(s.values()),
              c
            );
          }
          o.convertChildren(r, c);
        }
      }
      function CP(t, e) {
        return (t) => {
          t.on(`attribute:srcset:${e}`, n);
        };
        function n(e, n, i) {
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const o = i.writer;
          const r = i.mapper.toViewElement(n.item);
          const s = t.findViewImgElement(r);
          if (n.attributeNewValue === null) {
            const t = n.attributeOldValue;
            if (t.data) {
              o.removeAttribute('srcset', s);
              o.removeAttribute('sizes', s);
              if (t.width) {
                o.removeAttribute('width', s);
              }
            }
          } else {
            const t = n.attributeNewValue;
            if (t.data) {
              o.setAttribute('srcset', t.data, s);
              o.setAttribute('sizes', '100vw', s);
              if (t.width) {
                o.setAttribute('width', t.width, s);
              }
            }
          }
        }
      }
      function yP(t) {
        return (t) => {
          t.on('attribute:sources:imageBlock', e);
          t.on('attribute:sources:imageInline', e);
        };
        function e(e, n, i) {
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const o = i.writer;
          const r = i.mapper.toViewElement(n.item);
          const s = t.findViewImgElement(r);
          if (n.attributeNewValue && n.attributeNewValue.length) {
            const t = o.createContainerElement(
              'picture',
              null,
              n.attributeNewValue.map((t) =>
                o.createEmptyElement('source', t)
              )
            );
            const e = [];
            let i = s.parent;
            while (i && i.is('attributeElement')) {
              const t = i.parent;
              o.unwrap(o.createRangeOn(s), i);
              e.unshift(i);
              i = t;
            }
            o.insert(o.createPositionBefore(s), t);
            o.move(o.createRangeOn(s), o.createPositionAt(t, 'end'));
            for (const n of e) {
              o.wrap(o.createRangeOn(t), n);
            }
          } else if (s.parent.is('element', 'picture')) {
            const t = s.parent;
            o.move(o.createRangeOn(s), o.createPositionBefore(t));
            o.remove(t);
          }
        }
      }
      function xP(t, e, n) {
        return (t) => {
          t.on(`attribute:${n}:${e}`, i);
        };
        function i(e, n, i) {
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const o = i.writer;
          const r = i.mapper.toViewElement(n.item);
          const s = t.findViewImgElement(r);
          o.setAttribute(
            n.attributeKey,
            n.attributeNewValue || '',
            s
          );
        }
      }
      class EP extends ku {
        observe(t) {
          this.listenTo(
            t,
            'load',
            (t, e) => {
              const n = e.target;
              if (this.checkShouldIgnoreEventFromTarget(n)) {
                return;
              }
              if (n.tagName == 'IMG') {
                this._fireEvents(e);
              }
            },
            { useCapture: true }
          );
        }
        _fireEvents(t) {
          if (this.isEnabled) {
            this.document.fire('layoutChanged');
            this.document.fire('imageLoaded', t);
          }
        }
      }
      class DP extends ot {
        constructor(t) {
          super(t);
          const e = t.config.get('image.insert.type');
          if (!t.plugins.has('ImageBlockEditing')) {
            if (e === 'block') {
              u('image-block-plugin-required');
            }
          }
          if (!t.plugins.has('ImageInlineEditing')) {
            if (e === 'inline') {
              u('image-inline-plugin-required');
            }
          }
        }
        refresh() {
          this.isEnabled = this.editor.plugins
            .get('ImageUtils')
            .isImageAllowed();
        }
        execute(t) {
          const e = Ea(t.source);
          const n = this.editor.model.document.selection;
          const i = this.editor.plugins.get('ImageUtils');
          const o = Object.fromEntries(n.getAttributes());
          e.forEach((t, e) => {
            const r = n.getSelectedElement();
            if (typeof t === 'string') {
              t = { src: t };
            }
            if (e && r && i.isImage(r)) {
              const e = this.editor.model.createPositionAfter(r);
              i.insertImage({ ...t, ...o }, e);
            } else {
              i.insertImage({ ...t, ...o });
            }
          });
        }
      }
      class SP extends nt {
        static get requires() {
          return [kS];
        }
        static get pluginName() {
          return 'ImageEditing';
        }
        init() {
          const t = this.editor;
          const e = t.conversion;
          t.editing.view.addObserver(EP);
          e.for('upcast')
            .attributeToAttribute({
              view: { name: 'img', key: 'alt' },
              model: 'alt',
            })
            .attributeToAttribute({
              view: { name: 'img', key: 'srcset' },
              model: {
                key: 'srcset',
                value: (t) => {
                  const e = { data: t.getAttribute('srcset') };
                  if (t.hasAttribute('width')) {
                    e.width = t.getAttribute('width');
                  }
                  return e;
                },
              },
            });
          const n = new DP(t);
          t.commands.add('insertImage', n);
          t.commands.add('imageInsert', n);
        }
      }
      class TP extends ot {
        constructor(t, e) {
          super(t);
          this._modelElementName = e;
        }
        refresh() {
          const t = this.editor;
          const e = t.plugins.get('ImageUtils');
          const n = e.getClosestSelectedImageElement(
            this.editor.model.document.selection
          );
          if (this._modelElementName === 'imageBlock') {
            this.isEnabled = e.isInlineImage(n);
          } else {
            this.isEnabled = e.isBlockImage(n);
          }
        }
        execute() {
          const t = this.editor;
          const e = this.editor.model;
          const n = t.plugins.get('ImageUtils');
          const i = n.getClosestSelectedImageElement(
            e.document.selection
          );
          const o = Object.fromEntries(i.getAttributes());
          if (!o.src && !o.uploadId) {
            return null;
          }
          return e.change((t) => {
            const r = Array.from(e.markers).filter((t) =>
              t.getRange().containsItem(i)
            );
            const s = n.insertImage(
              o,
              e.createSelection(i, 'on'),
              this._modelElementName
            );
            if (!s) {
              return null;
            }
            const a = t.createRangeOn(s);
            for (const e of r) {
              const n = e.getRange();
              const i =
                n.root.rootName != '$graveyard'
                  ? n.getJoined(a, true)
                  : a;
              t.updateMarker(e, { range: i });
            }
            return { oldElement: i, newElement: s };
          });
        }
      }
      class BP extends nt {
        static get requires() {
          return [SP, kS, Ex];
        }
        static get pluginName() {
          return 'ImageBlockEditing';
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          e.register('imageBlock', {
            inheritAllFrom: '$blockObject',
            allowAttributes: ['alt', 'src', 'srcset'],
          });
          this._setupConversion();
          if (t.plugins.has('ImageInlineEditing')) {
            t.commands.add(
              'imageTypeBlock',
              new TP(this.editor, 'imageBlock')
            );
            this._setupClipboardIntegration();
          }
        }
        _setupConversion() {
          const t = this.editor;
          const e = t.t;
          const n = t.conversion;
          const i = t.plugins.get('ImageUtils');
          n.for('dataDowncast').elementToStructure({
            model: 'imageBlock',
            view: (t, { writer: e }) => gS(e),
          });
          n.for('editingDowncast').elementToStructure({
            model: 'imageBlock',
            view: (t, { writer: n }) =>
              i.toImageWidget(gS(n), n, e('image widget')),
          });
          n.for('downcast')
            .add(xP(i, 'imageBlock', 'src'))
            .add(xP(i, 'imageBlock', 'alt'))
            .add(CP(i, 'imageBlock'));
          n.for('upcast')
            .elementToElement({
              view: mS(t, 'imageBlock'),
              model: (t, { writer: e }) =>
                e.createElement(
                  'imageBlock',
                  t.hasAttribute('src')
                    ? { src: t.getAttribute('src') }
                    : null
                ),
            })
            .add(vP(i));
        }
        _setupClipboardIntegration() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = t.plugins.get('ImageUtils');
          this.listenTo(
            t.plugins.get('ClipboardPipeline'),
            'inputTransformation',
            (o, r) => {
              const s = Array.from(r.content.getChildren());
              let a;
              if (!s.every(i.isInlineImageView)) {
                return;
              }
              if (r.targetRanges) {
                a = t.editing.mapper.toModelRange(r.targetRanges[0]);
              } else {
                a = e.document.selection.getFirstRange();
              }
              const c = e.createSelection(a);
              if (pS(e.schema, c) === 'imageBlock') {
                const t = new iy(n.document);
                const e = s.map((e) =>
                  t.createElement('figure', { class: 'image' }, e)
                );
                r.content = t.createDocumentFragment(e);
              }
            }
          );
        }
      }
      var PP = n(9048);
      var IP = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      IP.insert = 'head';
      IP.singleton = true;
      var RP = Lh()(PP.Z, IP);
      const zP = PP.Z.locals || {};
      class OP extends nt {
        static get requires() {
          return [BP, LE, _P];
        }
        static get pluginName() {
          return 'ImageBlock';
        }
      }
      class FP extends nt {
        static get requires() {
          return [SP, kS, Ex];
        }
        static get pluginName() {
          return 'ImageInlineEditing';
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          e.register('imageInline', {
            inheritAllFrom: '$inlineObject',
            allowAttributes: ['alt', 'src', 'srcset'],
          });
          e.addChildCheck((t, e) => {
            if (t.endsWith('caption') && e.name === 'imageInline') {
              return false;
            }
          });
          this._setupConversion();
          if (t.plugins.has('ImageBlockEditing')) {
            t.commands.add(
              'imageTypeInline',
              new TP(this.editor, 'imageInline')
            );
            this._setupClipboardIntegration();
          }
        }
        _setupConversion() {
          const t = this.editor;
          const e = t.t;
          const n = t.conversion;
          const i = t.plugins.get('ImageUtils');
          n.for('dataDowncast').elementToElement({
            model: 'imageInline',
            view: (t, { writer: e }) => e.createEmptyElement('img'),
          });
          n.for('editingDowncast').elementToStructure({
            model: 'imageInline',
            view: (t, { writer: n }) =>
              i.toImageWidget(fS(n), n, e('image widget')),
          });
          n.for('downcast')
            .add(xP(i, 'imageInline', 'src'))
            .add(xP(i, 'imageInline', 'alt'))
            .add(CP(i, 'imageInline'));
          n.for('upcast').elementToElement({
            view: mS(t, 'imageInline'),
            model: (t, { writer: e }) =>
              e.createElement(
                'imageInline',
                t.hasAttribute('src')
                  ? { src: t.getAttribute('src') }
                  : null
              ),
          });
        }
        _setupClipboardIntegration() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const i = t.plugins.get('ImageUtils');
          this.listenTo(
            t.plugins.get('ClipboardPipeline'),
            'inputTransformation',
            (o, r) => {
              const s = Array.from(r.content.getChildren());
              let a;
              if (!s.every(i.isBlockImageView)) {
                return;
              }
              if (r.targetRanges) {
                a = t.editing.mapper.toModelRange(r.targetRanges[0]);
              } else {
                a = e.document.selection.getFirstRange();
              }
              const c = e.createSelection(a);
              if (pS(e.schema, c) === 'imageInline') {
                const t = new iy(n.document);
                const e = s.map((e) => {
                  if (e.childCount === 1) {
                    Array.from(e.getAttributes()).forEach((n) =>
                      t.setAttribute(...n, i.findViewImgElement(e))
                    );
                    return e.getChild(0);
                  } else {
                    return e;
                  }
                });
                r.content = t.createDocumentFragment(e);
              }
            }
          );
        }
      }
      class NP extends nt {
        static get requires() {
          return [FP, LE, _P];
        }
        static get pluginName() {
          return 'ImageInline';
        }
      }
      class MP extends nt {
        static get requires() {
          return [OP, NP];
        }
        static get pluginName() {
          return 'Image';
        }
      }
      class LP {
        constructor() {
          const t = new window.FileReader();
          this._reader = t;
          this._data = undefined;
          this.set('loaded', 0);
          t.onprogress = (t) => {
            this.loaded = t.loaded;
          };
        }
        get error() {
          return this._reader.error;
        }
        get data() {
          return this._data;
        }
        read(t) {
          const e = this._reader;
          this.total = t.size;
          return new Promise((n, i) => {
            e.onload = () => {
              const t = e.result;
              this._data = t;
              n(t);
            };
            e.onerror = () => {
              i('error');
            };
            e.onabort = () => {
              i('aborted');
            };
            this._reader.readAsDataURL(t);
          });
        }
        abort() {
          this._reader.abort();
        }
      }
      et(LP, q);
      class VP extends nt {
        static get pluginName() {
          return 'FileRepository';
        }
        static get requires() {
          return [c_];
        }
        init() {
          this.loaders = new ya();
          this.loaders.on('add', () => this._updatePendingAction());
          this.loaders.on('remove', () =>
            this._updatePendingAction()
          );
          this._loadersMap = new Map();
          this._pendingAction = null;
          this.set('uploaded', 0);
          this.set('uploadTotal', null);
          this.bind('uploadedPercent').to(
            this,
            'uploaded',
            this,
            'uploadTotal',
            (t, e) => (e ? (t / e) * 100 : 0)
          );
        }
        getLoader(t) {
          return this._loadersMap.get(t) || null;
        }
        createLoader(t) {
          if (!this.createUploadAdapter) {
            u('filerepository-no-upload-adapter');
            return null;
          }
          const e = new HP(
            Promise.resolve(t),
            this.createUploadAdapter
          );
          this.loaders.add(e);
          this._loadersMap.set(t, e);
          if (t instanceof Promise) {
            e.file
              .then((t) => {
                this._loadersMap.set(t, e);
              })
              .catch(() => {});
          }
          e.on('change:uploaded', () => {
            let t = 0;
            for (const e of this.loaders) {
              t += e.uploaded;
            }
            this.uploaded = t;
          });
          e.on('change:uploadTotal', () => {
            let t = 0;
            for (const e of this.loaders) {
              if (e.uploadTotal) {
                t += e.uploadTotal;
              }
            }
            this.uploadTotal = t;
          });
          return e;
        }
        destroyLoader(t) {
          const e = t instanceof HP ? t : this.getLoader(t);
          e._destroy();
          this.loaders.remove(e);
          this._loadersMap.forEach((t, n) => {
            if (t === e) {
              this._loadersMap.delete(n);
            }
          });
        }
        _updatePendingAction() {
          const t = this.editor.plugins.get(c_);
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const e = this.editor.t;
              const n = (t) =>
                `${e('Upload in progress')} ${parseInt(t)}%.`;
              this._pendingAction = t.add(n(this.uploadedPercent));
              this._pendingAction
                .bind('message')
                .to(this, 'uploadedPercent', n);
            }
          } else {
            t.remove(this._pendingAction);
            this._pendingAction = null;
          }
        }
      }
      et(VP, q);
      class HP {
        constructor(t, e) {
          this.id = s();
          this._filePromiseWrapper =
            this._createFilePromiseWrapper(t);
          this._adapter = e(this);
          this._reader = new LP();
          this.set('status', 'idle');
          this.set('uploaded', 0);
          this.set('uploadTotal', null);
          this.bind('uploadedPercent').to(
            this,
            'uploaded',
            this,
            'uploadTotal',
            (t, e) => (e ? (t / e) * 100 : 0)
          );
          this.set('uploadResponse', null);
        }
        get file() {
          if (!this._filePromiseWrapper) {
            return Promise.resolve(null);
          } else {
            return this._filePromiseWrapper.promise.then((t) =>
              this._filePromiseWrapper ? t : null
            );
          }
        }
        get data() {
          return this._reader.data;
        }
        read() {
          if (this.status != 'idle') {
            throw new h('filerepository-read-wrong-status', this);
          }
          this.status = 'reading';
          return this.file
            .then((t) => this._reader.read(t))
            .then((t) => {
              if (this.status !== 'reading') {
                throw this.status;
              }
              this.status = 'idle';
              return t;
            })
            .catch((t) => {
              if (t === 'aborted') {
                this.status = 'aborted';
                throw 'aborted';
              }
              this.status = 'error';
              throw this._reader.error ? this._reader.error : t;
            });
        }
        upload() {
          if (this.status != 'idle') {
            throw new h('filerepository-upload-wrong-status', this);
          }
          this.status = 'uploading';
          return this.file
            .then(() => this._adapter.upload())
            .then((t) => {
              this.uploadResponse = t;
              this.status = 'idle';
              return t;
            })
            .catch((t) => {
              if (this.status === 'aborted') {
                throw 'aborted';
              }
              this.status = 'error';
              throw t;
            });
        }
        abort() {
          const t = this.status;
          this.status = 'aborted';
          if (!this._filePromiseWrapper.isFulfilled) {
            this._filePromiseWrapper.promise.catch(() => {});
            this._filePromiseWrapper.rejecter('aborted');
          } else if (t == 'reading') {
            this._reader.abort();
          } else if (t == 'uploading' && this._adapter.abort) {
            this._adapter.abort();
          }
          this._destroy();
        }
        _destroy() {
          this._filePromiseWrapper = undefined;
          this._reader = undefined;
          this._adapter = undefined;
          this.uploadResponse = undefined;
        }
        _createFilePromiseWrapper(t) {
          const e = {};
          e.promise = new Promise((n, i) => {
            e.rejecter = i;
            e.isFulfilled = false;
            t.then((t) => {
              e.isFulfilled = true;
              n(t);
            }).catch((t) => {
              e.isFulfilled = true;
              i(t);
            });
          });
          return e;
        }
      }
      et(HP, q);
      class jP extends Dw {
        constructor(t) {
          super(t);
          this.buttonView = new iv(t);
          this._fileInputView = new qP(t);
          this._fileInputView.bind('acceptedType').to(this);
          this._fileInputView.bind('allowMultipleFiles').to(this);
          this._fileInputView.delegate('done').to(this);
          this.setTemplate({
            tag: 'span',
            attributes: { class: 'ck-file-dialog-button' },
            children: [this.buttonView, this._fileInputView],
          });
          this.buttonView.on('execute', () => {
            this._fileInputView.open();
          });
        }
        focus() {
          this.buttonView.focus();
        }
      }
      class qP extends Dw {
        constructor(t) {
          super(t);
          this.set('acceptedType');
          this.set('allowMultipleFiles', false);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: 'input',
            attributes: {
              class: ['ck-hidden'],
              type: 'file',
              tabindex: '-1',
              accept: e.to('acceptedType'),
              multiple: e.to('allowMultipleFiles'),
            },
            on: {
              change: e.to(() => {
                if (
                  this.element &&
                  this.element.files &&
                  this.element.files.length
                ) {
                  this.fire('done', this.element.files);
                }
                this.element.value = '';
              }),
            },
          });
        }
        open() {
          this.element.click();
        }
      }
      class WP extends (null && Plugin) {
        static get requires() {
          return [FileRepository];
        }
        static get pluginName() {
          return 'Base64UploadAdapter';
        }
        init() {
          this.editor.plugins.get(
            FileRepository
          ).createUploadAdapter = (t) => new UP(t);
        }
      }
      class UP {
        constructor(t) {
          this.loader = t;
        }
        upload() {
          return new Promise((t, e) => {
            const n = (this.reader = new window.FileReader());
            n.addEventListener('load', () => {
              t({ default: n.result });
            });
            n.addEventListener('error', (t) => {
              e(t);
            });
            n.addEventListener('abort', () => {
              e();
            });
            this.loader.file.then((t) => {
              n.readAsDataURL(t);
            });
          });
        }
        abort() {
          this.reader.abort();
        }
      }
      class GP extends nt {
        static get requires() {
          return [VP];
        }
        static get pluginName() {
          return 'SimpleUploadAdapter';
        }
        init() {
          const t = this.editor.config.get('simpleUpload');
          if (!t) {
            return;
          }
          if (!t.uploadUrl) {
            u('simple-upload-adapter-missing-uploadurl');
            return;
          }
          this.editor.plugins.get(VP).createUploadAdapter = (e) =>
            new $P(e, t);
        }
      }
      class $P {
        constructor(t, e) {
          this.loader = t;
          this.options = e;
        }
        upload() {
          return this.loader.file.then(
            (t) =>
              new Promise((e, n) => {
                this._initRequest();
                this._initListeners(e, n, t);
                this._sendRequest(t);
              })
          );
        }
        abort() {
          if (this.xhr) {
            this.xhr.abort();
          }
        }
        _initRequest() {
          const t = (this.xhr = new XMLHttpRequest());
          t.open('POST', this.options.uploadUrl, true);
          t.responseType = 'json';
        }
        _initListeners(t, e, n) {
          const i = this.xhr;
          const o = this.loader;
          const r = `Couldn't upload file: ${n.name}.`;
          i.addEventListener('error', () => e(r));
          i.addEventListener('abort', () => e());
          i.addEventListener('load', () => {
            const n = i.response;
            if (!n || n.error) {
              return e(
                n && n.error && n.error.message ? n.error.message : r
              );
            }
            const o = n.url ? { default: n.url } : n.urls;
            t({ ...n, urls: o });
          });
          if (i.upload) {
            i.upload.addEventListener('progress', (t) => {
              if (t.lengthComputable) {
                o.uploadTotal = t.total;
                o.uploaded = t.loaded;
              }
            });
          }
        }
        _sendRequest(t) {
          const e = this.options.headers || {};
          const n = this.options.withCredentials || false;
          for (const t of Object.keys(e)) {
            this.xhr.setRequestHeader(t, e[t]);
          }
          this.xhr.withCredentials = n;
          const i = new FormData();
          i.append('upload', t);
          this.xhr.send(i);
        }
      }
      function KP(t) {
        const e = t.map((t) => t.replace('+', '\\+'));
        return new RegExp(`^image\\/(${e.join('|')})$`);
      }
      function ZP(t) {
        return new Promise((e, n) => {
          const i = t.getAttribute('src');
          fetch(i)
            .then((t) => t.blob())
            .then((t) => {
              const n = YP(t, i);
              const o = n.replace('image/', '');
              const r = `image.${o}`;
              const s = new File([t], r, { type: n });
              e(s);
            })
            .catch((t) =>
              t && t.name === 'TypeError'
                ? QP(i).then(e).catch(n)
                : n(t)
            );
        });
      }
      function JP(t, e) {
        if (!t.isInlineImageView(e) || !e.getAttribute('src')) {
          return false;
        }
        return (
          e.getAttribute('src').match(/^data:image\/\w+;base64,/g) ||
          e.getAttribute('src').match(/^blob:/g)
        );
      }
      function YP(t, e) {
        if (t.type) {
          return t.type;
        } else if (e.match(/data:(image\/\w+);base64/)) {
          return e.match(/data:(image\/\w+);base64/)[1].toLowerCase();
        } else {
          return 'image/jpeg';
        }
      }
      function QP(t) {
        return XP(t).then((e) => {
          const n = YP(e, t);
          const i = n.replace('image/', '');
          const o = `image.${i}`;
          return new File([e], o, { type: n });
        });
      }
      function XP(t) {
        return new Promise((e, n) => {
          const i = Sa.document.createElement('img');
          i.addEventListener('load', () => {
            const t = Sa.document.createElement('canvas');
            t.width = i.width;
            t.height = i.height;
            const o = t.getContext('2d');
            o.drawImage(i, 0, 0);
            t.toBlob((t) => (t ? e(t) : n()));
          });
          i.addEventListener('error', () => n());
          i.src = t;
        });
      }
      class tI extends nt {
        static get pluginName() {
          return 'ImageUploadUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = (n) => {
            const i = new jP(n);
            const o = t.commands.get('uploadImage');
            const r = t.config.get('image.upload.types');
            const s = KP(r);
            i.set({
              acceptedType: r.map((t) => `image/${t}`).join(','),
              allowMultipleFiles: true,
            });
            i.buttonView.set({
              label: e('Insert image'),
              icon: M_.image,
              tooltip: true,
            });
            i.buttonView.bind('isEnabled').to(o);
            i.on('done', (e, n) => {
              const i = Array.from(n).filter((t) => s.test(t.type));
              if (i.length) {
                t.execute('uploadImage', { file: i });
                t.editing.view.focus();
              }
            });
            return i;
          };
          t.ui.componentFactory.add('uploadImage', n);
          t.ui.componentFactory.add('imageUpload', n);
        }
      }
      var eI = n(5870);
      var nI = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      nI.insert = 'head';
      nI.singleton = true;
      var iI = Lh()(eI.Z, nI);
      const oI = eI.Z.locals || {};
      var rI = n(9899);
      var sI = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      sI.insert = 'head';
      sI.singleton = true;
      var aI = Lh()(rI.Z, sI);
      const cI = rI.Z.locals || {};
      var lI = n(9825);
      var dI = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      dI.insert = 'head';
      dI.singleton = true;
      var hI = Lh()(lI.Z, dI);
      const uI = lI.Z.locals || {};
      class fI extends nt {
        static get pluginName() {
          return 'ImageUploadProgress';
        }
        constructor(t) {
          super(t);
          this.placeholder =
            'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
        }
        init() {
          const t = this.editor;
          if (t.plugins.has('ImageBlockEditing')) {
            t.editing.downcastDispatcher.on(
              'attribute:uploadStatus:imageBlock',
              (...t) => this.uploadStatusChange(...t)
            );
          }
          if (t.plugins.has('ImageInlineEditing')) {
            t.editing.downcastDispatcher.on(
              'attribute:uploadStatus:imageInline',
              (...t) => this.uploadStatusChange(...t)
            );
          }
        }
        uploadStatusChange(t, e, n) {
          const i = this.editor;
          const o = e.item;
          const r = o.getAttribute('uploadId');
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const s = i.plugins.get('ImageUtils');
          const a = i.plugins.get(VP);
          const c = r ? e.attributeNewValue : null;
          const l = this.placeholder;
          const d = i.editing.mapper.toViewElement(o);
          const h = n.writer;
          if (c == 'reading') {
            gI(d, h);
            pI(s, l, d, h);
            return;
          }
          if (c == 'uploading') {
            const t = a.loaders.get(r);
            gI(d, h);
            if (!t) {
              pI(s, l, d, h);
            } else {
              kI(d, h);
              bI(d, h, t, i.editing.view);
              xI(s, d, h, t);
            }
            return;
          }
          if (c == 'complete' && a.loaders.get(r)) {
            _I(d, h, i.editing.view);
          }
          wI(d, h);
          kI(d, h);
          mI(d, h);
        }
      }
      function gI(t, e) {
        if (!t.hasClass('ck-appear')) {
          e.addClass('ck-appear', t);
        }
      }
      function mI(t, e) {
        e.removeClass('ck-appear', t);
      }
      function pI(t, e, n, i) {
        if (!n.hasClass('ck-image-upload-placeholder')) {
          i.addClass('ck-image-upload-placeholder', n);
        }
        const o = t.findViewImgElement(n);
        if (o.getAttribute('src') !== e) {
          i.setAttribute('src', e, o);
        }
        if (!CI(n, 'placeholder')) {
          i.insert(i.createPositionAfter(o), AI(i));
        }
      }
      function kI(t, e) {
        if (t.hasClass('ck-image-upload-placeholder')) {
          e.removeClass('ck-image-upload-placeholder', t);
        }
        yI(t, e, 'placeholder');
      }
      function bI(t, e, n, i) {
        const o = vI(e);
        e.insert(e.createPositionAt(t, 'end'), o);
        n.on('change:uploadedPercent', (t, e, n) => {
          i.change((t) => {
            t.setStyle('width', n + '%', o);
          });
        });
      }
      function wI(t, e) {
        yI(t, e, 'progressBar');
      }
      function _I(t, e, n) {
        const i = e.createUIElement('div', {
          class: 'ck-image-upload-complete-icon',
        });
        e.insert(e.createPositionAt(t, 'end'), i);
        setTimeout(() => {
          n.change((t) => t.remove(t.createRangeOn(i)));
        }, 3e3);
      }
      function vI(t) {
        const e = t.createUIElement('div', {
          class: 'ck-progress-bar',
        });
        t.setCustomProperty('progressBar', true, e);
        return e;
      }
      function AI(t) {
        const e = t.createUIElement('div', {
          class: 'ck-upload-placeholder-loader',
        });
        t.setCustomProperty('placeholder', true, e);
        return e;
      }
      function CI(t, e) {
        for (const n of t.getChildren()) {
          if (n.getCustomProperty(e)) {
            return n;
          }
        }
      }
      function yI(t, e, n) {
        const i = CI(t, n);
        if (i) {
          e.remove(e.createRangeOn(i));
        }
      }
      function xI(t, e, n, i) {
        if (i.data) {
          const o = t.findViewImgElement(e);
          n.setAttribute('src', i.data, o);
        }
      }
      class EI extends ot {
        refresh() {
          const t = this.editor;
          const e = t.plugins.get('ImageUtils');
          const n = t.model.document.selection.getSelectedElement();
          this.isEnabled = e.isImageAllowed() || e.isImage(n);
        }
        execute(t) {
          const e = Ea(t.file);
          const n = this.editor.model.document.selection;
          const i = this.editor.plugins.get('ImageUtils');
          const o = Object.fromEntries(n.getAttributes());
          e.forEach((t, e) => {
            const r = n.getSelectedElement();
            if (e && r && i.isImage(r)) {
              const e = this.editor.model.createPositionAfter(r);
              this._uploadImage(t, o, e);
            } else {
              this._uploadImage(t, o);
            }
          });
        }
        _uploadImage(t, e, n) {
          const i = this.editor;
          const o = i.plugins.get(VP);
          const r = o.createLoader(t);
          const s = i.plugins.get('ImageUtils');
          if (!r) {
            return;
          }
          s.insertImage({ ...e, uploadId: r.id }, n);
        }
      }
      class DI extends nt {
        static get requires() {
          return [VP, JA, Ex, kS];
        }
        static get pluginName() {
          return 'ImageUploadEditing';
        }
        constructor(t) {
          super(t);
          t.config.define('image', {
            upload: {
              types: ['jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff'],
            },
          });
          this._uploadImageElements = new Map();
        }
        init() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.conversion;
          const i = t.plugins.get(VP);
          const o = t.plugins.get('ImageUtils');
          const r = KP(t.config.get('image.upload.types'));
          const s = new EI(t);
          t.commands.add('uploadImage', s);
          t.commands.add('imageUpload', s);
          n.for('upcast').attributeToAttribute({
            view: { name: 'img', key: 'uploadId' },
            model: 'uploadId',
          });
          this.listenTo(
            t.editing.view.document,
            'clipboardInput',
            (e, n) => {
              if (SI(n.dataTransfer)) {
                return;
              }
              const i = Array.from(n.dataTransfer.files).filter(
                (t) => {
                  if (!t) {
                    return false;
                  }
                  return r.test(t.type);
                }
              );
              if (!i.length) {
                return;
              }
              e.stop();
              t.model.change((e) => {
                if (n.targetRanges) {
                  e.setSelection(
                    n.targetRanges.map((e) =>
                      t.editing.mapper.toModelRange(e)
                    )
                  );
                }
                t.model.enqueueChange(() => {
                  t.execute('uploadImage', { file: i });
                });
              });
            }
          );
          this.listenTo(
            t.plugins.get('ClipboardPipeline'),
            'inputTransformation',
            (e, n) => {
              const r = Array.from(
                t.editing.view.createRangeIn(n.content)
              )
                .filter(
                  (t) =>
                    JP(o, t.item) &&
                    !t.item.getAttribute('uploadProcessed')
                )
                .map((t) => ({
                  promise: ZP(t.item),
                  imageElement: t.item,
                }));
              if (!r.length) {
                return;
              }
              const s = new iy(t.editing.view.document);
              for (const t of r) {
                s.setAttribute(
                  'uploadProcessed',
                  true,
                  t.imageElement
                );
                const e = i.createLoader(t.promise);
                if (e) {
                  s.setAttribute('src', '', t.imageElement);
                  s.setAttribute('uploadId', e.id, t.imageElement);
                }
              }
            }
          );
          t.editing.view.document.on('dragover', (t, e) => {
            e.preventDefault();
          });
          e.on('change', () => {
            const n = e.differ
              .getChanges({ includeChangesInGraveyard: true })
              .reverse();
            const o = new Set();
            for (const e of n) {
              if (e.type == 'insert' && e.name != '$text') {
                const n = e.position.nodeAfter;
                const r = e.position.root.rootName == '$graveyard';
                for (const e of TI(t, n)) {
                  const t = e.getAttribute('uploadId');
                  if (!t) {
                    continue;
                  }
                  const n = i.loaders.get(t);
                  if (!n) {
                    continue;
                  }
                  if (r) {
                    if (!o.has(t)) {
                      n.abort();
                    }
                  } else {
                    o.add(t);
                    this._uploadImageElements.set(t, e);
                    if (n.status == 'idle') {
                      this._readAndUpload(n);
                    }
                  }
                }
              }
            }
          });
          this.on(
            'uploadComplete',
            (t, { imageElement: e, data: n }) => {
              const i = n.urls ? n.urls : n;
              this.editor.model.change((t) => {
                t.setAttribute('src', i.default, e);
                this._parseAndSetSrcsetAttributeOnImage(i, e, t);
              });
            },
            { priority: 'low' }
          );
        }
        afterInit() {
          const t = this.editor.model.schema;
          if (this.editor.plugins.has('ImageBlockEditing')) {
            t.extend('imageBlock', {
              allowAttributes: ['uploadId', 'uploadStatus'],
            });
          }
          if (this.editor.plugins.has('ImageInlineEditing')) {
            t.extend('imageInline', {
              allowAttributes: ['uploadId', 'uploadStatus'],
            });
          }
        }
        _readAndUpload(t) {
          const e = this.editor;
          const n = e.model;
          const i = e.locale.t;
          const o = e.plugins.get(VP);
          const r = e.plugins.get(JA);
          const s = e.plugins.get('ImageUtils');
          const a = this._uploadImageElements;
          n.enqueueChange({ isUndoable: false }, (e) => {
            e.setAttribute('uploadStatus', 'reading', a.get(t.id));
          });
          return t
            .read()
            .then(() => {
              const i = t.upload();
              const o = a.get(t.id);
              if (Sd.isSafari) {
                const t = e.editing.mapper.toViewElement(o);
                const n = s.findViewImgElement(t);
                e.editing.view.once('render', () => {
                  if (!n.parent) {
                    return;
                  }
                  const t = e.editing.view.domConverter.mapViewToDom(
                    n.parent
                  );
                  if (!t) {
                    return;
                  }
                  const i = t.style.display;
                  t.style.display = 'none';
                  t._ckHack = t.offsetHeight;
                  t.style.display = i;
                });
              }
              n.enqueueChange({ isUndoable: false }, (t) => {
                t.setAttribute('uploadStatus', 'uploading', o);
              });
              return i;
            })
            .then((e) => {
              n.enqueueChange({ isUndoable: false }, (n) => {
                const i = a.get(t.id);
                n.setAttribute('uploadStatus', 'complete', i);
                this.fire('uploadComplete', {
                  data: e,
                  imageElement: i,
                });
              });
              c();
            })
            .catch((e) => {
              if (t.status !== 'error' && t.status !== 'aborted') {
                throw e;
              }
              if (t.status == 'error' && e) {
                r.showWarning(e, {
                  title: i('Upload failed'),
                  namespace: 'upload',
                });
              }
              n.enqueueChange({ isUndoable: false }, (e) => {
                e.remove(a.get(t.id));
              });
              c();
            });
          function c() {
            n.enqueueChange({ isUndoable: false }, (e) => {
              const n = a.get(t.id);
              e.removeAttribute('uploadId', n);
              e.removeAttribute('uploadStatus', n);
              a.delete(t.id);
            });
            o.destroyLoader(t);
          }
        }
        _parseAndSetSrcsetAttributeOnImage(t, e, n) {
          let i = 0;
          const o = Object.keys(t)
            .filter((t) => {
              const e = parseInt(t, 10);
              if (!isNaN(e)) {
                i = Math.max(i, e);
                return true;
              }
            })
            .map((e) => `${t[e]} ${e}w`)
            .join(', ');
          if (o != '') {
            n.setAttribute('srcset', { data: o, width: i }, e);
          }
        }
      }
      function SI(t) {
        return (
          Array.from(t.types).includes('text/html') &&
          t.getData('text/html') !== ''
        );
      }
      function TI(t, e) {
        const n = t.plugins.get('ImageUtils');
        return Array.from(t.model.createRangeOn(e))
          .filter((t) => n.isImage(t.item))
          .map((t) => t.item);
      }
      class BI extends nt {
        static get pluginName() {
          return 'ImageUpload';
        }
        static get requires() {
          return [DI, tI, fI];
        }
      }
      var PI = n(5150);
      var II = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      II.insert = 'head';
      II.singleton = true;
      var RI = Lh()(PI.Z, II);
      const zI = PI.Z.locals || {};
      class OI extends Dw {
        constructor(t, e = {}) {
          super(t);
          const n = this.bindTemplate;
          this.set('class', e.class || null);
          this.children = this.createCollection();
          if (e.children) {
            e.children.forEach((t) => this.children.add(t));
          }
          this.set('_role', null);
          this.set('_ariaLabelledBy', null);
          if (e.labelView) {
            this.set({
              _role: 'group',
              _ariaLabelledBy: e.labelView.id,
            });
          }
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-form__row', n.to('class')],
              role: n.to('_role'),
              'aria-labelledby': n.to('_ariaLabelledBy'),
            },
            children: this.children,
          });
        }
      }
      var FI = n(9292);
      var NI = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      NI.insert = 'head';
      NI.singleton = true;
      var MI = Lh()(FI.Z, NI);
      const LI = FI.Z.locals || {};
      class VI extends Dw {
        constructor(t, e) {
          super(t);
          const { insertButtonView: n, cancelButtonView: i } =
            this._createActionButtons(t);
          this.insertButtonView = n;
          this.cancelButtonView = i;
          this.set('imageURLInputValue', '');
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this._focusables = new Kb();
          this._focusCycler = new Iv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: 'shift + tab',
              focusNext: 'tab',
            },
          });
          this.set('_integrations', new ya());
          if (e) {
            for (const [t, n] of Object.entries(e)) {
              if (t === 'insertImageViaUrl') {
                n.fieldView
                  .bind('value')
                  .to(this, 'imageURLInputValue', (t) => t || '');
                n.fieldView.on('input', () => {
                  this.imageURLInputValue =
                    n.fieldView.element.value.trim();
                });
              }
              n.name = t;
              this._integrations.add(n);
            }
          }
          this.setTemplate({
            tag: 'form',
            attributes: {
              class: ['ck', 'ck-image-insert-form'],
              tabindex: '-1',
            },
            children: [
              ...this._integrations,
              new OI(t, {
                children: [
                  this.insertButtonView,
                  this.cancelButtonView,
                ],
                class: 'ck-image-insert-form__action-row',
              }),
            ],
          });
        }
        render() {
          super.render();
          H_({ view: this });
          const t = [
            ...this._integrations,
            this.insertButtonView,
            this.cancelButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
          const e = (t) => t.stopPropagation();
          this.keystrokes.set('arrowright', e);
          this.keystrokes.set('arrowleft', e);
          this.keystrokes.set('arrowup', e);
          this.keystrokes.set('arrowdown', e);
          this.listenTo(
            t[0].element,
            'selectstart',
            (t, e) => {
              e.stopPropagation();
            },
            { priority: 'high' }
          );
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        getIntegration(t) {
          return this._integrations.find((e) => e.name === t);
        }
        _createActionButtons(t) {
          const e = t.t;
          const n = new iv(t);
          const i = new iv(t);
          n.set({
            label: e('Insert'),
            icon: M_.check,
            class: 'ck-button-save',
            type: 'submit',
            withText: true,
            isEnabled: this.imageURLInputValue,
          });
          i.set({
            label: e('Cancel'),
            icon: M_.cancel,
            class: 'ck-button-cancel',
            withText: true,
          });
          n.bind('isEnabled').to(
            this,
            'imageURLInputValue',
            (t) => !!t
          );
          n.delegate('execute').to(this, 'submit');
          i.delegate('execute').to(this, 'cancel');
          return { insertButtonView: n, cancelButtonView: i };
        }
        focus() {
          this._focusCycler.focusFirst();
        }
      }
      function HI(t) {
        const e = t.config.get('image.insert.integrations');
        const n = t.plugins.get('ImageInsertUI');
        const i = { insertImageViaUrl: jI(t.locale) };
        if (!e) {
          return i;
        }
        if (
          e.find((t) => t === 'openCKFinder') &&
          t.ui.componentFactory.has('ckfinder')
        ) {
          const e = t.ui.componentFactory.create('ckfinder');
          e.set({
            withText: true,
            class: 'ck-image-insert__ck-finder-button',
          });
          e.delegate('execute').to(n, 'cancel');
          i.openCKFinder = e;
        }
        return e.reduce((e, n) => {
          if (i[n]) {
            e[n] = i[n];
          } else if (t.ui.componentFactory.has(n)) {
            e[n] = t.ui.componentFactory.create(n);
          }
          return e;
        }, {});
      }
      function jI(t) {
        const e = t.t;
        const n = new GA(t, $A);
        n.set({ label: e('Insert image via URL') });
        n.fieldView.placeholder = 'https://example.com/image.png';
        return n;
      }
      class qI extends nt {
        static get pluginName() {
          return 'ImageInsertUI';
        }
        init() {
          const t = this.editor;
          const e = (t) => this._createDropdownView(t);
          t.ui.componentFactory.add('insertImage', e);
          t.ui.componentFactory.add('imageInsert', e);
        }
        _createDropdownView(t) {
          const e = this.editor;
          const n = t.t;
          const i = e.commands.get('uploadImage');
          const o = e.commands.get('insertImage');
          this.dropdownView = aA(t, i ? xv : undefined);
          const r = this.dropdownView.buttonView;
          const s = this.dropdownView.panelView;
          r.set({
            label: n('Insert image'),
            icon: M_.image,
            tooltip: true,
          });
          s.extendTemplate({
            attributes: { class: 'ck-image-insert__panel' },
          });
          if (i) {
            const t = this.dropdownView.buttonView;
            t.actionView =
              e.ui.componentFactory.create('uploadImage');
            t.actionView.extendTemplate({
              attributes: {
                class: 'ck ck-button ck-splitbutton__action',
              },
            });
          }
          return this._setUpDropdown(i || o);
        }
        _setUpDropdown(t) {
          const e = this.editor;
          const n = e.t;
          const i = new VI(e.locale, HI(e));
          const o = i.insertButtonView;
          const r = i.getIntegration('insertImageViaUrl');
          const s = this.dropdownView;
          const a = s.panelView;
          const c = this.editor.plugins.get('ImageUtils');
          s.bind('isEnabled').to(t);
          s.buttonView.once('open', () => {
            a.children.add(i);
          });
          s.on(
            'change:isOpen',
            () => {
              const t =
                e.model.document.selection.getSelectedElement();
              if (s.isOpen) {
                if (c.isImage(t)) {
                  i.imageURLInputValue = t.getAttribute('src');
                  o.label = n('Update');
                  r.label = n('Update image URL');
                } else {
                  i.imageURLInputValue = '';
                  o.label = n('Insert');
                  r.label = n('Insert image via URL');
                }
              }
            },
            { priority: 'low' }
          );
          i.delegate('submit', 'cancel').to(s);
          this.delegate('cancel').to(s);
          s.on('submit', () => {
            d();
            l();
          });
          s.on('cancel', () => {
            d();
          });
          function l() {
            const t = e.model.document.selection.getSelectedElement();
            if (c.isImage(t)) {
              e.model.change((e) => {
                e.setAttribute('src', i.imageURLInputValue, t);
                e.removeAttribute('srcset', t);
                e.removeAttribute('sizes', t);
              });
            } else {
              e.execute('insertImage', {
                source: i.imageURLInputValue,
              });
            }
          }
          function d() {
            e.editing.view.focus();
            s.isOpen = false;
          }
          return s;
        }
      }
      class WI extends nt {
        static get pluginName() {
          return 'ImageInsertViaUrl';
        }
        static get requires() {
          return [qI];
        }
      }
      class UI extends nt {
        static get pluginName() {
          return 'ImageInsert';
        }
        static get requires() {
          return [BI, WI, qI];
        }
      }
      class GI extends ot {
        refresh() {
          const t = this.editor;
          const e = t.plugins.get('ImageUtils');
          const n = e.getClosestSelectedImageElement(
            t.model.document.selection
          );
          this.isEnabled = !!n;
          if (!n || !n.hasAttribute('width')) {
            this.value = null;
          } else {
            this.value = {
              width: n.getAttribute('width'),
              height: null,
            };
          }
        }
        execute(t) {
          const e = this.editor;
          const n = e.model;
          const i = e.plugins.get('ImageUtils');
          const o = i.getClosestSelectedImageElement(
            n.document.selection
          );
          this.value = { width: t.width, height: null };
          if (o) {
            n.change((e) => {
              e.setAttribute('width', t.width, o);
            });
          }
        }
      }
      class $I extends nt {
        static get requires() {
          return [kS];
        }
        static get pluginName() {
          return 'ImageResizeEditing';
        }
        constructor(t) {
          super(t);
          t.config.define('image', {
            resizeUnit: '%',
            resizeOptions: [
              {
                name: 'resizeImage:original',
                value: null,
                icon: 'original',
              },
              { name: 'resizeImage:25', value: '25', icon: 'small' },
              { name: 'resizeImage:50', value: '50', icon: 'medium' },
              { name: 'resizeImage:75', value: '75', icon: 'large' },
            ],
          });
        }
        init() {
          const t = this.editor;
          const e = new GI(t);
          this._registerSchema();
          this._registerConverters('imageBlock');
          this._registerConverters('imageInline');
          t.commands.add('resizeImage', e);
          t.commands.add('imageResize', e);
        }
        _registerSchema() {
          if (this.editor.plugins.has('ImageBlockEditing')) {
            this.editor.model.schema.extend('imageBlock', {
              allowAttributes: 'width',
            });
          }
          if (this.editor.plugins.has('ImageInlineEditing')) {
            this.editor.model.schema.extend('imageInline', {
              allowAttributes: 'width',
            });
          }
        }
        _registerConverters(t) {
          const e = this.editor;
          e.conversion.for('downcast').add((e) =>
            e.on(`attribute:width:${t}`, (t, e, n) => {
              if (!n.consumable.consume(e.item, t.name)) {
                return;
              }
              const i = n.writer;
              const o = n.mapper.toViewElement(e.item);
              if (e.attributeNewValue !== null) {
                i.setStyle('width', e.attributeNewValue, o);
                i.addClass('image_resized', o);
              } else {
                i.removeStyle('width', o);
                i.removeClass('image_resized', o);
              }
            })
          );
          e.conversion
            .for('upcast')
            .attributeToAttribute({
              view: {
                name: t === 'imageBlock' ? 'figure' : 'img',
                styles: { width: /.+/ },
              },
              model: {
                key: 'width',
                value: (t) => t.getStyle('width'),
              },
            });
        }
      }
      const KI = {
        small: M_.objectSizeSmall,
        medium: M_.objectSizeMedium,
        large: M_.objectSizeLarge,
        original: M_.objectSizeFull,
      };
      class ZI extends nt {
        static get requires() {
          return [$I];
        }
        static get pluginName() {
          return 'ImageResizeButtons';
        }
        constructor(t) {
          super(t);
          this._resizeUnit = t.config.get('image.resizeUnit');
        }
        init() {
          const t = this.editor;
          const e = t.config.get('image.resizeOptions');
          const n = t.commands.get('resizeImage');
          this.bind('isEnabled').to(n);
          for (const t of e) {
            this._registerImageResizeButton(t);
          }
          this._registerImageResizeDropdown(e);
        }
        _registerImageResizeButton(t) {
          const e = this.editor;
          const { name: n, value: i, icon: o } = t;
          const r = i ? i + this._resizeUnit : null;
          e.ui.componentFactory.add(n, (n) => {
            const i = new iv(n);
            const s = e.commands.get('resizeImage');
            const a = this._getOptionLabelValue(t, true);
            if (!KI[o]) {
              throw new h('imageresizebuttons-missing-icon', e, t);
            }
            i.set({
              label: a,
              icon: KI[o],
              tooltip: a,
              isToggleable: true,
            });
            i.bind('isEnabled').to(this);
            i.bind('isOn').to(s, 'value', JI(r));
            this.listenTo(i, 'execute', () => {
              e.execute('resizeImage', { width: r });
            });
            return i;
          });
        }
        _registerImageResizeDropdown(t) {
          const e = this.editor;
          const n = e.t;
          const i = t.find((t) => !t.value);
          const o = (o) => {
            const r = e.commands.get('resizeImage');
            const s = aA(o, _v);
            const a = s.buttonView;
            a.set({
              tooltip: n('Resize image'),
              commandValue: i.value,
              icon: KI.medium,
              isToggleable: true,
              label: this._getOptionLabelValue(i),
              withText: true,
              class: 'ck-resize-image-button',
            });
            a.bind('label').to(r, 'value', (t) => {
              if (t && t.width) {
                return t.width;
              } else {
                return this._getOptionLabelValue(i);
              }
            });
            s.bind('isOn').to(r);
            s.bind('isEnabled').to(this);
            lA(s, this._getResizeDropdownListItemDefinitions(t, r));
            s.listView.ariaLabel = n('Image resize list');
            this.listenTo(s, 'execute', (t) => {
              e.execute(t.source.commandName, {
                width: t.source.commandValue,
              });
              e.editing.view.focus();
            });
            return s;
          };
          e.ui.componentFactory.add('resizeImage', o);
          e.ui.componentFactory.add('imageResize', o);
        }
        _getOptionLabelValue(t, e) {
          const n = this.editor.t;
          if (t.label) {
            return t.label;
          } else if (e) {
            if (t.value) {
              return n(
                'Resize image to %0',
                t.value + this._resizeUnit
              );
            } else {
              return n('Resize image to the original size');
            }
          } else {
            if (t.value) {
              return t.value + this._resizeUnit;
            } else {
              return n('Original');
            }
          }
        }
        _getResizeDropdownListItemDefinitions(t, e) {
          const n = new ya();
          t.map((t) => {
            const i = t.value ? t.value + this._resizeUnit : null;
            const o = {
              type: 'button',
              model: new YA({
                commandName: 'resizeImage',
                commandValue: i,
                label: this._getOptionLabelValue(t),
                withText: true,
                icon: null,
              }),
            };
            o.model.bind('isOn').to(e, 'value', JI(i));
            n.add(o);
          });
          return n;
        }
      }
      function JI(t) {
        return (e) => {
          if (t === null && e === t) {
            return true;
          }
          return e && e.width === t;
        };
      }
      const YI =
        'figure.image.ck-widget > img,' +
        'figure.image.ck-widget > picture > img,' +
        'figure.image.ck-widget > a > img,' +
        'figure.image.ck-widget > a > picture > img,' +
        'span.image-inline.ck-widget > img,' +
        'span.image-inline.ck-widget > picture > img';
      const QI = /(image|image-inline)/;
      const XI = 'image_resized';
      class tR extends nt {
        static get requires() {
          return [uS];
        }
        static get pluginName() {
          return 'ImageResizeHandles';
        }
        init() {
          const t = this.editor.commands.get('resizeImage');
          this.bind('isEnabled').to(t);
          this._setupResizerCreator();
        }
        _setupResizerCreator() {
          const t = this.editor;
          const e = t.editing.view;
          e.addObserver(EP);
          this.listenTo(e.document, 'imageLoaded', (n, i) => {
            if (!i.target.matches(YI)) {
              return;
            }
            const o = t.editing.view.domConverter;
            const r = o.domToView(i.target);
            const s = r.findAncestor({ classes: QI });
            let a = this.editor.plugins
              .get(uS)
              .getResizerByViewElement(s);
            if (a) {
              a.redraw();
              return;
            }
            const c = t.editing.mapper;
            const l = c.toModelElement(s);
            a = t.plugins.get(uS).attachTo({
              unit: t.config.get('image.resizeUnit'),
              modelElement: l,
              viewElement: s,
              editor: t,
              getHandleHost(t) {
                return t.querySelector('img');
              },
              getResizeHost() {
                return o.mapViewToDom(c.toViewElement(l.parent));
              },
              isCentered() {
                const t = l.getAttribute('imageStyle');
                return !t || t == 'block' || t == 'alignCenter';
              },
              onCommit(n) {
                e.change((t) => {
                  t.removeClass(XI, s);
                });
                t.execute('resizeImage', { width: n });
              },
            });
            a.on('updateSize', () => {
              if (!s.hasClass(XI)) {
                e.change((t) => {
                  t.addClass(XI, s);
                });
              }
            });
            a.bind('isEnabled').to(this);
          });
        }
      }
      var eR = n(1043);
      var nR = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      nR.insert = 'head';
      nR.singleton = true;
      var iR = Lh()(eR.Z, nR);
      const oR = eR.Z.locals || {};
      class rR extends nt {
        static get requires() {
          return [$I, tR, ZI];
        }
        static get pluginName() {
          return 'ImageResize';
        }
      }
      class sR extends ot {
        constructor(t, e) {
          super(t);
          this._defaultStyles = {
            imageBlock: false,
            imageInline: false,
          };
          this._styles = new Map(
            e.map((t) => {
              if (t.isDefault) {
                for (const e of t.modelElements) {
                  this._defaultStyles[e] = t.name;
                }
              }
              return [t.name, t];
            })
          );
        }
        refresh() {
          const t = this.editor;
          const e = t.plugins.get('ImageUtils');
          const n = e.getClosestSelectedImageElement(
            this.editor.model.document.selection
          );
          this.isEnabled = !!n;
          if (!this.isEnabled) {
            this.value = false;
          } else if (n.hasAttribute('imageStyle')) {
            this.value = n.getAttribute('imageStyle');
          } else {
            this.value = this._defaultStyles[n.name];
          }
        }
        execute(t = {}) {
          const e = this.editor;
          const n = e.model;
          const i = e.plugins.get('ImageUtils');
          n.change((e) => {
            const o = t.value;
            let r = i.getClosestSelectedImageElement(
              n.document.selection
            );
            if (o && this.shouldConvertImageType(o, r)) {
              this.editor.execute(
                i.isBlockImage(r)
                  ? 'imageTypeInline'
                  : 'imageTypeBlock'
              );
              r = i.getClosestSelectedImageElement(
                n.document.selection
              );
            }
            if (!o || this._styles.get(o).isDefault) {
              e.removeAttribute('imageStyle', r);
            } else {
              e.setAttribute('imageStyle', o, r);
            }
          });
        }
        shouldConvertImageType(t, e) {
          const n = this._styles.get(t).modelElements;
          return !n.includes(e.name);
        }
      }
      const {
        objectFullWidth: aR,
        objectInline: cR,
        objectLeft: lR,
        objectRight: dR,
        objectCenter: hR,
        objectBlockLeft: uR,
        objectBlockRight: fR,
      } = M_;
      const gR = {
        get inline() {
          return {
            name: 'inline',
            title: 'In line',
            icon: cR,
            modelElements: ['imageInline'],
            isDefault: true,
          };
        },
        get alignLeft() {
          return {
            name: 'alignLeft',
            title: 'Left aligned image',
            icon: lR,
            modelElements: ['imageBlock', 'imageInline'],
            className: 'image-style-align-left',
          };
        },
        get alignBlockLeft() {
          return {
            name: 'alignBlockLeft',
            title: 'Left aligned image',
            icon: uR,
            modelElements: ['imageBlock'],
            className: 'image-style-block-align-left',
          };
        },
        get alignCenter() {
          return {
            name: 'alignCenter',
            title: 'Centered image',
            icon: hR,
            modelElements: ['imageBlock'],
            className: 'image-style-align-center',
          };
        },
        get alignRight() {
          return {
            name: 'alignRight',
            title: 'Right aligned image',
            icon: dR,
            modelElements: ['imageBlock', 'imageInline'],
            className: 'image-style-align-right',
          };
        },
        get alignBlockRight() {
          return {
            name: 'alignBlockRight',
            title: 'Right aligned image',
            icon: fR,
            modelElements: ['imageBlock'],
            className: 'image-style-block-align-right',
          };
        },
        get block() {
          return {
            name: 'block',
            title: 'Centered image',
            icon: hR,
            modelElements: ['imageBlock'],
            isDefault: true,
          };
        },
        get side() {
          return {
            name: 'side',
            title: 'Side image',
            icon: dR,
            modelElements: ['imageBlock'],
            className: 'image-style-side',
          };
        },
      };
      const mR = {
        full: aR,
        left: uR,
        right: fR,
        center: hR,
        inlineLeft: lR,
        inlineRight: dR,
        inline: cR,
      };
      const pR = [
        {
          name: 'imageStyle:wrapText',
          title: 'Wrap text',
          defaultItem: 'imageStyle:alignLeft',
          items: ['imageStyle:alignLeft', 'imageStyle:alignRight'],
        },
        {
          name: 'imageStyle:breakText',
          title: 'Break text',
          defaultItem: 'imageStyle:block',
          items: [
            'imageStyle:alignBlockLeft',
            'imageStyle:block',
            'imageStyle:alignBlockRight',
          ],
        },
      ];
      function kR(t) {
        const e = t.configuredStyles.options || [];
        const n = e.map((t) => _R(t)).filter((e) => vR(e, t));
        return n;
      }
      function bR(t, e) {
        if (t && e) {
          return {
            options: [
              'inline',
              'alignLeft',
              'alignRight',
              'alignCenter',
              'alignBlockLeft',
              'alignBlockRight',
              'block',
              'side',
            ],
          };
        } else if (t) {
          return { options: ['block', 'side'] };
        } else if (e) {
          return { options: ['inline', 'alignLeft', 'alignRight'] };
        }
        return {};
      }
      function wR(t) {
        if (
          t.has('ImageBlockEditing') &&
          t.has('ImageInlineEditing')
        ) {
          return [...pR];
        } else {
          return [];
        }
      }
      function _R(t) {
        if (typeof t === 'string') {
          if (!gR[t]) {
            t = { name: t };
          } else {
            t = { ...gR[t] };
          }
        } else {
          t = AR(gR[t.name], t);
        }
        if (typeof t.icon === 'string') {
          t.icon = mR[t.icon] || t.icon;
        }
        return t;
      }
      function vR(
        t,
        { isBlockPluginLoaded: e, isInlinePluginLoaded: n }
      ) {
        const { modelElements: i, name: o } = t;
        if (!i || !i.length || !o) {
          CR({ style: t });
          return false;
        } else {
          const o = [
            e ? 'imageBlock' : null,
            n ? 'imageInline' : null,
          ];
          if (!i.some((t) => o.includes(t))) {
            u('image-style-missing-dependency', {
              style: t,
              missingPlugins: i.map((t) =>
                t === 'imageBlock'
                  ? 'ImageBlockEditing'
                  : 'ImageInlineEditing'
              ),
            });
            return false;
          }
        }
        return true;
      }
      function AR(t, e) {
        const n = { ...e };
        for (const i in t) {
          if (!Object.prototype.hasOwnProperty.call(e, i)) {
            n[i] = t[i];
          }
        }
        return n;
      }
      function CR(t) {
        u('image-style-configuration-definition-invalid', t);
      }
      const yR = {
        normalizeStyles: kR,
        getDefaultStylesConfiguration: bR,
        getDefaultDropdownDefinitions: wR,
        warnInvalidStyle: CR,
        DEFAULT_OPTIONS: gR,
        DEFAULT_ICONS: mR,
        DEFAULT_DROPDOWN_DEFINITIONS: pR,
      };
      function xR(t) {
        return (e, n, i) => {
          if (!i.consumable.consume(n.item, e.name)) {
            return;
          }
          const o = DR(n.attributeNewValue, t);
          const r = DR(n.attributeOldValue, t);
          const s = i.mapper.toViewElement(n.item);
          const a = i.writer;
          if (r) {
            a.removeClass(r.className, s);
          }
          if (o) {
            a.addClass(o.className, s);
          }
        };
      }
      function ER(t) {
        const e = {
          imageInline: t.filter(
            (t) =>
              !t.isDefault && t.modelElements.includes('imageInline')
          ),
          imageBlock: t.filter(
            (t) =>
              !t.isDefault && t.modelElements.includes('imageBlock')
          ),
        };
        return (t, n, i) => {
          if (!n.modelRange) {
            return;
          }
          const o = n.viewItem;
          const r = Xf(n.modelRange.getItems());
          if (!r) {
            return;
          }
          if (!i.schema.checkAttribute(r, 'imageStyle')) {
            return;
          }
          for (const t of e[r.name]) {
            if (i.consumable.consume(o, { classes: t.className })) {
              i.writer.setAttribute('imageStyle', t.name, r);
            }
          }
        };
      }
      function DR(t, e) {
        for (const n of e) {
          if (n.name === t) {
            return n;
          }
        }
      }
      class SR extends nt {
        static get pluginName() {
          return 'ImageStyleEditing';
        }
        static get requires() {
          return [kS];
        }
        init() {
          const {
            normalizeStyles: t,
            getDefaultStylesConfiguration: e,
          } = yR;
          const n = this.editor;
          const i = n.plugins.has('ImageBlockEditing');
          const o = n.plugins.has('ImageInlineEditing');
          n.config.define('image.styles', e(i, o));
          this.normalizedStyles = t({
            configuredStyles: n.config.get('image.styles'),
            isBlockPluginLoaded: i,
            isInlinePluginLoaded: o,
          });
          this._setupConversion(i, o);
          this._setupPostFixer();
          n.commands.add(
            'imageStyle',
            new sR(n, this.normalizedStyles)
          );
        }
        _setupConversion(t, e) {
          const n = this.editor;
          const i = n.model.schema;
          const o = xR(this.normalizedStyles);
          const r = ER(this.normalizedStyles);
          n.editing.downcastDispatcher.on('attribute:imageStyle', o);
          n.data.downcastDispatcher.on('attribute:imageStyle', o);
          if (t) {
            i.extend('imageBlock', { allowAttributes: 'imageStyle' });
            n.data.upcastDispatcher.on('element:figure', r, {
              priority: 'low',
            });
          }
          if (e) {
            i.extend('imageInline', {
              allowAttributes: 'imageStyle',
            });
            n.data.upcastDispatcher.on('element:img', r, {
              priority: 'low',
            });
          }
        }
        _setupPostFixer() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.plugins.get(kS);
          const i = new Map(
            this.normalizedStyles.map((t) => [t.name, t])
          );
          e.registerPostFixer((t) => {
            let o = false;
            for (const r of e.differ.getChanges()) {
              if (
                r.type == 'insert' ||
                (r.type == 'attribute' &&
                  r.attributeKey == 'imageStyle')
              ) {
                let e =
                  r.type == 'insert'
                    ? r.position.nodeAfter
                    : r.range.start.nodeAfter;
                if (
                  e &&
                  e.is('element', 'paragraph') &&
                  e.childCount > 0
                ) {
                  e = e.getChild(0);
                }
                if (!n.isImage(e)) {
                  continue;
                }
                const s = e.getAttribute('imageStyle');
                if (!s) {
                  continue;
                }
                const a = i.get(s);
                if (!a || !a.modelElements.includes(e.name)) {
                  t.removeAttribute('imageStyle', e);
                  o = true;
                }
              }
            }
            return o;
          });
        }
      }
      var TR = n(4622);
      var BR = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      BR.insert = 'head';
      BR.singleton = true;
      var PR = Lh()(TR.Z, BR);
      const IR = TR.Z.locals || {};
      class RR extends nt {
        static get requires() {
          return [SR];
        }
        static get pluginName() {
          return 'ImageStyleUI';
        }
        get localizedDefaultStylesTitles() {
          const t = this.editor.t;
          return {
            'Wrap text': t('Wrap text'),
            'Break text': t('Break text'),
            'In line': t('In line'),
            'Full size image': t('Full size image'),
            'Side image': t('Side image'),
            'Left aligned image': t('Left aligned image'),
            'Centered image': t('Centered image'),
            'Right aligned image': t('Right aligned image'),
          };
        }
        init() {
          const t = this.editor.plugins;
          const e = this.editor.config.get('image.toolbar') || [];
          const n = zR(
            t.get('ImageStyleEditing').normalizedStyles,
            this.localizedDefaultStylesTitles
          );
          for (const t of n) {
            this._createButton(t);
          }
          const i = zR(
            [...e.filter(N), ...yR.getDefaultDropdownDefinitions(t)],
            this.localizedDefaultStylesTitles
          );
          for (const t of i) {
            this._createDropdown(t, n);
          }
        }
        _createDropdown(t, e) {
          const n = this.editor.ui.componentFactory;
          n.add(t.name, (i) => {
            let o;
            const { defaultItem: r, items: s, title: a } = t;
            const c = s
              .filter((t) => e.find(({ name: e }) => OR(e) === t))
              .map((t) => {
                const e = n.create(t);
                if (t === r) {
                  o = e;
                }
                return e;
              });
            if (s.length !== c.length) {
              yR.warnInvalidStyle({ dropdown: t });
            }
            const l = aA(i, xv);
            const d = l.buttonView;
            const h = d.arrowView;
            cA(l, c, { enableActiveItemFocusOnDropdownOpen: true });
            d.set({
              label: FR(a, o.label),
              class: null,
              tooltip: true,
            });
            h.unbind('label');
            h.set({ label: a });
            d.bind('icon').toMany(c, 'isOn', (...t) => {
              const e = t.findIndex(gl);
              return e < 0 ? o.icon : c[e].icon;
            });
            d.bind('label').toMany(c, 'isOn', (...t) => {
              const e = t.findIndex(gl);
              return FR(a, e < 0 ? o.label : c[e].label);
            });
            d.bind('isOn').toMany(c, 'isOn', (...t) => t.some(gl));
            d.bind('class').toMany(c, 'isOn', (...t) =>
              t.some(gl) ? 'ck-splitbutton_flatten' : null
            );
            d.on('execute', () => {
              if (!c.some(({ isOn: t }) => t)) {
                o.fire('execute');
              } else {
                l.isOpen = !l.isOpen;
              }
            });
            l.bind('isEnabled').toMany(c, 'isEnabled', (...t) =>
              t.some(gl)
            );
            this.listenTo(l, 'execute', () => {
              this.editor.editing.view.focus();
            });
            return l;
          });
        }
        _createButton(t) {
          const e = t.name;
          this.editor.ui.componentFactory.add(OR(e), (n) => {
            const i = this.editor.commands.get('imageStyle');
            const o = new iv(n);
            o.set({
              label: t.title,
              icon: t.icon,
              tooltip: true,
              isToggleable: true,
            });
            o.bind('isEnabled').to(i, 'isEnabled');
            o.bind('isOn').to(i, 'value', (t) => t === e);
            o.on('execute', this._executeCommand.bind(this, e));
            return o;
          });
        }
        _executeCommand(t) {
          this.editor.execute('imageStyle', { value: t });
          this.editor.editing.view.focus();
        }
      }
      function zR(t, e) {
        for (const n of t) {
          if (e[n.title]) {
            n.title = e[n.title];
          }
        }
        return t;
      }
      function OR(t) {
        return `imageStyle:${t}`;
      }
      function FR(t, e) {
        return (t ? t + ': ' : '') + e;
      }
      class NR extends nt {
        static get requires() {
          return [SR, RR];
        }
        static get pluginName() {
          return 'ImageStyle';
        }
      }
      class MR extends nt {
        static get pluginName() {
          return 'IndentEditing';
        }
        init() {
          const t = this.editor;
          t.commands.add('indent', new st(t));
          t.commands.add('outdent', new st(t));
        }
      }
      const LR =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
      const VR =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
      class HR extends nt {
        static get pluginName() {
          return 'IndentUI';
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.t;
          const i = e.uiLanguageDirection == 'ltr' ? LR : VR;
          const o = e.uiLanguageDirection == 'ltr' ? VR : LR;
          this._defineButton('indent', n('Increase indent'), i);
          this._defineButton('outdent', n('Decrease indent'), o);
        }
        _defineButton(t, e, n) {
          const i = this.editor;
          i.ui.componentFactory.add(t, (o) => {
            const r = i.commands.get(t);
            const s = new iv(o);
            s.set({ label: e, icon: n, tooltip: true });
            s.bind('isOn', 'isEnabled').to(r, 'value', 'isEnabled');
            this.listenTo(s, 'execute', () => {
              i.execute(t);
              i.editing.view.focus();
            });
            return s;
          });
        }
      }
      class jR extends nt {
        static get pluginName() {
          return 'Indent';
        }
        static get requires() {
          return [MR, HR];
        }
      }
      class qR extends ot {
        constructor(t, e) {
          super(t);
          this._indentBehavior = e;
        }
        refresh() {
          const t = this.editor;
          const e = t.model;
          const n = Xf(e.document.selection.getSelectedBlocks());
          if (!n || !e.schema.checkAttribute(n, 'blockIndent')) {
            this.isEnabled = false;
            return;
          }
          this.isEnabled = this._indentBehavior.checkEnabled(
            n.getAttribute('blockIndent')
          );
        }
        execute() {
          const t = this.editor.model;
          const e = WR(t);
          t.change((t) => {
            for (const n of e) {
              const e = n.getAttribute('blockIndent');
              const i = this._indentBehavior.getNextIndent(e);
              if (i) {
                t.setAttribute('blockIndent', i, n);
              } else {
                t.removeAttribute('blockIndent', n);
              }
            }
          });
        }
      }
      function WR(t) {
        const e = t.document.selection;
        const n = t.schema;
        const i = Array.from(e.getSelectedBlocks());
        return i.filter((t) => n.checkAttribute(t, 'blockIndent'));
      }
      class UR {
        constructor(t) {
          this.isForward = t.direction === 'forward';
          this.offset = t.offset;
          this.unit = t.unit;
        }
        checkEnabled(t) {
          const e = parseFloat(t || 0);
          return this.isForward || e > 0;
        }
        getNextIndent(t) {
          const e = parseFloat(t || 0);
          const n = !t || t.endsWith(this.unit);
          if (!n) {
            return this.isForward
              ? this.offset + this.unit
              : undefined;
          }
          const i = this.isForward ? this.offset : -this.offset;
          const o = e + i;
          return o > 0 ? o + this.unit : undefined;
        }
      }
      class GR {
        constructor(t) {
          this.isForward = t.direction === 'forward';
          this.classes = t.classes;
        }
        checkEnabled(t) {
          const e = this.classes.indexOf(t);
          if (this.isForward) {
            return e < this.classes.length - 1;
          } else {
            return e >= 0;
          }
        }
        getNextIndent(t) {
          const e = this.classes.indexOf(t);
          const n = this.isForward ? 1 : -1;
          return this.classes[e + n];
        }
      }
      const $R = [
        'paragraph',
        'heading1',
        'heading2',
        'heading3',
        'heading4',
        'heading5',
        'heading6',
      ];
      class KR extends nt {
        constructor(t) {
          super(t);
          t.config.define('indentBlock', { offset: 40, unit: 'px' });
        }
        static get pluginName() {
          return 'IndentBlock';
        }
        init() {
          const t = this.editor;
          const e = t.config.get('indentBlock');
          const n = !e.classes || !e.classes.length;
          const i = Object.assign({ direction: 'forward' }, e);
          const o = Object.assign({ direction: 'backward' }, e);
          if (n) {
            t.data.addStyleProcessorRules(Gy);
            this._setupConversionUsingOffset(t.conversion);
            t.commands.add('indentBlock', new qR(t, new UR(i)));
            t.commands.add('outdentBlock', new qR(t, new UR(o)));
          } else {
            this._setupConversionUsingClasses(e.classes);
            t.commands.add('indentBlock', new qR(t, new GR(i)));
            t.commands.add('outdentBlock', new qR(t, new GR(o)));
          }
        }
        afterInit() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.commands.get('indent');
          const i = t.commands.get('outdent');
          const o = t.config.get('heading.options');
          const r = o && o.map((t) => t.model);
          const s = r || $R;
          s.forEach((t) => {
            if (e.isRegistered(t)) {
              e.extend(t, { allowAttributes: 'blockIndent' });
            }
          });
          e.setAttributeProperties('blockIndent', {
            isFormatting: true,
          });
          n.registerChildCommand(t.commands.get('indentBlock'));
          i.registerChildCommand(t.commands.get('outdentBlock'));
        }
        _setupConversionUsingOffset() {
          const t = this.editor.conversion;
          const e = this.editor.locale;
          const n =
            e.contentLanguageDirection === 'rtl'
              ? 'margin-right'
              : 'margin-left';
          t.for('upcast').attributeToAttribute({
            view: { styles: { [n]: /[\s\S]+/ } },
            model: {
              key: 'blockIndent',
              value: (t) => t.getStyle(n),
            },
          });
          t.for('downcast').attributeToAttribute({
            model: 'blockIndent',
            view: (t) => ({ key: 'style', value: { [n]: t } }),
          });
        }
        _setupConversionUsingClasses(t) {
          const e = {
            model: { key: 'blockIndent', values: [] },
            view: {},
          };
          for (const n of t) {
            e.model.values.push(n);
            e.view[n] = { key: 'class', value: [n] };
          }
          this.editor.conversion.attributeToAttribute(e);
        }
      }
      const ZR = 'italic';
      class JR extends nt {
        static get pluginName() {
          return 'ItalicEditing';
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', { allowAttributes: ZR });
          t.model.schema.setAttributeProperties(ZR, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: ZR,
            view: 'i',
            upcastAlso: [
              'em',
              { styles: { 'font-style': 'italic' } },
            ],
          });
          t.commands.add(ZR, new zT(t, ZR));
          t.keystrokes.set('CTRL+I', ZR);
        }
      }
      const YR =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
      const QR = 'italic';
      class XR extends nt {
        static get pluginName() {
          return 'ItalicUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(QR, (n) => {
            const i = t.commands.get(QR);
            const o = new iv(n);
            o.set({
              label: e('Italic'),
              icon: YR,
              keystroke: 'CTRL+I',
              tooltip: true,
              isToggleable: true,
            });
            o.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled');
            this.listenTo(o, 'execute', () => {
              t.execute(QR);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class tz extends nt {
        static get requires() {
          return [JR, XR];
        }
        static get pluginName() {
          return 'Italic';
        }
      }
      class ez {
        constructor() {
          this._definitions = new Set();
        }
        get length() {
          return this._definitions.size;
        }
        add(t) {
          if (Array.isArray(t)) {
            t.forEach((t) => this._definitions.add(t));
          } else {
            this._definitions.add(t);
          }
        }
        getDispatcher() {
          return (t) => {
            t.on(
              'attribute:linkHref',
              (t, e, n) => {
                if (
                  !n.consumable.test(e.item, 'attribute:linkHref')
                ) {
                  return;
                }
                if (
                  !(
                    e.item.is('selection') ||
                    n.schema.isInline(e.item)
                  )
                ) {
                  return;
                }
                const i = n.writer;
                const o = i.document.selection;
                for (const t of this._definitions) {
                  const r = i.createAttributeElement(
                    'a',
                    t.attributes,
                    { priority: 5 }
                  );
                  if (t.classes) {
                    i.addClass(t.classes, r);
                  }
                  for (const e in t.styles) {
                    i.setStyle(e, t.styles[e], r);
                  }
                  i.setCustomProperty('link', true, r);
                  if (t.callback(e.attributeNewValue)) {
                    if (e.item.is('selection')) {
                      i.wrap(o.getFirstRange(), r);
                    } else {
                      i.wrap(n.mapper.toViewRange(e.range), r);
                    }
                  } else {
                    i.unwrap(n.mapper.toViewRange(e.range), r);
                  }
                }
              },
              { priority: 'high' }
            );
          };
        }
        getDispatcherForLinkedImage() {
          return (t) => {
            t.on(
              'attribute:linkHref:imageBlock',
              (t, e, { writer: n, mapper: i }) => {
                const o = i.toViewElement(e.item);
                const r = Array.from(o.getChildren()).find(
                  (t) => t.name === 'a'
                );
                for (const t of this._definitions) {
                  const i = Za(t.attributes);
                  if (t.callback(e.attributeNewValue)) {
                    for (const [t, e] of i) {
                      if (t === 'class') {
                        n.addClass(e, r);
                      } else {
                        n.setAttribute(t, e, r);
                      }
                    }
                    if (t.classes) {
                      n.addClass(t.classes, r);
                    }
                    for (const e in t.styles) {
                      n.setStyle(e, t.styles[e], r);
                    }
                  } else {
                    for (const [t, e] of i) {
                      if (t === 'class') {
                        n.removeClass(e, r);
                      } else {
                        n.removeAttribute(t, r);
                      }
                    }
                    if (t.classes) {
                      n.removeClass(t.classes, r);
                    }
                    for (const e in t.styles) {
                      n.removeStyle(e, r);
                    }
                  }
                }
              }
            );
          };
        }
      }
      class nz extends ot {
        constructor(t) {
          super(t);
          this.manualDecorators = new ya();
          this.automaticDecorators = new ez();
        }
        restoreManualDecoratorStates() {
          for (const t of this.manualDecorators) {
            t.value = this._getDecoratorStateFromModel(t.id);
          }
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document.selection;
          const n =
            e.getSelectedElement() || Xf(e.getSelectedBlocks());
          if (CT(n, t.schema)) {
            this.value = n.getAttribute('linkHref');
            this.isEnabled = t.schema.checkAttribute(n, 'linkHref');
          } else {
            this.value = e.getAttribute('linkHref');
            this.isEnabled = t.schema.checkAttributeInSelection(
              e,
              'linkHref'
            );
          }
          for (const t of this.manualDecorators) {
            t.value = this._getDecoratorStateFromModel(t.id);
          }
        }
        execute(t, e = {}) {
          const n = this.editor.model;
          const i = n.document.selection;
          const o = [];
          const r = [];
          for (const t in e) {
            if (e[t]) {
              o.push(t);
            } else {
              r.push(t);
            }
          }
          n.change((e) => {
            if (i.isCollapsed) {
              const s = i.getFirstPosition();
              if (i.hasAttribute('linkHref')) {
                const a = WD(
                  s,
                  'linkHref',
                  i.getAttribute('linkHref'),
                  n
                );
                e.setAttribute('linkHref', t, a);
                o.forEach((t) => {
                  e.setAttribute(t, true, a);
                });
                r.forEach((t) => {
                  e.removeAttribute(t, a);
                });
                e.setSelection(
                  e.createPositionAfter(a.end.nodeBefore)
                );
              } else if (t !== '') {
                const r = Za(i.getAttributes());
                r.set('linkHref', t);
                o.forEach((t) => {
                  r.set(t, true);
                });
                const { end: a } = n.insertContent(
                  e.createText(t, r),
                  s
                );
                e.setSelection(a);
              }
              ['linkHref', ...o, ...r].forEach((t) => {
                e.removeSelectionAttribute(t);
              });
            } else {
              const s = n.schema.getValidRanges(
                i.getRanges(),
                'linkHref'
              );
              const a = [];
              for (const t of i.getSelectedBlocks()) {
                if (n.schema.checkAttribute(t, 'linkHref')) {
                  a.push(e.createRangeOn(t));
                }
              }
              const c = a.slice();
              for (const t of s) {
                if (this._isRangeToUpdate(t, a)) {
                  c.push(t);
                }
              }
              for (const n of c) {
                e.setAttribute('linkHref', t, n);
                o.forEach((t) => {
                  e.setAttribute(t, true, n);
                });
                r.forEach((t) => {
                  e.removeAttribute(t, n);
                });
              }
            }
          });
        }
        _getDecoratorStateFromModel(t) {
          const e = this.editor.model;
          const n = e.document.selection;
          const i = n.getSelectedElement();
          if (CT(i, e.schema)) {
            return i.getAttribute(t);
          }
          return n.getAttribute(t);
        }
        _isRangeToUpdate(t, e) {
          for (const n of e) {
            if (n.containsRange(t)) {
              return false;
            }
          }
          return true;
        }
      }
      class iz extends ot {
        refresh() {
          const t = this.editor.model;
          const e = t.document.selection;
          const n = e.getSelectedElement();
          if (CT(n, t.schema)) {
            this.isEnabled = t.schema.checkAttribute(n, 'linkHref');
          } else {
            this.isEnabled = t.schema.checkAttributeInSelection(
              e,
              'linkHref'
            );
          }
        }
        execute() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          const i = t.commands.get('link');
          e.change((t) => {
            const o = n.isCollapsed
              ? [
                  WD(
                    n.getFirstPosition(),
                    'linkHref',
                    n.getAttribute('linkHref'),
                    e
                  ),
                ]
              : e.schema.getValidRanges(n.getRanges(), 'linkHref');
            for (const e of o) {
              t.removeAttribute('linkHref', e);
              if (i) {
                for (const n of i.manualDecorators) {
                  t.removeAttribute(n.id, e);
                }
              }
            }
          });
        }
      }
      class oz {
        constructor({
          id: t,
          label: e,
          attributes: n,
          classes: i,
          styles: o,
          defaultValue: r,
        }) {
          this.id = t;
          this.set('value');
          this.defaultValue = r;
          this.label = e;
          this.attributes = n;
          this.classes = i;
          this.styles = o;
        }
        _createPattern() {
          return {
            attributes: this.attributes,
            classes: this.classes,
            styles: this.styles,
          };
        }
      }
      et(oz, q);
      var rz = n(399);
      var sz = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      sz.insert = 'head';
      sz.singleton = true;
      var az = Lh()(rz.Z, sz);
      const cz = rz.Z.locals || {};
      const lz = 'ck-link_selected';
      const dz = 'automatic';
      const hz = 'manual';
      const uz = /^(https?:)?\/\//;
      class fz extends nt {
        static get pluginName() {
          return 'LinkEditing';
        }
        static get requires() {
          return [SD, yD, Ex];
        }
        constructor(t) {
          super(t);
          t.config.define('link', {
            addTargetToExternalLinks: false,
          });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', {
            allowAttributes: 'linkHref',
          });
          t.conversion
            .for('dataDowncast')
            .attributeToElement({ model: 'linkHref', view: bT });
          t.conversion
            .for('editingDowncast')
            .attributeToElement({
              model: 'linkHref',
              view: (t, e) => bT(wT(t), e),
            });
          t.conversion
            .for('upcast')
            .elementToAttribute({
              view: { name: 'a', attributes: { href: true } },
              model: {
                key: 'linkHref',
                value: (t) => t.getAttribute('href'),
              },
            });
          t.commands.add('link', new nz(t));
          t.commands.add('unlink', new iz(t));
          const e = vT(t.t, AT(t.config.get('link.decorators')));
          this._enableAutomaticDecorators(
            e.filter((t) => t.mode === dz)
          );
          this._enableManualDecorators(
            e.filter((t) => t.mode === hz)
          );
          const n = t.plugins.get(SD);
          n.registerAttribute('linkHref');
          GD(t, 'linkHref', 'a', lz);
          this._enableLinkOpen();
          this._enableInsertContentSelectionAttributesFixer();
          this._enableClickingAfterLink();
          this._enableTypingOverLink();
          this._handleDeleteContentAfterLink();
        }
        _enableAutomaticDecorators(t) {
          const e = this.editor;
          const n = e.commands.get('link');
          const i = n.automaticDecorators;
          if (e.config.get('link.addTargetToExternalLinks')) {
            i.add({
              id: 'linkIsExternal',
              mode: dz,
              callback: (t) => uz.test(t),
              attributes: {
                target: '_blank',
                rel: 'noopener noreferrer',
              },
            });
          }
          i.add(t);
          if (i.length) {
            e.conversion.for('downcast').add(i.getDispatcher());
          }
        }
        _enableManualDecorators(t) {
          if (!t.length) {
            return;
          }
          const e = this.editor;
          const n = e.commands.get('link');
          const i = n.manualDecorators;
          t.forEach((t) => {
            e.model.schema.extend('$text', { allowAttributes: t.id });
            t = new oz(t);
            i.add(t);
            e.conversion.for('downcast').attributeToElement({
              model: t.id,
              view: (e, { writer: n, schema: i }, { item: o }) => {
                if (!(o.is('selection') || i.isInline(o))) {
                  return;
                }
                if (e) {
                  const e = n.createAttributeElement(
                    'a',
                    t.attributes,
                    { priority: 5 }
                  );
                  if (t.classes) {
                    n.addClass(t.classes, e);
                  }
                  for (const i in t.styles) {
                    n.setStyle(i, t.styles[i], e);
                  }
                  n.setCustomProperty('link', true, e);
                  return e;
                }
              },
            });
            e.conversion
              .for('upcast')
              .elementToAttribute({
                view: { name: 'a', ...t._createPattern() },
                model: { key: t.id },
              });
          });
        }
        _enableLinkOpen() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const i = t.model.document;
          this.listenTo(
            n,
            'click',
            (t, e) => {
              const n = Sd.isMac
                ? e.domEvent.metaKey
                : e.domEvent.ctrlKey;
              if (!n) {
                return;
              }
              let i = e.domTarget;
              if (i.tagName.toLowerCase() != 'a') {
                i = i.closest('a');
              }
              if (!i) {
                return;
              }
              const o = i.getAttribute('href');
              if (!o) {
                return;
              }
              t.stop();
              e.preventDefault();
              ET(o);
            },
            { context: '$capture' }
          );
          this.listenTo(
            n,
            'enter',
            (t, e) => {
              const n = i.selection;
              const o = n.getSelectedElement();
              const r = o
                ? o.getAttribute('linkHref')
                : n.getAttribute('linkHref');
              const s = r && e.domEvent.altKey;
              if (!s) {
                return;
              }
              t.stop();
              ET(r);
            },
            { context: 'a' }
          );
        }
        _enableInsertContentSelectionAttributesFixer() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          this.listenTo(
            e,
            'insertContent',
            () => {
              const t = n.anchor.nodeBefore;
              const i = n.anchor.nodeAfter;
              if (!n.hasAttribute('linkHref')) {
                return;
              }
              if (!t) {
                return;
              }
              if (!t.hasAttribute('linkHref')) {
                return;
              }
              if (i && i.hasAttribute('linkHref')) {
                return;
              }
              e.change((t) => {
                gz(t, kz(e.schema));
              });
            },
            { priority: 'low' }
          );
        }
        _enableClickingAfterLink() {
          const t = this.editor;
          const e = t.model;
          t.editing.view.addObserver(ny);
          let n = false;
          this.listenTo(t.editing.view.document, 'mousedown', () => {
            n = true;
          });
          this.listenTo(
            t.editing.view.document,
            'selectionChange',
            () => {
              if (!n) {
                return;
              }
              n = false;
              const t = e.document.selection;
              if (!t.isCollapsed) {
                return;
              }
              if (!t.hasAttribute('linkHref')) {
                return;
              }
              const i = t.getFirstPosition();
              const o = WD(
                i,
                'linkHref',
                t.getAttribute('linkHref'),
                e
              );
              if (i.isTouching(o.start) || i.isTouching(o.end)) {
                e.change((t) => {
                  gz(t, kz(e.schema));
                });
              }
            }
          );
        }
        _enableTypingOverLink() {
          const t = this.editor;
          const e = t.editing.view;
          let n;
          let i;
          this.listenTo(
            e.document,
            'delete',
            () => {
              i = true;
            },
            { priority: 'high' }
          );
          this.listenTo(
            t.model,
            'deleteContent',
            () => {
              const e = t.model.document.selection;
              if (e.isCollapsed) {
                return;
              }
              if (i) {
                i = false;
                return;
              }
              if (!pz(t)) {
                return;
              }
              if (mz(t.model)) {
                n = e.getAttributes();
              }
            },
            { priority: 'high' }
          );
          this.listenTo(
            t.model,
            'insertContent',
            (e, [o]) => {
              i = false;
              if (!pz(t)) {
                return;
              }
              if (!n) {
                return;
              }
              t.model.change((t) => {
                for (const [e, i] of n) {
                  t.setAttribute(e, i, o);
                }
              });
              n = null;
            },
            { priority: 'high' }
          );
        }
        _handleDeleteContentAfterLink() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const i = t.editing.view;
          let o = false;
          let r = false;
          this.listenTo(
            i.document,
            'delete',
            (t, e) => {
              r = e.domEvent.keyCode === Ld.backspace;
            },
            { priority: 'high' }
          );
          this.listenTo(
            e,
            'deleteContent',
            () => {
              o = false;
              const t = n.getFirstPosition();
              const i = n.getAttribute('linkHref');
              if (!i) {
                return;
              }
              const r = WD(t, 'linkHref', i, e);
              o = r.containsPosition(t) || r.end.isEqual(t);
            },
            { priority: 'high' }
          );
          this.listenTo(
            e,
            'deleteContent',
            () => {
              if (!r) {
                return;
              }
              r = false;
              if (o) {
                return;
              }
              t.model.enqueueChange((t) => {
                gz(t, kz(e.schema));
              });
            },
            { priority: 'low' }
          );
        }
      }
      function gz(t, e) {
        t.removeSelectionAttribute('linkHref');
        for (const n of e) {
          t.removeSelectionAttribute(n);
        }
      }
      function mz(t) {
        const e = t.document.selection;
        const n = e.getFirstPosition();
        const i = e.getLastPosition();
        const o = n.nodeAfter;
        if (!o) {
          return false;
        }
        if (!o.is('$text')) {
          return false;
        }
        if (!o.hasAttribute('linkHref')) {
          return false;
        }
        const r = i.textNode || i.nodeBefore;
        if (o === r) {
          return true;
        }
        const s = WD(n, 'linkHref', o.getAttribute('linkHref'), t);
        return s.containsRange(t.createRange(n, i), true);
      }
      function pz(t) {
        const e = t.model.change((t) => t.batch);
        return e.isTyping;
      }
      function kz(t) {
        const e = t.getDefinition('$text').allowAttributes;
        return e.filter((t) => t.startsWith('link'));
      }
      var bz = n(4827);
      var wz = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      wz.insert = 'head';
      wz.singleton = true;
      var _z = Lh()(bz.Z, wz);
      const vz = bz.Z.locals || {};
      class Az extends Dw {
        constructor(t, e) {
          super(t);
          const n = t.t;
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this.urlInputView = this._createUrlInput();
          this.saveButtonView = this._createButton(
            n('Save'),
            M_.check,
            'ck-button-save'
          );
          this.saveButtonView.type = 'submit';
          this.cancelButtonView = this._createButton(
            n('Cancel'),
            M_.cancel,
            'ck-button-cancel',
            'cancel'
          );
          this._manualDecoratorSwitches =
            this._createManualDecoratorSwitches(e);
          this.children = this._createFormChildren(
            e.manualDecorators
          );
          this._focusables = new Kb();
          this._focusCycler = new Iv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: 'shift + tab',
              focusNext: 'tab',
            },
          });
          const i = ['ck', 'ck-link-form', 'ck-responsive-form'];
          if (e.manualDecorators.length) {
            i.push(
              'ck-link-form_layout-vertical',
              'ck-vertical-form'
            );
          }
          this.setTemplate({
            tag: 'form',
            attributes: { class: i, tabindex: '-1' },
            children: this.children,
          });
          V_(this);
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce(
            (t, e) => {
              t[e.name] = e.isOn;
              return t;
            },
            {}
          );
        }
        render() {
          super.render();
          H_({ view: this });
          const t = [
            this.urlInputView,
            ...this._manualDecoratorSwitches,
            this.saveButtonView,
            this.cancelButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createUrlInput() {
          const t = this.locale.t;
          const e = new GA(this.locale, $A);
          e.label = t('Link URL');
          return e;
        }
        _createButton(t, e, n, i) {
          const o = new iv(this.locale);
          o.set({ label: t, icon: e, tooltip: true });
          o.extendTemplate({ attributes: { class: n } });
          if (i) {
            o.delegate('execute').to(this, i);
          }
          return o;
        }
        _createManualDecoratorSwitches(t) {
          const e = this.createCollection();
          for (const n of t.manualDecorators) {
            const i = new cv(this.locale);
            i.set({ name: n.id, label: n.label, withText: true });
            i.bind('isOn').toMany([n, t], 'value', (t, e) =>
              e === undefined && t === undefined ? n.defaultValue : t
            );
            i.on('execute', () => {
              n.set('value', !i.isOn);
            });
            e.add(i);
          }
          return e;
        }
        _createFormChildren(t) {
          const e = this.createCollection();
          e.add(this.urlInputView);
          if (t.length) {
            const t = new Dw();
            t.setTemplate({
              tag: 'ul',
              children: this._manualDecoratorSwitches.map((t) => ({
                tag: 'li',
                children: [t],
                attributes: { class: ['ck', 'ck-list__item'] },
              })),
              attributes: { class: ['ck', 'ck-reset', 'ck-list'] },
            });
            e.add(t);
          }
          e.add(this.saveButtonView);
          e.add(this.cancelButtonView);
          return e;
        }
      }
      var Cz = n(9465);
      var yz = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      yz.insert = 'head';
      yz.singleton = true;
      var xz = Lh()(Cz.Z, yz);
      const Ez = Cz.Z.locals || {};
      const Dz =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
      class Sz extends Dw {
        constructor(t) {
          super(t);
          const e = t.t;
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this.previewButtonView = this._createPreviewButton();
          this.unlinkButtonView = this._createButton(
            e('Unlink'),
            Dz,
            'unlink'
          );
          this.editButtonView = this._createButton(
            e('Edit link'),
            M_.pencil,
            'edit'
          );
          this.set('href');
          this._focusables = new Kb();
          this._focusCycler = new Iv({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: 'shift + tab',
              focusNext: 'tab',
            },
          });
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-link-actions', 'ck-responsive-form'],
              tabindex: '-1',
            },
            children: [
              this.previewButtonView,
              this.editButtonView,
              this.unlinkButtonView,
            ],
          });
        }
        render() {
          super.render();
          const t = [
            this.previewButtonView,
            this.editButtonView,
            this.unlinkButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createButton(t, e, n) {
          const i = new iv(this.locale);
          i.set({ label: t, icon: e, tooltip: true });
          i.delegate('execute').to(this, n);
          return i;
        }
        _createPreviewButton() {
          const t = new iv(this.locale);
          const e = this.bindTemplate;
          const n = this.t;
          t.set({
            withText: true,
            tooltip: n('Open link in new tab'),
          });
          t.extendTemplate({
            attributes: {
              class: ['ck', 'ck-link-actions__preview'],
              href: e.to('href', (t) => t && wT(t)),
              target: '_blank',
              rel: 'noopener noreferrer',
            },
          });
          t.bind('label').to(
            this,
            'href',
            (t) => t || n('This link has no URL')
          );
          t.bind('isEnabled').to(this, 'href', (t) => !!t);
          t.template.tag = 'a';
          t.template.eventListeners = {};
          return t;
        }
      }
      const Tz =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
      const Bz = 'link-ui';
      class Pz extends nt {
        static get requires() {
          return [lC];
        }
        static get pluginName() {
          return 'LinkUI';
        }
        init() {
          const t = this.editor;
          t.editing.view.addObserver(ey);
          this.actionsView = this._createActionsView();
          this.formView = this._createFormView();
          this._balloon = t.plugins.get(lC);
          this._createToolbarLinkButton();
          this._enableUserBalloonInteractions();
          t.conversion
            .for('editingDowncast')
            .markerToHighlight({
              model: Bz,
              view: { classes: ['ck-fake-link-selection'] },
            });
          t.conversion
            .for('editingDowncast')
            .markerToElement({
              model: Bz,
              view: {
                name: 'span',
                classes: [
                  'ck-fake-link-selection',
                  'ck-fake-link-selection_collapsed',
                ],
              },
            });
        }
        destroy() {
          super.destroy();
          this.formView.destroy();
        }
        _createActionsView() {
          const t = this.editor;
          const e = new Sz(t.locale);
          const n = t.commands.get('link');
          const i = t.commands.get('unlink');
          e.bind('href').to(n, 'value');
          e.editButtonView.bind('isEnabled').to(n);
          e.unlinkButtonView.bind('isEnabled').to(i);
          this.listenTo(e, 'edit', () => {
            this._addFormView();
          });
          this.listenTo(e, 'unlink', () => {
            t.execute('unlink');
            this._hideUI();
          });
          e.keystrokes.set('Esc', (t, e) => {
            this._hideUI();
            e();
          });
          e.keystrokes.set(pT, (t, e) => {
            this._addFormView();
            e();
          });
          return e;
        }
        _createFormView() {
          const t = this.editor;
          const e = t.commands.get('link');
          const n = t.config.get('link.defaultProtocol');
          const i = new Az(t.locale, e);
          i.urlInputView.fieldView.bind('value').to(e, 'value');
          i.urlInputView
            .bind('isReadOnly')
            .to(e, 'isEnabled', (t) => !t);
          i.saveButtonView.bind('isEnabled').to(e);
          this.listenTo(i, 'submit', () => {
            const { value: e } = i.urlInputView.fieldView.element;
            const o = xT(e, n);
            t.execute('link', o, i.getDecoratorSwitchesState());
            this._closeFormView();
          });
          this.listenTo(i, 'cancel', () => {
            this._closeFormView();
          });
          i.keystrokes.set('Esc', (t, e) => {
            this._closeFormView();
            e();
          });
          return i;
        }
        _createToolbarLinkButton() {
          const t = this.editor;
          const e = t.commands.get('link');
          const n = t.t;
          t.keystrokes.set(pT, (t, n) => {
            n();
            if (e.isEnabled) {
              this._showUI(true);
            }
          });
          t.ui.componentFactory.add('link', (t) => {
            const i = new iv(t);
            i.isEnabled = true;
            i.label = n('Link');
            i.icon = Tz;
            i.keystroke = pT;
            i.tooltip = true;
            i.isToggleable = true;
            i.bind('isEnabled').to(e, 'isEnabled');
            i.bind('isOn').to(e, 'value', (t) => !!t);
            this.listenTo(i, 'execute', () => this._showUI(true));
            return i;
          });
        }
        _enableUserBalloonInteractions() {
          const t = this.editor.editing.view.document;
          this.listenTo(t, 'click', () => {
            const t = this._getSelectedLinkElement();
            if (t) {
              this._showUI();
            }
          });
          this.editor.keystrokes.set(
            'Tab',
            (t, e) => {
              if (
                this._areActionsVisible &&
                !this.actionsView.focusTracker.isFocused
              ) {
                this.actionsView.focus();
                e();
              }
            },
            { priority: 'high' }
          );
          this.editor.keystrokes.set('Esc', (t, e) => {
            if (this._isUIVisible) {
              this._hideUI();
              e();
            }
          });
          L_({
            emitter: this.formView,
            activator: () => this._isUIInPanel,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideUI(),
          });
        }
        _addActionsView() {
          if (this._areActionsInPanel) {
            return;
          }
          this._balloon.add({
            view: this.actionsView,
            position: this._getBalloonPositionData(),
          });
        }
        _addFormView() {
          if (this._isFormInPanel) {
            return;
          }
          const t = this.editor;
          const e = t.commands.get('link');
          this.formView.disableCssTransitions();
          this._balloon.add({
            view: this.formView,
            position: this._getBalloonPositionData(),
          });
          if (this._balloon.visibleView === this.formView) {
            this.formView.urlInputView.fieldView.select();
          }
          this.formView.enableCssTransitions();
          this.formView.urlInputView.fieldView.element.value =
            e.value || '';
        }
        _closeFormView() {
          const t = this.editor.commands.get('link');
          t.restoreManualDecoratorStates();
          if (t.value !== undefined) {
            this._removeFormView();
          } else {
            this._hideUI();
          }
        }
        _removeFormView() {
          if (this._isFormInPanel) {
            this.formView.saveButtonView.focus();
            this._balloon.remove(this.formView);
            this.editor.editing.view.focus();
            this._hideFakeVisualSelection();
          }
        }
        _showUI(t = false) {
          if (!this._getSelectedLinkElement()) {
            this._showFakeVisualSelection();
            this._addActionsView();
            if (t) {
              this._balloon.showStack('main');
            }
            this._addFormView();
          } else {
            if (this._areActionsVisible) {
              this._addFormView();
            } else {
              this._addActionsView();
            }
            if (t) {
              this._balloon.showStack('main');
            }
          }
          this._startUpdatingUI();
        }
        _hideUI() {
          if (!this._isUIInPanel) {
            return;
          }
          const t = this.editor;
          this.stopListening(t.ui, 'update');
          this.stopListening(this._balloon, 'change:visibleView');
          t.editing.view.focus();
          this._removeFormView();
          this._balloon.remove(this.actionsView);
          this._hideFakeVisualSelection();
        }
        _startUpdatingUI() {
          const t = this.editor;
          const e = t.editing.view.document;
          let n = this._getSelectedLinkElement();
          let i = r();
          const o = () => {
            const t = this._getSelectedLinkElement();
            const e = r();
            if ((n && !t) || (!n && e !== i)) {
              this._hideUI();
            } else if (this._isUIVisible) {
              this._balloon.updatePosition(
                this._getBalloonPositionData()
              );
            }
            n = t;
            i = e;
          };
          function r() {
            return e.selection.focus
              .getAncestors()
              .reverse()
              .find((t) => t.is('element'));
          }
          this.listenTo(t.ui, 'update', o);
          this.listenTo(this._balloon, 'change:visibleView', o);
        }
        get _isFormInPanel() {
          return this._balloon.hasView(this.formView);
        }
        get _areActionsInPanel() {
          return this._balloon.hasView(this.actionsView);
        }
        get _areActionsVisible() {
          return this._balloon.visibleView === this.actionsView;
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel;
        }
        get _isUIVisible() {
          const t = this._balloon.visibleView;
          return t == this.formView || this._areActionsVisible;
        }
        _getBalloonPositionData() {
          const t = this.editor.editing.view;
          const e = this.editor.model;
          const n = t.document;
          let i = null;
          if (e.markers.has(Bz)) {
            const e = Array.from(
              this.editor.editing.mapper.markerNameToElements(Bz)
            );
            const n = t.createRange(
              t.createPositionBefore(e[0]),
              t.createPositionAfter(e[e.length - 1])
            );
            i = t.domConverter.viewRangeToDom(n);
          } else {
            i = () => {
              const e = this._getSelectedLinkElement();
              return e
                ? t.domConverter.mapViewToDom(e)
                : t.domConverter.viewRangeToDom(
                    n.selection.getFirstRange()
                  );
            };
          }
          return { target: i };
        }
        _getSelectedLinkElement() {
          const t = this.editor.editing.view;
          const e = t.document.selection;
          const n = e.getSelectedElement();
          if (e.isCollapsed || (n && Zx(n))) {
            return Iz(e.getFirstPosition());
          } else {
            const n = e.getFirstRange().getTrimmed();
            const i = Iz(n.start);
            const o = Iz(n.end);
            if (!i || i != o) {
              return null;
            }
            if (t.createRangeIn(i).getTrimmed().isEqual(n)) {
              return i;
            } else {
              return null;
            }
          }
        }
        _showFakeVisualSelection() {
          const t = this.editor.model;
          t.change((e) => {
            const n = t.document.selection.getFirstRange();
            if (t.markers.has(Bz)) {
              e.updateMarker(Bz, { range: n });
            } else {
              if (n.start.isAtEnd) {
                const i = n.start.getLastMatchingPosition(
                  ({ item: e }) => !t.schema.isContent(e),
                  { boundaries: n }
                );
                e.addMarker(Bz, {
                  usingOperation: false,
                  affectsData: false,
                  range: e.createRange(i, n.end),
                });
              } else {
                e.addMarker(Bz, {
                  usingOperation: false,
                  affectsData: false,
                  range: n,
                });
              }
            }
          });
        }
        _hideFakeVisualSelection() {
          const t = this.editor.model;
          if (t.markers.has(Bz)) {
            t.change((t) => {
              t.removeMarker(Bz);
            });
          }
        }
      }
      function Iz(t) {
        return t.getAncestors().find((t) => kT(t));
      }
      class Rz extends nt {
        static get requires() {
          return [fz, Pz, BT];
        }
        static get pluginName() {
          return 'Link';
        }
      }
      class zz extends ot {
        constructor(t, e) {
          super(t);
          this.type = e;
        }
        refresh() {
          this.value = this._getValue();
          this.isEnabled = this._checkEnabled();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const i = Array.from(
            n.selection.getSelectedBlocks()
          ).filter((t) => Fz(t, e.schema));
          const o =
            t.forceValue !== undefined ? !t.forceValue : this.value;
          e.change((t) => {
            if (o) {
              let e = i[i.length - 1].nextSibling;
              let n = Number.POSITIVE_INFINITY;
              let o = [];
              while (
                e &&
                e.name == 'listItem' &&
                e.getAttribute('listIndent') !== 0
              ) {
                const t = e.getAttribute('listIndent');
                if (t < n) {
                  n = t;
                }
                const i = t - n;
                o.push({ element: e, listIndent: i });
                e = e.nextSibling;
              }
              o = o.reverse();
              for (const e of o) {
                t.setAttribute('listIndent', e.listIndent, e.element);
              }
            }
            if (!o) {
              let t = Number.POSITIVE_INFINITY;
              for (const e of i) {
                if (
                  e.is('element', 'listItem') &&
                  e.getAttribute('listIndent') < t
                ) {
                  t = e.getAttribute('listIndent');
                }
              }
              t = t === 0 ? 1 : t;
              Oz(i, true, t);
              Oz(i, false, t);
            }
            for (const e of i.reverse()) {
              if (o && e.name == 'listItem') {
                t.rename(e, 'paragraph');
              } else if (!o && e.name != 'listItem') {
                t.setAttributes(
                  { listType: this.type, listIndent: 0 },
                  e
                );
                t.rename(e, 'listItem');
              } else if (
                !o &&
                e.name == 'listItem' &&
                e.getAttribute('listType') != this.type
              ) {
                t.setAttribute('listType', this.type, e);
              }
            }
            this.fire('_executeCleanup', i);
          });
        }
        _getValue() {
          const t = Xf(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          return (
            !!t &&
            t.is('element', 'listItem') &&
            t.getAttribute('listType') == this.type
          );
        }
        _checkEnabled() {
          if (this.value) {
            return true;
          }
          const t = this.editor.model.document.selection;
          const e = this.editor.model.schema;
          const n = Xf(t.getSelectedBlocks());
          if (!n) {
            return false;
          }
          return Fz(n, e);
        }
      }
      function Oz(t, e, n) {
        const i = e ? t[0] : t[t.length - 1];
        if (i.is('element', 'listItem')) {
          let o = i[e ? 'previousSibling' : 'nextSibling'];
          let r = i.getAttribute('listIndent');
          while (
            o &&
            o.is('element', 'listItem') &&
            o.getAttribute('listIndent') >= n
          ) {
            if (r > o.getAttribute('listIndent')) {
              r = o.getAttribute('listIndent');
            }
            if (o.getAttribute('listIndent') == r) {
              t[e ? 'unshift' : 'push'](o);
            }
            o = o[e ? 'previousSibling' : 'nextSibling'];
          }
        }
      }
      function Fz(t, e) {
        return e.checkChild(t.parent, 'listItem') && !e.isObject(t);
      }
      class Nz extends ot {
        constructor(t, e) {
          super(t);
          this._indentBy = e == 'forward' ? 1 : -1;
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const t = this.editor.model;
          const e = t.document;
          let n = Array.from(e.selection.getSelectedBlocks());
          t.change((t) => {
            const e = n[n.length - 1];
            let i = e.nextSibling;
            while (
              i &&
              i.name == 'listItem' &&
              i.getAttribute('listIndent') >
                e.getAttribute('listIndent')
            ) {
              n.push(i);
              i = i.nextSibling;
            }
            if (this._indentBy < 0) {
              n = n.reverse();
            }
            for (const e of n) {
              const n = e.getAttribute('listIndent') + this._indentBy;
              if (n < 0) {
                t.rename(e, 'paragraph');
              } else {
                t.setAttribute('listIndent', n, e);
              }
            }
            this.fire('_executeCleanup', n);
          });
        }
        _checkEnabled() {
          const t = Xf(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          if (!t || !t.is('element', 'listItem')) {
            return false;
          }
          if (this._indentBy > 0) {
            const e = t.getAttribute('listIndent');
            const n = t.getAttribute('listType');
            let i = t.previousSibling;
            while (
              i &&
              i.is('element', 'listItem') &&
              i.getAttribute('listIndent') >= e
            ) {
              if (i.getAttribute('listIndent') == e) {
                return i.getAttribute('listType') == n;
              }
              i = i.previousSibling;
            }
            return false;
          }
          return true;
        }
      }
      function Mz(t) {
        const e = t.createContainerElement('li');
        e.getFillerOffset = Yz;
        return e;
      }
      function Lz(t, e) {
        const n = e.mapper;
        const i = e.writer;
        const o =
          t.getAttribute('listType') == 'numbered' ? 'ol' : 'ul';
        const r = Mz(i);
        const s = i.createContainerElement(o, null);
        i.insert(i.createPositionAt(s, 0), r);
        n.bindElements(t, r);
        return r;
      }
      function Vz(t, e, n, i) {
        const o = e.parent;
        const r = n.mapper;
        const s = n.writer;
        let a = r.toViewPosition(i.createPositionBefore(t));
        const c = qz(t.previousSibling, {
          sameIndent: true,
          smallerIndent: true,
          listIndent: t.getAttribute('listIndent'),
        });
        const l = t.previousSibling;
        if (
          c &&
          c.getAttribute('listIndent') == t.getAttribute('listIndent')
        ) {
          const t = r.toViewElement(c);
          a = s.breakContainer(s.createPositionAfter(t));
        } else {
          if (l && l.name == 'listItem') {
            a = r.toViewPosition(i.createPositionAt(l, 'end'));
            const t = r.findMappedViewAncestor(a);
            const e = Uz(t);
            if (e) {
              a = s.createPositionBefore(e);
            } else {
              a = s.createPositionAt(t, 'end');
            }
          } else {
            a = r.toViewPosition(i.createPositionBefore(t));
          }
        }
        a = jz(a);
        s.insert(a, o);
        if (l && l.name == 'listItem') {
          const t = r.toViewElement(l);
          const n = s.createRange(s.createPositionAt(t, 0), a);
          const i = n.getWalker({ ignoreElementEnd: true });
          for (const t of i) {
            if (t.item.is('element', 'li')) {
              const n = s.breakContainer(
                s.createPositionBefore(t.item)
              );
              const o = t.item.parent;
              const r = s.createPositionAt(e, 'end');
              Hz(s, r.nodeBefore, r.nodeAfter);
              s.move(s.createRangeOn(o), r);
              i.position = n;
            }
          }
        } else {
          const n = o.nextSibling;
          if (n && (n.is('element', 'ul') || n.is('element', 'ol'))) {
            let i = null;
            for (const e of n.getChildren()) {
              const n = r.toModelElement(e);
              if (
                n &&
                n.getAttribute('listIndent') >
                  t.getAttribute('listIndent')
              ) {
                i = e;
              } else {
                break;
              }
            }
            if (i) {
              s.breakContainer(s.createPositionAfter(i));
              s.move(
                s.createRangeOn(i.parent),
                s.createPositionAt(e, 'end')
              );
            }
          }
        }
        Hz(s, o, o.nextSibling);
        Hz(s, o.previousSibling, o);
      }
      function Hz(t, e, n) {
        if (!e || !n || (e.name != 'ul' && e.name != 'ol')) {
          return null;
        }
        if (
          e.name != n.name ||
          e.getAttribute('class') !== n.getAttribute('class')
        ) {
          return null;
        }
        return t.mergeContainers(t.createPositionAfter(e));
      }
      function jz(t) {
        return t.getLastMatchingPosition((t) =>
          t.item.is('uiElement')
        );
      }
      function qz(t, e) {
        const n = !!e.sameIndent;
        const i = !!e.smallerIndent;
        const o = e.listIndent;
        let r = t;
        while (r && r.name == 'listItem') {
          const t = r.getAttribute('listIndent');
          if ((n && o == t) || (i && o > t)) {
            return r;
          }
          if (e.direction === 'forward') {
            r = r.nextSibling;
          } else {
            r = r.previousSibling;
          }
        }
        return null;
      }
      function Wz(t, e, n, i) {
        t.ui.componentFactory.add(e, (o) => {
          const r = t.commands.get(e);
          const s = new iv(o);
          s.set({
            label: n,
            icon: i,
            tooltip: true,
            isToggleable: true,
          });
          s.bind('isOn', 'isEnabled').to(r, 'value', 'isEnabled');
          s.on('execute', () => {
            t.execute(e);
            t.editing.view.focus();
          });
          return s;
        });
      }
      function Uz(t) {
        for (const e of t.getChildren()) {
          if (e.name == 'ul' || e.name == 'ol') {
            return e;
          }
        }
        return null;
      }
      function Gz(t, e) {
        const n = [];
        const i = t.parent;
        const o = {
          ignoreElementEnd: true,
          startPosition: t,
          shallow: true,
          direction: e,
        };
        const r = i.getAttribute('listIndent');
        const s = [...new TreeWalker(o)]
          .filter((t) => t.item.is('element'))
          .map((t) => t.item);
        for (const t of s) {
          if (!t.is('element', 'listItem')) {
            break;
          }
          if (t.getAttribute('listIndent') < r) {
            break;
          }
          if (t.getAttribute('listIndent') > r) {
            continue;
          }
          if (
            t.getAttribute('listType') !== i.getAttribute('listType')
          ) {
            break;
          }
          if (
            t.getAttribute('listStyle') !==
            i.getAttribute('listStyle')
          ) {
            break;
          }
          if (
            t.getAttribute('listReversed') !==
            i.getAttribute('listReversed')
          ) {
            break;
          }
          if (
            t.getAttribute('listStart') !==
            i.getAttribute('listStart')
          ) {
            break;
          }
          if (e === 'backward') {
            n.unshift(t);
          } else {
            n.push(t);
          }
        }
        return n;
      }
      function $z(t) {
        const e = t.document;
        let n = [...e.selection.getSelectedBlocks()]
          .filter((t) => t.is('element', 'listItem'))
          .map((e) => {
            const n = t.change((t) => t.createPositionAt(e, 0));
            return [...Gz(n, 'backward'), ...Gz(n, 'forward')];
          })
          .flat();
        n = [...new Set(n)];
        return n;
      }
      const Kz = null && ['disc', 'circle', 'square'];
      const Zz = null && [
        'decimal',
        'decimal-leading-zero',
        'lower-roman',
        'upper-roman',
        'lower-latin',
        'upper-latin',
      ];
      function Jz(t) {
        if (Kz.includes(t)) {
          return 'bulleted';
        }
        if (Zz.includes(t)) {
          return 'numbered';
        }
        return null;
      }
      function Yz() {
        const t =
          !this.isEmpty &&
          (this.getChild(0).name == 'ul' ||
            this.getChild(0).name == 'ol');
        if (this.isEmpty || t) {
          return 0;
        }
        return Xl.call(this);
      }
      function Qz(t) {
        return (e, n, i) => {
          const o = i.consumable;
          if (
            !o.test(n.item, 'insert') ||
            !o.test(n.item, 'attribute:listType') ||
            !o.test(n.item, 'attribute:listIndent')
          ) {
            return;
          }
          o.consume(n.item, 'insert');
          o.consume(n.item, 'attribute:listType');
          o.consume(n.item, 'attribute:listIndent');
          const r = n.item;
          const s = Lz(r, i);
          Vz(r, s, i, t);
        };
      }
      function Xz(t) {
        return (e, n, i) => {
          const o = i.mapper.toViewPosition(n.position);
          const r = o.getLastMatchingPosition(
            (t) => !t.item.is('element', 'li')
          );
          const s = r.nodeAfter;
          const a = i.writer;
          a.breakContainer(a.createPositionBefore(s));
          a.breakContainer(a.createPositionAfter(s));
          const c = s.parent;
          const l = c.previousSibling;
          const d = a.createRangeOn(c);
          const h = a.remove(d);
          if (l && l.nextSibling) {
            Hz(a, l, l.nextSibling);
          }
          const u = i.mapper.toModelElement(s);
          gO(
            u.getAttribute('listIndent') + 1,
            n.position,
            d.start,
            s,
            i,
            t
          );
          for (const t of a.createRangeIn(h).getItems()) {
            i.mapper.unbindViewElement(t);
          }
          e.stop();
        };
      }
      function tO(t, e, n) {
        if (!n.consumable.test(e.item, t.name)) {
          return;
        }
        const i = n.mapper.toViewElement(e.item);
        const o = n.writer;
        o.breakContainer(o.createPositionBefore(i));
        o.breakContainer(o.createPositionAfter(i));
        const r = i.parent;
        const s = e.attributeNewValue == 'numbered' ? 'ol' : 'ul';
        o.rename(s, r);
      }
      function eO(t, e, n) {
        n.consumable.consume(e.item, t.name);
        const i = n.mapper.toViewElement(e.item);
        const o = i.parent;
        const r = n.writer;
        Hz(r, o, o.nextSibling);
        Hz(r, o.previousSibling, o);
      }
      function nO(t) {
        return (e, n, i) => {
          if (!i.consumable.consume(n.item, 'attribute:listIndent')) {
            return;
          }
          const o = i.mapper.toViewElement(n.item);
          const r = i.writer;
          r.breakContainer(r.createPositionBefore(o));
          r.breakContainer(r.createPositionAfter(o));
          const s = o.parent;
          const a = s.previousSibling;
          const c = r.createRangeOn(s);
          r.remove(c);
          if (a && a.nextSibling) {
            Hz(r, a, a.nextSibling);
          }
          gO(
            n.attributeOldValue + 1,
            n.range.start,
            c.start,
            o,
            i,
            t
          );
          Vz(n.item, o, i, t);
          for (const t of n.item.getChildren()) {
            i.consumable.consume(t, 'insert');
          }
        };
      }
      function iO(t, e, n) {
        if (!n.consumable.test(e.item, t.name)) {
          return;
        }
        if (e.item.name != 'listItem') {
          let t = n.mapper.toViewPosition(e.range.start);
          const i = n.writer;
          const o = [];
          while (t.parent.name == 'ul' || t.parent.name == 'ol') {
            t = i.breakContainer(t);
            if (t.parent.name != 'li') {
              break;
            }
            const e = t;
            const n = i.createPositionAt(t.parent, 'end');
            if (!e.isEqual(n)) {
              const t = i.remove(i.createRange(e, n));
              o.push(t);
            }
            t = i.createPositionAfter(t.parent);
          }
          if (o.length > 0) {
            for (let e = 0; e < o.length; e++) {
              const n = t.nodeBefore;
              const r = i.insert(t, o[e]);
              t = r.end;
              if (e > 0) {
                const e = Hz(i, n, n.nextSibling);
                if (e && e.parent == n) {
                  t.offset--;
                }
              }
            }
            Hz(i, t.nodeBefore, t.nodeAfter);
          }
        }
      }
      function oO(t, e, n) {
        const i = n.mapper.toViewPosition(e.position);
        const o = i.nodeBefore;
        const r = i.nodeAfter;
        Hz(n.writer, o, r);
      }
      function rO(t, e, n) {
        if (n.consumable.consume(e.viewItem, { name: true })) {
          const t = n.writer;
          const i = t.createElement('listItem');
          const o = pO(e.viewItem);
          t.setAttribute('listIndent', o, i);
          const r =
            e.viewItem.parent && e.viewItem.parent.name == 'ol'
              ? 'numbered'
              : 'bulleted';
          t.setAttribute('listType', r, i);
          if (!n.safeInsert(i, e.modelCursor)) {
            return;
          }
          const s = uO(i, e.viewItem.getChildren(), n);
          e.modelRange = t.createRange(e.modelCursor, s);
          n.updateConversionResult(i, e);
        }
      }
      function sO(t, e, n) {
        if (n.consumable.test(e.viewItem, { name: true })) {
          const t = Array.from(e.viewItem.getChildren());
          for (const e of t) {
            const t = !(e.is('element', 'li') || mO(e));
            if (t) {
              e._remove();
            }
          }
        }
      }
      function aO(t, e, n) {
        if (n.consumable.test(e.viewItem, { name: true })) {
          if (e.viewItem.childCount === 0) {
            return;
          }
          const t = [...e.viewItem.getChildren()];
          let n = false;
          for (const e of t) {
            if (n && !mO(e)) {
              e._remove();
            }
            if (mO(e)) {
              n = true;
            }
          }
        }
      }
      function cO(t) {
        return (e, n) => {
          if (n.isPhantom) {
            return;
          }
          const i = n.modelPosition.nodeBefore;
          if (i && i.is('element', 'listItem')) {
            const e = n.mapper.toViewElement(i);
            const o = e.getAncestors().find(mO);
            const r = t.createPositionAt(e, 0).getWalker();
            for (const t of r) {
              if (
                t.type == 'elementStart' &&
                t.item.is('element', 'li')
              ) {
                n.viewPosition = t.previousPosition;
                break;
              } else if (t.type == 'elementEnd' && t.item == o) {
                n.viewPosition = t.nextPosition;
                break;
              }
            }
          }
        };
      }
      function lO(t) {
        return (e, n) => {
          const i = n.viewPosition;
          const o = i.parent;
          const r = n.mapper;
          if (o.name == 'ul' || o.name == 'ol') {
            if (!i.isAtEnd) {
              const e = r.toModelElement(i.nodeAfter);
              n.modelPosition = t.createPositionBefore(e);
            } else {
              const e = r.toModelElement(i.nodeBefore);
              const o = r.getModelLength(i.nodeBefore);
              n.modelPosition = t
                .createPositionBefore(e)
                .getShiftedBy(o);
            }
            e.stop();
          } else if (
            o.name == 'li' &&
            i.nodeBefore &&
            (i.nodeBefore.name == 'ul' || i.nodeBefore.name == 'ol')
          ) {
            const s = r.toModelElement(o);
            let a = 1;
            let c = i.nodeBefore;
            while (c && mO(c)) {
              a += r.getModelLength(c);
              c = c.previousSibling;
            }
            n.modelPosition = t
              .createPositionBefore(s)
              .getShiftedBy(a);
            e.stop();
          }
        };
      }
      function dO(t, e) {
        const n = t.document.differ.getChanges();
        const i = new Map();
        let o = false;
        for (const i of n) {
          if (i.type == 'insert' && i.name == 'listItem') {
            r(i.position);
          } else if (i.type == 'insert' && i.name != 'listItem') {
            if (i.name != '$text') {
              const n = i.position.nodeAfter;
              if (n.hasAttribute('listIndent')) {
                e.removeAttribute('listIndent', n);
                o = true;
              }
              if (n.hasAttribute('listType')) {
                e.removeAttribute('listType', n);
                o = true;
              }
              if (n.hasAttribute('listStyle')) {
                e.removeAttribute('listStyle', n);
                o = true;
              }
              if (n.hasAttribute('listReversed')) {
                e.removeAttribute('listReversed', n);
                o = true;
              }
              if (n.hasAttribute('listStart')) {
                e.removeAttribute('listStart', n);
                o = true;
              }
              for (const e of Array.from(t.createRangeIn(n)).filter(
                (t) => t.item.is('element', 'listItem')
              )) {
                r(e.previousPosition);
              }
            }
            const n = i.position.getShiftedBy(i.length);
            r(n);
          } else if (i.type == 'remove' && i.name == 'listItem') {
            r(i.position);
          } else if (
            i.type == 'attribute' &&
            i.attributeKey == 'listIndent'
          ) {
            r(i.range.start);
          } else if (
            i.type == 'attribute' &&
            i.attributeKey == 'listType'
          ) {
            r(i.range.start);
          }
        }
        for (const t of i.values()) {
          s(t);
          a(t);
        }
        return o;
        function r(t) {
          const e = t.nodeBefore;
          if (!e || !e.is('element', 'listItem')) {
            const e = t.nodeAfter;
            if (e && e.is('element', 'listItem')) {
              i.set(e, e);
            }
          } else {
            let t = e;
            if (i.has(t)) {
              return;
            }
            for (
              let e = t.previousSibling;
              e && e.is('element', 'listItem');
              e = t.previousSibling
            ) {
              t = e;
              if (i.has(t)) {
                return;
              }
            }
            i.set(e, t);
          }
        }
        function s(t) {
          let n = 0;
          let i = null;
          while (t && t.is('element', 'listItem')) {
            const r = t.getAttribute('listIndent');
            if (r > n) {
              let s;
              if (i === null) {
                i = r - n;
                s = n;
              } else {
                if (i > r) {
                  i = r;
                }
                s = r - i;
              }
              e.setAttribute('listIndent', s, t);
              o = true;
            } else {
              i = null;
              n = t.getAttribute('listIndent') + 1;
            }
            t = t.nextSibling;
          }
        }
        function a(t) {
          let n = [];
          let i = null;
          while (t && t.is('element', 'listItem')) {
            const r = t.getAttribute('listIndent');
            if (i && i.getAttribute('listIndent') > r) {
              n = n.slice(0, r + 1);
            }
            if (r != 0) {
              if (n[r]) {
                const i = n[r];
                if (t.getAttribute('listType') != i) {
                  e.setAttribute('listType', i, t);
                  o = true;
                }
              } else {
                n[r] = t.getAttribute('listType');
              }
            }
            i = t;
            t = t.nextSibling;
          }
        }
      }
      function hO(t, [e, n]) {
        let i = e.is('documentFragment') ? e.getChild(0) : e;
        let o;
        if (!n) {
          o = this.document.selection;
        } else {
          o = this.createSelection(n);
        }
        if (i && i.is('element', 'listItem')) {
          const t = o.getFirstPosition();
          let e = null;
          if (t.parent.is('element', 'listItem')) {
            e = t.parent;
          } else if (
            t.nodeBefore &&
            t.nodeBefore.is('element', 'listItem')
          ) {
            e = t.nodeBefore;
          }
          if (e) {
            const t = e.getAttribute('listIndent');
            if (t > 0) {
              while (i && i.is('element', 'listItem')) {
                i._setAttribute(
                  'listIndent',
                  i.getAttribute('listIndent') + t
                );
                i = i.nextSibling;
              }
            }
          }
        }
      }
      function uO(t, e, n) {
        const { writer: i, schema: o } = n;
        let r = i.createPositionAfter(t);
        for (const s of e) {
          if (s.name == 'ul' || s.name == 'ol') {
            r = n.convertItem(s, r).modelCursor;
          } else {
            const e = n.convertItem(s, i.createPositionAt(t, 'end'));
            const a = e.modelRange.start.nodeAfter;
            const c =
              a && a.is('element') && !o.checkChild(t, a.name);
            if (c) {
              if (e.modelCursor.parent.is('element', 'listItem')) {
                t = e.modelCursor.parent;
              } else {
                t = fO(e.modelCursor);
              }
              r = i.createPositionAfter(t);
            }
          }
        }
        return r;
      }
      function fO(t) {
        const e = new Bg({ startPosition: t });
        let n;
        do {
          n = e.next();
        } while (!n.value.item.is('element', 'listItem'));
        return n.value.item;
      }
      function gO(t, e, n, i, o, r) {
        const s = qz(e.nodeBefore, {
          sameIndent: true,
          smallerIndent: true,
          listIndent: t,
          foo: 'b',
        });
        const a = o.mapper;
        const c = o.writer;
        const l = s ? s.getAttribute('listIndent') : null;
        let d;
        if (!s) {
          d = n;
        } else if (l == t) {
          const t = a.toViewElement(s).parent;
          d = c.createPositionAfter(t);
        } else {
          const t = r.createPositionAt(s, 'end');
          d = a.toViewPosition(t);
        }
        d = jz(d);
        for (const t of [...i.getChildren()]) {
          if (mO(t)) {
            d = c.move(c.createRangeOn(t), d).end;
            Hz(c, t, t.nextSibling);
            Hz(c, t.previousSibling, t);
          }
        }
      }
      function mO(t) {
        return t.is('element', 'ol') || t.is('element', 'ul');
      }
      function pO(t) {
        let e = 0;
        let n = t.parent;
        while (n) {
          if (n.is('element', 'li')) {
            e++;
          } else {
            const t = n.previousSibling;
            if (t && t.is('element', 'li')) {
              e++;
            }
          }
          n = n.parent;
        }
        return e;
      }
      class kO extends nt {
        static get pluginName() {
          return 'ListEditing';
        }
        static get requires() {
          return [Ix, Hx];
        }
        init() {
          const t = this.editor;
          t.model.schema.register('listItem', {
            inheritAllFrom: '$block',
            allowAttributes: ['listType', 'listIndent'],
          });
          const e = t.data;
          const n = t.editing;
          t.model.document.registerPostFixer((e) => dO(t.model, e));
          n.mapper.registerViewToModelLength('li', bO);
          e.mapper.registerViewToModelLength('li', bO);
          n.mapper.on('modelToViewPosition', cO(n.view));
          n.mapper.on('viewToModelPosition', lO(t.model));
          e.mapper.on('modelToViewPosition', cO(n.view));
          t.conversion.for('editingDowncast').add((e) => {
            e.on('insert', iO, { priority: 'high' });
            e.on('insert:listItem', Qz(t.model));
            e.on('attribute:listType:listItem', tO, {
              priority: 'high',
            });
            e.on('attribute:listType:listItem', eO, {
              priority: 'low',
            });
            e.on('attribute:listIndent:listItem', nO(t.model));
            e.on('remove:listItem', Xz(t.model));
            e.on('remove', oO, { priority: 'low' });
          });
          t.conversion.for('dataDowncast').add((e) => {
            e.on('insert', iO, { priority: 'high' });
            e.on('insert:listItem', Qz(t.model));
          });
          t.conversion.for('upcast').add((t) => {
            t.on('element:ul', sO, { priority: 'high' });
            t.on('element:ol', sO, { priority: 'high' });
            t.on('element:li', aO, { priority: 'high' });
            t.on('element:li', rO);
          });
          t.model.on('insertContent', hO, { priority: 'high' });
          t.commands.add('numberedList', new zz(t, 'numbered'));
          t.commands.add('bulletedList', new zz(t, 'bulleted'));
          t.commands.add('indentList', new Nz(t, 'forward'));
          t.commands.add('outdentList', new Nz(t, 'backward'));
          const i = n.view.document;
          this.listenTo(
            i,
            'enter',
            (t, e) => {
              const n = this.editor.model.document;
              const i = n.selection.getLastPosition().parent;
              if (
                n.selection.isCollapsed &&
                i.name == 'listItem' &&
                i.isEmpty
              ) {
                this.editor.execute('outdentList');
                e.preventDefault();
                t.stop();
              }
            },
            { context: 'li' }
          );
          this.listenTo(
            i,
            'delete',
            (t, e) => {
              if (e.direction !== 'backward') {
                return;
              }
              const n = this.editor.model.document.selection;
              if (!n.isCollapsed) {
                return;
              }
              const i = n.getFirstPosition();
              if (!i.isAtStart) {
                return;
              }
              const o = i.parent;
              if (o.name !== 'listItem') {
                return;
              }
              const r =
                o.previousSibling &&
                o.previousSibling.name === 'listItem';
              if (r) {
                return;
              }
              this.editor.execute('outdentList');
              e.preventDefault();
              t.stop();
            },
            { context: 'li' }
          );
          this.listenTo(
            t.editing.view.document,
            'tab',
            (e, n) => {
              const i = n.shiftKey ? 'outdentList' : 'indentList';
              const o = this.editor.commands.get(i);
              if (o.isEnabled) {
                t.execute(i);
                n.stopPropagation();
                n.preventDefault();
                e.stop();
              }
            },
            { context: 'li' }
          );
        }
        afterInit() {
          const t = this.editor.commands;
          const e = t.get('indent');
          const n = t.get('outdent');
          if (e) {
            e.registerChildCommand(t.get('indentList'));
          }
          if (n) {
            n.registerChildCommand(t.get('outdentList'));
          }
        }
      }
      function bO(t) {
        let e = 1;
        for (const n of t.getChildren()) {
          if (n.name == 'ul' || n.name == 'ol') {
            for (const t of n.getChildren()) {
              e += bO(t);
            }
          }
        }
        return e;
      }
      const wO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
      const _O =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
      class vO extends nt {
        static get pluginName() {
          return 'ListUI';
        }
        init() {
          const t = this.editor.t;
          Wz(this.editor, 'numberedList', t('Numbered List'), wO);
          Wz(this.editor, 'bulletedList', t('Bulleted List'), _O);
        }
      }
      class AO extends nt {
        static get requires() {
          return [kO, vO];
        }
        static get pluginName() {
          return 'List';
        }
      }
      class CO extends ot {
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          const n = Xf(e.selection.getSelectedBlocks());
          this.value = !!n && n.is('element', 'paragraph');
          this.isEnabled = !!n && yO(n, t.schema);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          e.change((i) => {
            const o = (
              t.selection || n.selection
            ).getSelectedBlocks();
            for (const t of o) {
              if (!t.is('element', 'paragraph') && yO(t, e.schema)) {
                i.rename(t, 'paragraph');
              }
            }
          });
        }
      }
      function yO(t, e) {
        return e.checkChild(t.parent, 'paragraph') && !e.isObject(t);
      }
      class xO extends ot {
        execute(t) {
          const e = this.editor.model;
          const n = t.attributes;
          let i = t.position;
          e.change((t) => {
            const o = t.createElement('paragraph');
            if (n) {
              e.schema.setAllowedAttributes(o, n, t);
            }
            if (!e.schema.checkChild(i.parent, o)) {
              const n = e.schema.findAllowedParent(i, o);
              if (!n) {
                return;
              }
              i = t.split(i, n).position;
            }
            e.insertContent(o, i);
            t.setSelection(o, 'in');
          });
        }
      }
      class EO extends nt {
        static get pluginName() {
          return 'Paragraph';
        }
        init() {
          const t = this.editor;
          const e = t.model;
          t.commands.add('paragraph', new CO(t));
          t.commands.add('insertParagraph', new xO(t));
          e.schema.register('paragraph', {
            inheritAllFrom: '$block',
          });
          t.conversion.elementToElement({
            model: 'paragraph',
            view: 'p',
          });
          t.conversion.for('upcast').elementToElement({
            model: (t, { writer: e }) => {
              if (!EO.paragraphLikeElements.has(t.name)) {
                return null;
              }
              if (t.isEmpty) {
                return null;
              }
              return e.createElement('paragraph');
            },
            view: /.+/,
            converterPriority: 'low',
          });
        }
      }
      EO.paragraphLikeElements = new Set([
        'blockquote',
        'dd',
        'div',
        'dt',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'li',
        'p',
        'td',
        'th',
      ]);
      const DO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>';
      const SO = 'removeFormat';
      class TO extends nt {
        static get pluginName() {
          return 'RemoveFormatUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(SO, (n) => {
            const i = t.commands.get(SO);
            const o = new iv(n);
            o.set({
              label: e('Remove Format'),
              icon: DO,
              tooltip: true,
            });
            o.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled');
            this.listenTo(o, 'execute', () => {
              t.execute(SO);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class BO extends ot {
        refresh() {
          const t = this.editor.model;
          this.isEnabled = !!Xf(
            this._getFormattingItems(t.document.selection, t.schema)
          );
        }
        execute() {
          const t = this.editor.model;
          const e = t.schema;
          t.change((n) => {
            for (const i of this._getFormattingItems(
              t.document.selection,
              e
            )) {
              if (i.is('selection')) {
                for (const t of this._getFormattingAttributes(i, e)) {
                  n.removeSelectionAttribute(t);
                }
              } else {
                const t = n.createRangeOn(i);
                for (const o of this._getFormattingAttributes(i, e)) {
                  n.removeAttribute(o, t);
                }
              }
            }
          });
        }
        *_getFormattingItems(t, e) {
          const n = (t) => !!Xf(this._getFormattingAttributes(t, e));
          for (const i of t.getRanges()) {
            for (const t of i.getItems()) {
              if (!e.isBlock(t) && n(t)) {
                yield t;
              }
            }
          }
          for (const e of t.getSelectedBlocks()) {
            if (n(e)) {
              yield e;
            }
          }
          if (n(t)) {
            yield t;
          }
        }
        *_getFormattingAttributes(t, e) {
          for (const [n] of t.getAttributes()) {
            const t = e.getAttributeProperties(n);
            if (t && t.isFormatting) {
              yield n;
            }
          }
        }
      }
      class PO extends nt {
        static get pluginName() {
          return 'RemoveFormatEditing';
        }
        init() {
          const t = this.editor;
          t.commands.add('removeFormat', new BO(t));
        }
      }
      class IO extends nt {
        static get requires() {
          return [PO, TO];
        }
        static get pluginName() {
          return 'RemoveFormat';
        }
      }
      class RO extends IA {
        constructor(t, e) {
          super(t);
          const n = t.t;
          this.set('class', 'ck-special-characters-navigation');
          this.groupDropdownView = this._createGroupDropdown(e);
          this.groupDropdownView.panelPosition =
            t.uiLanguageDirection === 'rtl' ? 'se' : 'sw';
          this.label = n('Special characters');
          this.children.add(this.groupDropdownView);
        }
        get currentGroupName() {
          return this.groupDropdownView.value;
        }
        focus() {
          this.groupDropdownView.focus();
        }
        _createGroupDropdown(t) {
          const e = this.locale;
          const n = e.t;
          const i = aA(e);
          const o = this._getCharacterGroupListItemDefinitions(i, t);
          i.set('value', o.first.model.label);
          i.buttonView.bind('label').to(i, 'value');
          i.buttonView.set({
            isOn: false,
            withText: true,
            tooltip: n('Character categories'),
            class: ['ck-dropdown__button_label-width_auto'],
          });
          i.on('execute', (t) => {
            i.value = t.source.label;
          });
          i.delegate('execute').to(this);
          lA(i, o);
          return i;
        }
        _getCharacterGroupListItemDefinitions(t, e) {
          const n = new ya();
          for (const i of e) {
            const e = {
              type: 'button',
              model: new YA({ label: i, withText: true }),
            };
            e.model
              .bind('isOn')
              .to(t, 'value', (t) => t === e.model.label);
            n.add(e);
          }
          return n;
        }
      }
      var zO = n(4046);
      var OO = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      OO.insert = 'head';
      OO.singleton = true;
      var FO = Lh()(zO.Z, OO);
      const NO = zO.Z.locals || {};
      class MO extends Dw {
        constructor(t) {
          super(t);
          this.tiles = this.createCollection();
          this.setTemplate({
            tag: 'div',
            children: [
              {
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-character-grid__tiles'],
                },
                children: this.tiles,
              },
            ],
            attributes: { class: ['ck', 'ck-character-grid'] },
          });
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          j_({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.tiles,
            numberOfColumns: () =>
              Sa.window
                .getComputedStyle(this.element.firstChild)
                .getPropertyValue('grid-template-columns')
                .split(' ').length,
          });
        }
        createTile(t, e) {
          const n = new iv(this.locale);
          n.set({
            label: t,
            withText: true,
            class: 'ck-character-grid__tile',
          });
          n.extendTemplate({
            attributes: { title: e },
            on: { mouseover: n.bindTemplate.to('mouseover') },
          });
          n.on('mouseover', () => {
            this.fire('tileHover', { name: e, character: t });
          });
          n.on('execute', () => {
            this.fire('execute', { name: e, character: t });
          });
          return n;
        }
        render() {
          super.render();
          for (const t of this.tiles) {
            this.focusTracker.add(t.element);
          }
          this.tiles.on('change', (t, { added: e, removed: n }) => {
            if (e.length > 0) {
              for (const t of e) {
                this.focusTracker.add(t.element);
              }
            }
            if (n.length > 0) {
              for (const t of n) {
                this.focusTracker.remove(t.element);
              }
            }
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this.tiles.get(0).focus();
        }
      }
      var LO = n(4779);
      var VO = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      VO.insert = 'head';
      VO.singleton = true;
      var HO = Lh()(LO.Z, VO);
      const jO = LO.Z.locals || {};
      class qO extends Dw {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('character', null);
          this.set('name', null);
          this.bind('code').to(this, 'character', WO);
          this.setTemplate({
            tag: 'div',
            children: [
              {
                tag: 'span',
                attributes: { class: ['ck-character-info__name'] },
                children: [
                  { text: e.to('name', (t) => (t ? t : '​')) },
                ],
              },
              {
                tag: 'span',
                attributes: { class: ['ck-character-info__code'] },
                children: [{ text: e.to('code') }],
              },
            ],
            attributes: { class: ['ck', 'ck-character-info'] },
          });
        }
      }
      function WO(t) {
        if (t === null) {
          return '';
        }
        const e = t.codePointAt(0).toString(16);
        return 'U+' + ('0000' + e).slice(-4);
      }
      class UO extends Dw {
        constructor(t, e, n, i) {
          super(t);
          this.items = this.createCollection();
          this.focusTracker = new tg();
          this.keystrokes = new eg();
          this._focusCycler = new Iv({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: 'shift + tab',
              focusNext: 'tab',
            },
          });
          this.navigationView = e;
          this.gridView = n;
          this.infoView = i;
          this.setTemplate({
            tag: 'div',
            children: [
              this.navigationView,
              this.gridView,
              this.infoView,
            ],
          });
          this.items.add(
            this.navigationView.groupDropdownView.buttonView
          );
          this.items.add(this.gridView);
        }
        render() {
          super.render();
          this.focusTracker.add(
            this.navigationView.groupDropdownView.buttonView.element
          );
          this.focusTracker.add(this.gridView.element);
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this.navigationView.focus();
        }
      }
      const GO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>';
      var $O = n(8170);
      var KO = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      KO.insert = 'head';
      KO.singleton = true;
      var ZO = Lh()($O.Z, KO);
      const JO = $O.Z.locals || {};
      const YO = 'All';
      class QO extends nt {
        static get requires() {
          return [xD];
        }
        static get pluginName() {
          return 'SpecialCharacters';
        }
        constructor(t) {
          super(t);
          this._characters = new Map();
          this._groups = new Map();
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = t.commands.get('input');
          t.ui.componentFactory.add('specialCharacters', (i) => {
            const o = aA(i);
            let r;
            o.buttonView.set({
              label: e('Special characters'),
              icon: GO,
              tooltip: true,
            });
            o.bind('isEnabled').to(n);
            o.on('execute', (e, n) => {
              t.execute('input', { text: n.character });
              t.editing.view.focus();
            });
            o.on('change:isOpen', () => {
              if (!r) {
                r = this._createDropdownPanelContent(i, o);
                const t = new UO(
                  i,
                  r.navigationView,
                  r.gridView,
                  r.infoView
                );
                o.panelView.children.add(t);
              }
              r.infoView.set({ character: null, name: null });
            });
            return o;
          });
        }
        addItems(t, e) {
          if (t === YO) {
            throw new h(
              `special-character-invalid-group-name: The name "${YO}" is reserved and cannot be used.`
            );
          }
          const n = this._getGroup(t);
          for (const t of e) {
            n.add(t.title);
            this._characters.set(t.title, t.character);
          }
        }
        getGroups() {
          return this._groups.keys();
        }
        getCharactersForGroup(t) {
          if (t === YO) {
            return new Set(this._characters.keys());
          }
          return this._groups.get(t);
        }
        getCharacter(t) {
          return this._characters.get(t);
        }
        _getGroup(t) {
          if (!this._groups.has(t)) {
            this._groups.set(t, new Set());
          }
          return this._groups.get(t);
        }
        _updateGrid(t, e) {
          e.tiles.clear();
          const n = this.getCharactersForGroup(t);
          for (const t of n) {
            const n = this.getCharacter(t);
            e.tiles.add(e.createTile(n, t));
          }
        }
        _createDropdownPanelContent(t, e) {
          const n = [...this.getGroups()];
          n.unshift(YO);
          const i = new RO(t, n);
          const o = new MO(t);
          const r = new qO(t);
          o.delegate('execute').to(e);
          o.on('tileHover', (t, e) => {
            r.set(e);
          });
          i.on('execute', () => {
            this._updateGrid(i.currentGroupName, o);
          });
          this._updateGrid(i.currentGroupName, o);
          return { navigationView: i, gridView: o, infoView: r };
        }
      }
      class XO extends nt {
        static get pluginName() {
          return 'SpecialCharactersArrows';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get('SpecialCharacters').addItems('Arrows', [
            { title: e('leftwards double arrow'), character: '⇐' },
            { title: e('rightwards double arrow'), character: '⇒' },
            { title: e('upwards double arrow'), character: '⇑' },
            { title: e('downwards double arrow'), character: '⇓' },
            { title: e('leftwards dashed arrow'), character: '⇠' },
            { title: e('rightwards dashed arrow'), character: '⇢' },
            { title: e('upwards dashed arrow'), character: '⇡' },
            { title: e('downwards dashed arrow'), character: '⇣' },
            { title: e('leftwards arrow to bar'), character: '⇤' },
            { title: e('rightwards arrow to bar'), character: '⇥' },
            { title: e('upwards arrow to bar'), character: '⤒' },
            { title: e('downwards arrow to bar'), character: '⤓' },
            { title: e('up down arrow with base'), character: '↨' },
            {
              title: e('back with leftwards arrow above'),
              character: '🔙',
            },
            {
              title: e('end with leftwards arrow above'),
              character: '🔚',
            },
            {
              title: e(
                'on with exclamation mark with left right arrow above'
              ),
              character: '🔛',
            },
            {
              title: e('soon with rightwards arrow above'),
              character: '🔜',
            },
            {
              title: e('top with upwards arrow above'),
              character: '🔝',
            },
          ]);
        }
      }
      class tF extends nt {
        static get pluginName() {
          return 'SpecialCharactersCurrency';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get('SpecialCharacters').addItems('Currency', [
            { character: '$', title: e('Dollar sign') },
            { character: '€', title: e('Euro sign') },
            { character: '¥', title: e('Yen sign') },
            { character: '£', title: e('Pound sign') },
            { character: '¢', title: e('Cent sign') },
            { character: '₠', title: e('Euro-currency sign') },
            { character: '₡', title: e('Colon sign') },
            { character: '₢', title: e('Cruzeiro sign') },
            { character: '₣', title: e('French franc sign') },
            { character: '₤', title: e('Lira sign') },
            { character: '¤', title: e('Currency sign') },
            { character: '₿', title: e('Bitcoin sign') },
            { character: '₥', title: e('Mill sign') },
            { character: '₦', title: e('Naira sign') },
            { character: '₧', title: e('Peseta sign') },
            { character: '₨', title: e('Rupee sign') },
            { character: '₩', title: e('Won sign') },
            { character: '₪', title: e('New sheqel sign') },
            { character: '₫', title: e('Dong sign') },
            { character: '₭', title: e('Kip sign') },
            { character: '₮', title: e('Tugrik sign') },
            { character: '₯', title: e('Drachma sign') },
            { character: '₰', title: e('German penny sign') },
            { character: '₱', title: e('Peso sign') },
            { character: '₲', title: e('Guarani sign') },
            { character: '₳', title: e('Austral sign') },
            { character: '₴', title: e('Hryvnia sign') },
            { character: '₵', title: e('Cedi sign') },
            { character: '₶', title: e('Livre tournois sign') },
            { character: '₷', title: e('Spesmilo sign') },
            { character: '₸', title: e('Tenge sign') },
            { character: '₹', title: e('Indian rupee sign') },
            { character: '₺', title: e('Turkish lira sign') },
            { character: '₻', title: e('Nordic mark sign') },
            { character: '₼', title: e('Manat sign') },
            { character: '₽', title: e('Ruble sign') },
          ]);
        }
      }
      class eF extends nt {
        static get pluginName() {
          return 'SpecialCharactersMathematical';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins
            .get('SpecialCharacters')
            .addItems('Mathematical', [
              { character: '<', title: e('Less-than sign') },
              { character: '>', title: e('Greater-than sign') },
              { character: '≤', title: e('Less-than or equal to') },
              {
                character: '≥',
                title: e('Greater-than or equal to'),
              },
              { character: '–', title: e('En dash') },
              { character: '—', title: e('Em dash') },
              { character: '¯', title: e('Macron') },
              { character: '‾', title: e('Overline') },
              { character: '°', title: e('Degree sign') },
              { character: '−', title: e('Minus sign') },
              { character: '±', title: e('Plus-minus sign') },
              { character: '÷', title: e('Division sign') },
              { character: '⁄', title: e('Fraction slash') },
              { character: '×', title: e('Multiplication sign') },
              {
                character: 'ƒ',
                title: e('Latin small letter f with hook'),
              },
              { character: '∫', title: e('Integral') },
              { character: '∑', title: e('N-ary summation') },
              { character: '∞', title: e('Infinity') },
              { character: '√', title: e('Square root') },
              { character: '∼', title: e('Tilde operator') },
              { character: '≅', title: e('Approximately equal to') },
              { character: '≈', title: e('Almost equal to') },
              { character: '≠', title: e('Not equal to') },
              { character: '≡', title: e('Identical to') },
              { character: '∈', title: e('Element of') },
              { character: '∉', title: e('Not an element of') },
              { character: '∋', title: e('Contains as member') },
              { character: '∏', title: e('N-ary product') },
              { character: '∧', title: e('Logical and') },
              { character: '∨', title: e('Logical or') },
              { character: '¬', title: e('Not sign') },
              { character: '∩', title: e('Intersection') },
              { character: '∪', title: e('Union') },
              { character: '∂', title: e('Partial differential') },
              { character: '∀', title: e('For all') },
              { character: '∃', title: e('There exists') },
              { character: '∅', title: e('Empty set') },
              { character: '∇', title: e('Nabla') },
              { character: '∗', title: e('Asterisk operator') },
              { character: '∝', title: e('Proportional to') },
              { character: '∠', title: e('Angle') },
              {
                character: '¼',
                title: e('Vulgar fraction one quarter'),
              },
              {
                character: '½',
                title: e('Vulgar fraction one half'),
              },
              {
                character: '¾',
                title: e('Vulgar fraction three quarters'),
              },
            ]);
        }
      }
      class nF extends nt {
        static get pluginName() {
          return 'SpecialCharactersLatin';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get('SpecialCharacters').addItems('Latin', [
            {
              character: 'Ā',
              title: e('Latin capital letter a with macron'),
            },
            {
              character: 'ā',
              title: e('Latin small letter a with macron'),
            },
            {
              character: 'Ă',
              title: e('Latin capital letter a with breve'),
            },
            {
              character: 'ă',
              title: e('Latin small letter a with breve'),
            },
            {
              character: 'Ą',
              title: e('Latin capital letter a with ogonek'),
            },
            {
              character: 'ą',
              title: e('Latin small letter a with ogonek'),
            },
            {
              character: 'Ć',
              title: e('Latin capital letter c with acute'),
            },
            {
              character: 'ć',
              title: e('Latin small letter c with acute'),
            },
            {
              character: 'Ĉ',
              title: e('Latin capital letter c with circumflex'),
            },
            {
              character: 'ĉ',
              title: e('Latin small letter c with circumflex'),
            },
            {
              character: 'Ċ',
              title: e('Latin capital letter c with dot above'),
            },
            {
              character: 'ċ',
              title: e('Latin small letter c with dot above'),
            },
            {
              character: 'Č',
              title: e('Latin capital letter c with caron'),
            },
            {
              character: 'č',
              title: e('Latin small letter c with caron'),
            },
            {
              character: 'Ď',
              title: e('Latin capital letter d with caron'),
            },
            {
              character: 'ď',
              title: e('Latin small letter d with caron'),
            },
            {
              character: 'Đ',
              title: e('Latin capital letter d with stroke'),
            },
            {
              character: 'đ',
              title: e('Latin small letter d with stroke'),
            },
            {
              character: 'Ē',
              title: e('Latin capital letter e with macron'),
            },
            {
              character: 'ē',
              title: e('Latin small letter e with macron'),
            },
            {
              character: 'Ĕ',
              title: e('Latin capital letter e with breve'),
            },
            {
              character: 'ĕ',
              title: e('Latin small letter e with breve'),
            },
            {
              character: 'Ė',
              title: e('Latin capital letter e with dot above'),
            },
            {
              character: 'ė',
              title: e('Latin small letter e with dot above'),
            },
            {
              character: 'Ę',
              title: e('Latin capital letter e with ogonek'),
            },
            {
              character: 'ę',
              title: e('Latin small letter e with ogonek'),
            },
            {
              character: 'Ě',
              title: e('Latin capital letter e with caron'),
            },
            {
              character: 'ě',
              title: e('Latin small letter e with caron'),
            },
            {
              character: 'Ĝ',
              title: e('Latin capital letter g with circumflex'),
            },
            {
              character: 'ĝ',
              title: e('Latin small letter g with circumflex'),
            },
            {
              character: 'Ğ',
              title: e('Latin capital letter g with breve'),
            },
            {
              character: 'ğ',
              title: e('Latin small letter g with breve'),
            },
            {
              character: 'Ġ',
              title: e('Latin capital letter g with dot above'),
            },
            {
              character: 'ġ',
              title: e('Latin small letter g with dot above'),
            },
            {
              character: 'Ģ',
              title: e('Latin capital letter g with cedilla'),
            },
            {
              character: 'ģ',
              title: e('Latin small letter g with cedilla'),
            },
            {
              character: 'Ĥ',
              title: e('Latin capital letter h with circumflex'),
            },
            {
              character: 'ĥ',
              title: e('Latin small letter h with circumflex'),
            },
            {
              character: 'Ħ',
              title: e('Latin capital letter h with stroke'),
            },
            {
              character: 'ħ',
              title: e('Latin small letter h with stroke'),
            },
            {
              character: 'Ĩ',
              title: e('Latin capital letter i with tilde'),
            },
            {
              character: 'ĩ',
              title: e('Latin small letter i with tilde'),
            },
            {
              character: 'Ī',
              title: e('Latin capital letter i with macron'),
            },
            {
              character: 'ī',
              title: e('Latin small letter i with macron'),
            },
            {
              character: 'Ĭ',
              title: e('Latin capital letter i with breve'),
            },
            {
              character: 'ĭ',
              title: e('Latin small letter i with breve'),
            },
            {
              character: 'Į',
              title: e('Latin capital letter i with ogonek'),
            },
            {
              character: 'į',
              title: e('Latin small letter i with ogonek'),
            },
            {
              character: 'İ',
              title: e('Latin capital letter i with dot above'),
            },
            {
              character: 'ı',
              title: e('Latin small letter dotless i'),
            },
            { character: 'Ĳ', title: e('Latin capital ligature ij') },
            { character: 'ĳ', title: e('Latin small ligature ij') },
            {
              character: 'Ĵ',
              title: e('Latin capital letter j with circumflex'),
            },
            {
              character: 'ĵ',
              title: e('Latin small letter j with circumflex'),
            },
            {
              character: 'Ķ',
              title: e('Latin capital letter k with cedilla'),
            },
            {
              character: 'ķ',
              title: e('Latin small letter k with cedilla'),
            },
            { character: 'ĸ', title: e('Latin small letter kra') },
            {
              character: 'Ĺ',
              title: e('Latin capital letter l with acute'),
            },
            {
              character: 'ĺ',
              title: e('Latin small letter l with acute'),
            },
            {
              character: 'Ļ',
              title: e('Latin capital letter l with cedilla'),
            },
            {
              character: 'ļ',
              title: e('Latin small letter l with cedilla'),
            },
            {
              character: 'Ľ',
              title: e('Latin capital letter l with caron'),
            },
            {
              character: 'ľ',
              title: e('Latin small letter l with caron'),
            },
            {
              character: 'Ŀ',
              title: e('Latin capital letter l with middle dot'),
            },
            {
              character: 'ŀ',
              title: e('Latin small letter l with middle dot'),
            },
            {
              character: 'Ł',
              title: e('Latin capital letter l with stroke'),
            },
            {
              character: 'ł',
              title: e('Latin small letter l with stroke'),
            },
            {
              character: 'Ń',
              title: e('Latin capital letter n with acute'),
            },
            {
              character: 'ń',
              title: e('Latin small letter n with acute'),
            },
            {
              character: 'Ņ',
              title: e('Latin capital letter n with cedilla'),
            },
            {
              character: 'ņ',
              title: e('Latin small letter n with cedilla'),
            },
            {
              character: 'Ň',
              title: e('Latin capital letter n with caron'),
            },
            {
              character: 'ň',
              title: e('Latin small letter n with caron'),
            },
            {
              character: 'ŉ',
              title: e('Latin small letter n preceded by apostrophe'),
            },
            { character: 'Ŋ', title: e('Latin capital letter eng') },
            { character: 'ŋ', title: e('Latin small letter eng') },
            {
              character: 'Ō',
              title: e('Latin capital letter o with macron'),
            },
            {
              character: 'ō',
              title: e('Latin small letter o with macron'),
            },
            {
              character: 'Ŏ',
              title: e('Latin capital letter o with breve'),
            },
            {
              character: 'ŏ',
              title: e('Latin small letter o with breve'),
            },
            {
              character: 'Ő',
              title: e('Latin capital letter o with double acute'),
            },
            {
              character: 'ő',
              title: e('Latin small letter o with double acute'),
            },
            { character: 'Œ', title: e('Latin capital ligature oe') },
            { character: 'œ', title: e('Latin small ligature oe') },
            {
              character: 'Ŕ',
              title: e('Latin capital letter r with acute'),
            },
            {
              character: 'ŕ',
              title: e('Latin small letter r with acute'),
            },
            {
              character: 'Ŗ',
              title: e('Latin capital letter r with cedilla'),
            },
            {
              character: 'ŗ',
              title: e('Latin small letter r with cedilla'),
            },
            {
              character: 'Ř',
              title: e('Latin capital letter r with caron'),
            },
            {
              character: 'ř',
              title: e('Latin small letter r with caron'),
            },
            {
              character: 'Ś',
              title: e('Latin capital letter s with acute'),
            },
            {
              character: 'ś',
              title: e('Latin small letter s with acute'),
            },
            {
              character: 'Ŝ',
              title: e('Latin capital letter s with circumflex'),
            },
            {
              character: 'ŝ',
              title: e('Latin small letter s with circumflex'),
            },
            {
              character: 'Ş',
              title: e('Latin capital letter s with cedilla'),
            },
            {
              character: 'ş',
              title: e('Latin small letter s with cedilla'),
            },
            {
              character: 'Š',
              title: e('Latin capital letter s with caron'),
            },
            {
              character: 'š',
              title: e('Latin small letter s with caron'),
            },
            {
              character: 'Ţ',
              title: e('Latin capital letter t with cedilla'),
            },
            {
              character: 'ţ',
              title: e('Latin small letter t with cedilla'),
            },
            {
              character: 'Ť',
              title: e('Latin capital letter t with caron'),
            },
            {
              character: 'ť',
              title: e('Latin small letter t with caron'),
            },
            {
              character: 'Ŧ',
              title: e('Latin capital letter t with stroke'),
            },
            {
              character: 'ŧ',
              title: e('Latin small letter t with stroke'),
            },
            {
              character: 'Ũ',
              title: e('Latin capital letter u with tilde'),
            },
            {
              character: 'ũ',
              title: e('Latin small letter u with tilde'),
            },
            {
              character: 'Ū',
              title: e('Latin capital letter u with macron'),
            },
            {
              character: 'ū',
              title: e('Latin small letter u with macron'),
            },
            {
              character: 'Ŭ',
              title: e('Latin capital letter u with breve'),
            },
            {
              character: 'ŭ',
              title: e('Latin small letter u with breve'),
            },
            {
              character: 'Ů',
              title: e('Latin capital letter u with ring above'),
            },
            {
              character: 'ů',
              title: e('Latin small letter u with ring above'),
            },
            {
              character: 'Ű',
              title: e('Latin capital letter u with double acute'),
            },
            {
              character: 'ű',
              title: e('Latin small letter u with double acute'),
            },
            {
              character: 'Ų',
              title: e('Latin capital letter u with ogonek'),
            },
            {
              character: 'ų',
              title: e('Latin small letter u with ogonek'),
            },
            {
              character: 'Ŵ',
              title: e('Latin capital letter w with circumflex'),
            },
            {
              character: 'ŵ',
              title: e('Latin small letter w with circumflex'),
            },
            {
              character: 'Ŷ',
              title: e('Latin capital letter y with circumflex'),
            },
            {
              character: 'ŷ',
              title: e('Latin small letter y with circumflex'),
            },
            {
              character: 'Ÿ',
              title: e('Latin capital letter y with diaeresis'),
            },
            {
              character: 'Ź',
              title: e('Latin capital letter z with acute'),
            },
            {
              character: 'ź',
              title: e('Latin small letter z with acute'),
            },
            {
              character: 'Ż',
              title: e('Latin capital letter z with dot above'),
            },
            {
              character: 'ż',
              title: e('Latin small letter z with dot above'),
            },
            {
              character: 'Ž',
              title: e('Latin capital letter z with caron'),
            },
            {
              character: 'ž',
              title: e('Latin small letter z with caron'),
            },
            { character: 'ſ', title: e('Latin small letter long s') },
          ]);
        }
      }
      class iF extends nt {
        static get pluginName() {
          return 'SpecialCharactersText';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.plugins.get('SpecialCharacters').addItems('Text', [
            {
              character: '‹',
              title: e('Single left-pointing angle quotation mark'),
            },
            {
              character: '›',
              title: e('Single right-pointing angle quotation mark'),
            },
            {
              character: '«',
              title: e('Left-pointing double angle quotation mark'),
            },
            {
              character: '»',
              title: e('Right-pointing double angle quotation mark'),
            },
            {
              character: '‘',
              title: e('Left single quotation mark'),
            },
            {
              character: '’',
              title: e('Right single quotation mark'),
            },
            {
              character: '“',
              title: e('Left double quotation mark'),
            },
            {
              character: '”',
              title: e('Right double quotation mark'),
            },
            {
              character: '‚',
              title: e('Single low-9 quotation mark'),
            },
            {
              character: '„',
              title: e('Double low-9 quotation mark'),
            },
            { character: '¡', title: e('Inverted exclamation mark') },
            { character: '¿', title: e('Inverted question mark') },
            { character: '‥', title: e('Two dot leader') },
            { character: '…', title: e('Horizontal ellipsis') },
            { character: '‡', title: e('Double dagger') },
            { character: '‰', title: e('Per mille sign') },
            { character: '‱', title: e('Per ten thousand sign') },
            { character: '‼', title: e('Double exclamation mark') },
            { character: '⁈', title: e('Question exclamation mark') },
            { character: '⁉', title: e('Exclamation question mark') },
            { character: '⁇', title: e('Double question mark') },
            { character: '©', title: e('Copyright sign') },
            { character: '®', title: e('Registered sign') },
            { character: '™', title: e('Trade mark sign') },
            { character: '§', title: e('Section sign') },
            { character: '¶', title: e('Paragraph sign') },
            { character: '⁋', title: e('Reversed paragraph sign') },
          ]);
        }
      }
      class oF extends nt {
        static get requires() {
          return [tF, iF, eF, XO, nF];
        }
      }
      const rF = 'strikethrough';
      class sF extends nt {
        static get pluginName() {
          return 'StrikethroughEditing';
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', { allowAttributes: rF });
          t.model.schema.setAttributeProperties(rF, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: rF,
            view: 's',
            upcastAlso: [
              'del',
              'strike',
              { styles: { 'text-decoration': 'line-through' } },
            ],
          });
          t.commands.add(rF, new zT(t, rF));
          t.keystrokes.set('CTRL+SHIFT+X', 'strikethrough');
        }
      }
      const aF =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
      const cF = 'strikethrough';
      class lF extends nt {
        static get pluginName() {
          return 'StrikethroughUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(cF, (n) => {
            const i = t.commands.get(cF);
            const o = new iv(n);
            o.set({
              label: e('Strikethrough'),
              icon: aF,
              keystroke: 'CTRL+SHIFT+X',
              tooltip: true,
              isToggleable: true,
            });
            o.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled');
            this.listenTo(o, 'execute', () => {
              t.execute(cF);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class dF extends nt {
        static get requires() {
          return [sF, lF];
        }
        static get pluginName() {
          return 'Strikethrough';
        }
      }
      const hF = 'subscript';
      class uF extends nt {
        static get pluginName() {
          return 'SubscriptEditing';
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', { allowAttributes: hF });
          t.model.schema.setAttributeProperties(hF, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: hF,
            view: 'sub',
            upcastAlso: [{ styles: { 'vertical-align': 'sub' } }],
          });
          t.commands.add(hF, new zT(t, hF));
        }
      }
      const fF =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
      const gF = 'subscript';
      class mF extends nt {
        static get pluginName() {
          return 'SubscriptUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(gF, (n) => {
            const i = t.commands.get(gF);
            const o = new iv(n);
            o.set({
              label: e('Subscript'),
              icon: fF,
              tooltip: true,
              isToggleable: true,
            });
            o.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled');
            this.listenTo(o, 'execute', () => {
              t.execute(gF);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class pF extends nt {
        static get requires() {
          return [uF, mF];
        }
        static get pluginName() {
          return 'Subscript';
        }
      }
      const kF = 'superscript';
      class bF extends nt {
        static get pluginName() {
          return 'SuperscriptEditing';
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', { allowAttributes: kF });
          t.model.schema.setAttributeProperties(kF, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: kF,
            view: 'sup',
            upcastAlso: [{ styles: { 'vertical-align': 'super' } }],
          });
          t.commands.add(kF, new zT(t, kF));
        }
      }
      const wF =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
      const _F = 'superscript';
      class vF extends nt {
        static get pluginName() {
          return 'SuperscriptUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(_F, (n) => {
            const i = t.commands.get(_F);
            const o = new iv(n);
            o.set({
              label: e('Superscript'),
              icon: wF,
              tooltip: true,
              isToggleable: true,
            });
            o.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled');
            this.listenTo(o, 'execute', () => {
              t.execute(_F);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class AF extends nt {
        static get requires() {
          return [bF, vF];
        }
        static get pluginName() {
          return 'Superscript';
        }
      }
      const CF = 'underline';
      class yF extends nt {
        static get pluginName() {
          return 'UnderlineEditing';
        }
        init() {
          const t = this.editor;
          t.model.schema.extend('$text', { allowAttributes: CF });
          t.model.schema.setAttributeProperties(CF, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: CF,
            view: 'u',
            upcastAlso: {
              styles: { 'text-decoration': 'underline' },
            },
          });
          t.commands.add(CF, new zT(t, CF));
          t.keystrokes.set('CTRL+U', 'underline');
        }
      }
      const xF =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
      const EF = 'underline';
      class DF extends nt {
        static get pluginName() {
          return 'UnderlineUI';
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(EF, (n) => {
            const i = t.commands.get(EF);
            const o = new iv(n);
            o.set({
              label: e('Underline'),
              icon: xF,
              keystroke: 'CTRL+U',
              tooltip: true,
              isToggleable: true,
            });
            o.bind('isOn', 'isEnabled').to(i, 'value', 'isEnabled');
            this.listenTo(o, 'execute', () => {
              t.execute(EF);
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class SF extends nt {
        static get requires() {
          return [yF, DF];
        }
        static get pluginName() {
          return 'Underline';
        }
      }
      class TF extends tx {}
      TF.builtinPlugins = [
        kx,
        CS,
        BT,
        VT,
        tB,
        AB,
        DB,
        GB,
        rP,
        MP,
        UI,
        rR,
        NR,
        BI,
        jR,
        KR,
        tz,
        Rz,
        AO,
        EO,
        IO,
        GP,
        QO,
        XO,
        tF,
        oF,
        nF,
        eF,
        iF,
        dF,
        pF,
        AF,
        SF,
      ];
      TF.defaultConfig = {
        toolbar: {
          items: [
            'alignment',
            'bold',
            'italic',
            'underline',
            'strikethrough',
            '|',
            'highlight',
            'fontSize',
            'fontColor',
            'fontBackgroundColor',
            '|',
            'link',
            'specialCharacters',
            'subscript',
            'superscript',
            'removeFormat',
            '|',
            'bulletedList',
            'numberedList',
            'outdent',
            'indent',
            '|',
            'imageUpload',
            'imageInsert',
            '|',
            'undo',
            'redo',
          ],
        },
        language: 'ru',
      };
      const BF = TF;
    })();
    i = i['default'];
    return i;
  })()
);
//# sourceMappingURL=ckeditor.js.map
